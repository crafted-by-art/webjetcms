<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sk"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GroupsDB.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">webjet8v9</a> &gt; <a href="index.source.html" class="el_package">sk.iway.iwcm.doc</a> &gt; <span class="el_source">GroupsDB.java</span></div><h1>GroupsDB.java</h1><pre class="source lang-java linenums">package sk.iway.iwcm.doc;

import org.apache.commons.beanutils.BeanUtils;
import org.apache.struts.util.ResponseUtils;

import sk.iway.iwcm.*;
import sk.iway.iwcm.common.CloudToolsForCore;
import sk.iway.iwcm.common.FilePathTools;
import sk.iway.iwcm.common.UserTools;
import sk.iway.iwcm.database.ComplexQuery;
import sk.iway.iwcm.database.Mapper;
import sk.iway.iwcm.database.SimpleQuery;
import sk.iway.iwcm.helpers.BeanDiff;
import sk.iway.iwcm.helpers.BeanDiffPrinter;
import sk.iway.iwcm.i18n.Prop;
import sk.iway.iwcm.io.IwcmFile;
import sk.iway.iwcm.system.cluster.ClusterDB;
import sk.iway.iwcm.system.spring.events.WebjetEvent;
import sk.iway.iwcm.system.spring.events.WebjetEventType;
import sk.iway.iwcm.users.UserDetails;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

import static sk.iway.iwcm.Tools.isEmpty;

/**
 *  Drzi obsah tabulky groups
 *
 *@Title        Interway Content Management
 *@Company      Interway s.r.o. (www.interway.sk)
 *@Copyright    Interway s.r.o. (c) 2001-2002
 *@author       $Author: jeeff $
 *@version      $Revision: 1.18 $
 *@created      $Date: 2004/03/25 17:36:09 $
 *@modified     $Date: 2004/03/25 17:36:09 $
 */
public class GroupsDB extends DB
{

	private List&lt;GroupDetails&gt; groups;
	//cache pre zobrazenie stromovej struktury stranok (pri velkych sidlach sa to dlho a zbytocne nacitavalo dookola)
<span class="fc" id="L49">	private List&lt;GroupDetails&gt; groupsTreeAllCache = null;</span>

	private Map&lt;Integer, GroupDetails&gt; idToGroups;
	private Map&lt;String,Integer&gt; domainIds;

	private final String serverName;

<span class="fc" id="L56">	public static final Comparator&lt;GroupDetails&gt; groupsDbSorter = new Comparator&lt;GroupDetails&gt;(){</span>
		@Override
		public int compare(GroupDetails group1, GroupDetails group2)
		{
<span class="fc bfc" id="L60" title="All 2 branches covered.">			return 	group1.getSortPriority() - group2.getSortPriority() != 0 ?</span>
<span class="fc" id="L61">						group1.getSortPriority() - group2.getSortPriority() :</span>
<span class="fc" id="L62">						group1.getGroupId() - group2.getGroupId();</span>
		}
	};

<span class="fc" id="L66">	public static final Comparator&lt;GroupDetails&gt; nameSorter = new Comparator&lt;GroupDetails&gt;()</span>
<span class="fc" id="L67">	{</span>
		@Override
		public int compare(GroupDetails group1, GroupDetails group2)
		{
<span class="nc" id="L71">			return Tools.slovakCollator.compare(group1.getGroupName(), group2.getGroupName());</span>
		}
	};


	/**
	 * vrati instanciu triedy
	 * @return
	 */
	public static GroupsDB getInstance()
	{
<span class="fc" id="L82">		return(getInstance(false));</span>
	}

	/**
	 * vrati instanciu triedy
	 * @param forceRefresh
	 * @return
	 */
	public static GroupsDB getInstance(boolean forceRefresh)
	{
<span class="fc" id="L92">		return(getInstance(Constants.getServletContext(), forceRefresh, &quot;iwcm&quot;)); //NOSONAR</span>
	}

	/**
	 *  Gets the instance attribute of the GroupsDB class
	 *
	 *@param  servletContext  Description of the Parameter
	 *@param  force_refresh   Description of the Parameter
	 *@param  serverName      Description of the Parameter
	 *@return                 The instance value
	 *@deprecated - pouzite verziu getInstance(boolean forceRefresh)
	 */
	@Deprecated
	public static GroupsDB getInstance(javax.servlet.ServletContext servletContext, boolean force_refresh, String serverName)
	{
		//try to get it from server space
<span class="fc bfc" id="L108" title="All 2 branches covered.">		if (force_refresh == false)</span>
		{
<span class="fc" id="L110">			GroupsDB groupsDB = ((GroupsDB) servletContext.getAttribute(Constants.A_GROUPS_DB));</span>
			//Logger.println(this,&quot;GroupsDB: getting from server space&quot;);
<span class="pc bpc" id="L112" title="1 of 4 branches missed.">			if (groupsDB != null &amp;&amp; groupsDB.groups!=null) // fix MBO: ak groups je null, zbehne force refresh</span>
			{
<span class="fc" id="L114">				return groupsDB;</span>
			}
		}
<span class="fc" id="L117">		synchronized (GroupsDB.class)</span>
		{
<span class="fc bfc" id="L119" title="All 2 branches covered.">			if (force_refresh)</span>
			{
<span class="fc" id="L121">				GroupsDB groupsDB = new GroupsDB(servletContext, serverName);</span>
				//	remove
<span class="fc" id="L123">				servletContext.removeAttribute(Constants.A_GROUPS_DB);</span>
				//save us to server space
<span class="fc" id="L125">				servletContext.setAttribute(Constants.A_GROUPS_DB, groupsDB);</span>

<span class="fc" id="L127">				return groupsDB;</span>
			}
			else
			{
<span class="fc" id="L131">				GroupsDB groupsDB = (GroupsDB) servletContext.getAttribute(Constants.A_GROUPS_DB);</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">				if (groupsDB == null)</span>
				{
<span class="fc" id="L134">					groupsDB = new GroupsDB(servletContext, serverName);</span>
					//	remove
<span class="fc" id="L136">					servletContext.removeAttribute(Constants.A_GROUPS_DB);</span>
					//save us to server space
<span class="fc" id="L138">					servletContext.setAttribute(Constants.A_GROUPS_DB, groupsDB);</span>

				}
<span class="fc" id="L141">				return groupsDB;</span>
			}
		}
	}

	/**
	 *  Constructor for the GroupsDB object
	 *
	 *@param  servletContext  Description of the Parameter
	 *@param  serverName      Description of the Parameter
	 */
	private GroupsDB(javax.servlet.ServletContext servletContext, String serverName)
<span class="fc" id="L153">	{</span>
<span class="fc" id="L154">		Logger.println(this,&quot;GroupsDB: constructor [&quot; + Constants.getInstallName()+&quot;]&quot;);</span>
<span class="fc" id="L155">		this.serverName = serverName;</span>

		try
		{
<span class="fc" id="L159">			reloadGroups();</span>
		}
<span class="nc" id="L161">		catch (Exception ex)</span>
		{
<span class="nc" id="L163">			sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L164">		}</span>

<span class="fc" id="L166">		ClusterDB.addRefresh(GroupsDB.class);</span>
<span class="fc" id="L167">		Cache.getInstance().removeObjectStartsWithName(&quot;GroupsDB.&quot;);</span>
<span class="fc" id="L168">	}</span>

	/**
	 *  Description of the Method
	 *
	 *@exception  Exception  Description of the Exception
	 */
	public void reloadGroups() throws Exception
	{
<span class="fc" id="L177">		DebugTimer dt = new DebugTimer(&quot;GroupsDB.reloadGroups&quot;);</span>

		//ak vieme predchadzajucu velkost, tak si ju vopred predalokujeme
<span class="fc" id="L180">		List&lt;GroupDetails&gt; groupsHolderWhileLoading = new CopyOnWriteArrayList&lt;&gt;(); //Collections.synchronizedList(new ArrayList&lt;&gt;(groups!=null?groups.size():300));</span>
		//ak existuje, tak si vopred predalokuj dost miesta pre kluce
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">		Map&lt;Integer, GroupDetails&gt; idToGroupsHolderWhileLoading = Collections.synchronizedMap(new HashMap&lt;Integer, GroupDetails&gt;(idToGroups!=null?idToGroups.size():300));</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">		Map&lt;String,GroupDetails&gt; domainIdsGroups = Collections.synchronizedMap(new HashMap&lt;String, GroupDetails&gt;(domainIds!=null?domainIds.size():100));</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">		Map&lt;String,Integer&gt; domainIdsHolderWhileLoading = Collections.synchronizedMap(new HashMap&lt;String, Integer&gt;(domainIds!=null?domainIds.size():100));</span>

<span class="fc" id="L186">		java.sql.Connection db_conn = null;</span>
<span class="fc" id="L187">		java.sql.PreparedStatement ps = null;</span>
<span class="fc" id="L188">		java.sql.ResultSet rs = null;</span>
		try
		{
<span class="fc" id="L191">			dt.diff(&quot;after objects&quot;);</span>

<span class="fc" id="L193">			db_conn = DBPool.getConnection(serverName);</span>
<span class="fc" id="L194">			String sql = &quot;SELECT * FROM groups ORDER BY sort_priority, group_name&quot;;</span>
<span class="fc" id="L195">			ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L196">			rs = ps.executeQuery();</span>

<span class="fc" id="L198">			dt.diff(&quot;after rs&quot;);</span>

<span class="fc bfc" id="L200" title="All 2 branches covered.">			while (rs.next())</span>
			{
<span class="fc" id="L202">				GroupDetails group = fillFieldsByResultSet(rs);</span>

<span class="fc" id="L204">				groupsHolderWhileLoading.add(group);</span>
<span class="fc" id="L205">				idToGroupsHolderWhileLoading.put(group.getGroupId(), group);</span>
<span class="fc bfc" id="L206" title="All 4 branches covered.">				if(Tools.isNotEmpty(group.getDomainName()) &amp;&amp; group.getParentGroupId() == 0)</span>
				{
<span class="fc" id="L208">					GroupDetails domainGroup = domainIdsGroups.get(group.getDomainName());</span>
					//ako domainId bereme groupId, ktore ma najnizsie ID, aby sa prvo vytvoreny priecinok v domene zachoval
<span class="fc bfc" id="L210" title="All 4 branches covered.">					if (domainGroup==null || group.getGroupId()&lt;domainGroup.getGroupId())</span>
					{

<span class="fc" id="L213">						domainIdsGroups.put(group.getDomainName(), group);</span>
						//pomocou konf. premennej domainId-www.domena.sk je mozne nastavit fixne ID, napr. ak zmazeme povodny korenovy priecinok domeny
<span class="fc" id="L215">						int constantDomainId = Constants.getInt(&quot;domainId-&quot;+group.getDomainName());</span>
<span class="fc" id="L216">						int domainId = group.getGroupId();</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">						if (constantDomainId&gt;0) domainId = constantDomainId;</span>
<span class="fc" id="L218">						domainIdsHolderWhileLoading.put(group.getDomainName(), domainId);</span>
					}
				}
<span class="fc" id="L221">			}</span>
<span class="fc" id="L222">			rs.close();</span>
<span class="fc" id="L223">			ps.close();</span>
<span class="fc" id="L224">			db_conn.close();</span>
<span class="fc" id="L225">			db_conn = null;</span>
<span class="fc" id="L226">			ps = null;</span>
<span class="fc" id="L227">			rs = null;</span>

<span class="fc" id="L229">			groups = groupsHolderWhileLoading;</span>
<span class="fc" id="L230">			idToGroups = idToGroupsHolderWhileLoading;</span>
<span class="fc" id="L231">			domainIds = domainIdsHolderWhileLoading;</span>

<span class="fc" id="L233">			dt.diff(&quot;after db load&quot;);</span>

			//nastav full path
<span class="fc bfc" id="L236" title="All 2 branches covered.">			for (GroupDetails group : groups)</span>
			{
<span class="fc" id="L238">				group.setFullPath(getPath(group.getGroupId()));</span>
<span class="fc" id="L239">			}</span>

<span class="fc" id="L241">			dt.diff(&quot;after full path&quot;);</span>

<span class="fc" id="L243">			getAllSystemFolders(true);</span>

<span class="fc" id="L245">			dt.diff(&quot;after system folders&quot;);</span>
		}
<span class="nc" id="L247">		catch (Exception ex){sk.iway.iwcm.Logger.error(ex);}</span>
		finally{
			try{
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">				if (rs != null) rs.close();</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">				if (ps != null) ps.close();</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">				if (db_conn != null) db_conn.close();</span>
<span class="pc" id="L253">			}catch (Exception e) {sk.iway.iwcm.Logger.error(e);}</span>
		}

<span class="fc" id="L256">		dt.diff(&quot;done&quot;);</span>
<span class="fc" id="L257">	}</span>

	/**
	 * Naplni objekt z result setu
	 * @param rs
	 * @return
	 * @throws SQLException
	 */
	public static GroupDetails fillFieldsByResultSet(java.sql.ResultSet rs) throws SQLException
	{
		GroupDetails group;
<span class="fc" id="L268">		group = new GroupDetails();</span>
<span class="fc" id="L269">		group.setGroupId(rs.getInt(&quot;group_id&quot;));</span>
<span class="fc" id="L270">		group.setGroupName(getDbString(rs, &quot;group_name&quot;));</span>
<span class="fc" id="L271">		group.setInternal(rs.getBoolean(&quot;internal&quot;));</span>
<span class="fc" id="L272">		group.setParentGroupId(rs.getInt(&quot;parent_group_id&quot;));</span>
<span class="fc" id="L273">		group.setNavbar(getDbString(rs, &quot;navbar&quot;));</span>
<span class="fc" id="L274">		group.setDefaultDocId(rs.getInt(&quot;default_doc_id&quot;));</span>
<span class="fc" id="L275">		group.setTempId(rs.getInt(&quot;temp_id&quot;));</span>
<span class="fc" id="L276">		group.setSortPriority(rs.getInt(&quot;sort_priority&quot;));</span>
<span class="fc" id="L277">		group.setPasswordProtected(getDbString(rs, &quot;password_protected&quot;));</span>
<span class="fc" id="L278">		group.setMenuType(rs.getInt(&quot;menu_type&quot;));</span>
<span class="fc" id="L279">		group.setUrlDirName(getDbString(rs, &quot;url_dir_name&quot;));</span>
<span class="fc" id="L280">		group.setSyncId(rs.getInt(&quot;sync_id&quot;));</span>
<span class="fc" id="L281">		group.setSyncStatus(rs.getInt(&quot;sync_status&quot;));</span>
<span class="fc" id="L282">		group.setHtmlHead(DB.getDbString(rs, &quot;html_head&quot;));</span>
<span class="fc" id="L283">		group.setLogonPageDocId(rs.getInt(&quot;logon_page_doc_id&quot;));</span>

		//	domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d
<span class="fc" id="L286">		group.setDomainName(DB.getDbString(rs, &quot;domain_name&quot;));</span>
<span class="fc" id="L287">		group.setNewPageDocIdTemplate(rs.getInt(&quot;new_page_docid_template&quot;));</span>
<span class="fc" id="L288">		group.setInstallName(DB.getDbString(rs, &quot;install_name&quot;));</span>
<span class="fc" id="L289">		group.setFieldA(DB.getDbString(rs, &quot;field_a&quot;));</span>
<span class="fc" id="L290">		group.setFieldB(DB.getDbString(rs, &quot;field_b&quot;));</span>
<span class="fc" id="L291">		group.setFieldC(DB.getDbString(rs, &quot;field_c&quot;));</span>
<span class="fc" id="L292">		group.setFieldD(DB.getDbString(rs, &quot;field_d&quot;));</span>

<span class="fc" id="L294">		group.setLoggedMenuType(rs.getInt(&quot;logged_menu_type&quot;));</span>
<span class="fc" id="L295">		group.setLinkGroupId(rs.getInt(&quot;link_group_id&quot;));</span>
<span class="fc" id="L296">		group.setLng(rs.getString(&quot;lng&quot;));</span>
<span class="fc" id="L297">		group.setHiddenInAdmin(rs.getBoolean(&quot;hidden_in_admin&quot;));</span>
<span class="fc" id="L298">		group.setForceTheUseOfGroupTemplate(rs.getBoolean(&quot;force_group_template&quot;));</span>

<span class="fc" id="L300">		DataAccessHelper.groupLoadData(rs, group);</span>

<span class="fc" id="L302">		return group;</span>
	}


	/**
	 * Naplni objekt GroupSchedulerDetails z result setu
	 * @param rs
	 * @return
	 * @throws SQLException
	 */
	public static GroupSchedulerDetails fillFieldsByResultSetFromScheduler(java.sql.ResultSet rs) throws SQLException
	{
		GroupSchedulerDetails groupScheduler;
<span class="nc" id="L315">		groupScheduler = new GroupSchedulerDetails();</span>
<span class="nc" id="L316">		groupScheduler.setGroupId(rs.getInt(&quot;group_id&quot;));</span>
<span class="nc" id="L317">		groupScheduler.setGroupName(getDbString(rs, &quot;group_name&quot;));</span>
<span class="nc" id="L318">		groupScheduler.setInternal(rs.getBoolean(&quot;internal&quot;));</span>
<span class="nc" id="L319">		groupScheduler.setParentGroupId(rs.getInt(&quot;parent_group_id&quot;));</span>
<span class="nc" id="L320">		groupScheduler.setNavbar(getDbString(rs, &quot;navbar&quot;));</span>
<span class="nc" id="L321">		groupScheduler.setDefaultDocId(rs.getInt(&quot;default_doc_id&quot;));</span>
<span class="nc" id="L322">		groupScheduler.setTempId(rs.getInt(&quot;temp_id&quot;));</span>
<span class="nc" id="L323">		groupScheduler.setSortPriority(rs.getInt(&quot;sort_priority&quot;));</span>
<span class="nc" id="L324">		groupScheduler.setPasswordProtected(getDbString(rs, &quot;password_protected&quot;));</span>
<span class="nc" id="L325">		groupScheduler.setMenuType(rs.getInt(&quot;menu_type&quot;));</span>
<span class="nc" id="L326">		groupScheduler.setUrlDirName(getDbString(rs, &quot;url_dir_name&quot;));</span>
<span class="nc" id="L327">		groupScheduler.setSyncId(rs.getInt(&quot;sync_id&quot;));</span>
<span class="nc" id="L328">		groupScheduler.setSyncStatus(rs.getInt(&quot;sync_status&quot;));</span>
<span class="nc" id="L329">		groupScheduler.setHtmlHead(DB.getDbString(rs, &quot;html_head&quot;));</span>
<span class="nc" id="L330">		groupScheduler.setLogonPageDocId(rs.getInt(&quot;logon_page_doc_id&quot;));</span>

		//	domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d
<span class="nc" id="L333">		groupScheduler.setDomainName(DB.getDbString(rs, &quot;domain_name&quot;));</span>
<span class="nc" id="L334">		groupScheduler.setNewPageDocIdTemplate(rs.getInt(&quot;new_page_docid_template&quot;));</span>
<span class="nc" id="L335">		groupScheduler.setInstallName(DB.getDbString(rs, &quot;install_name&quot;));</span>
<span class="nc" id="L336">		groupScheduler.setFieldA(DB.getDbString(rs, &quot;field_a&quot;));</span>
<span class="nc" id="L337">		groupScheduler.setFieldB(DB.getDbString(rs, &quot;field_b&quot;));</span>
<span class="nc" id="L338">		groupScheduler.setFieldC(DB.getDbString(rs, &quot;field_c&quot;));</span>
<span class="nc" id="L339">		groupScheduler.setFieldD(DB.getDbString(rs, &quot;field_d&quot;));</span>

<span class="nc" id="L341">		groupScheduler.setLoggedMenuType(rs.getInt(&quot;logged_menu_type&quot;));</span>
<span class="nc" id="L342">		groupScheduler.setLinkGroupId(rs.getInt(&quot;link_group_id&quot;));</span>

		//groupScheduler
<span class="nc" id="L345">		groupScheduler.setUserId(rs.getInt(&quot;user_id&quot;));</span>
<span class="nc" id="L346">		groupScheduler.setSaveDate(rs.getTimestamp(&quot;save_date&quot;));</span>
<span class="nc" id="L347">		groupScheduler.setScheduleId(rs.getInt(&quot;schedule_id&quot;));</span>
<span class="nc" id="L348">		groupScheduler.setWhenToPublish(rs.getTimestamp(&quot;when_to_publish&quot;));</span>

<span class="nc" id="L350">		groupScheduler.setLng(rs.getString(&quot;lng&quot;));</span>
<span class="nc" id="L351">		groupScheduler.setHiddenInAdmin(rs.getBoolean(&quot;hidden_in_admin&quot;));</span>
<span class="nc" id="L352">		groupScheduler.setForceTheUseOfGroupTemplate(rs.getBoolean(&quot;force_group_template&quot;));</span>

<span class="nc" id="L354">		DataAccessHelper.groupLoadData(rs, groupScheduler);</span>

<span class="nc" id="L356">		return groupScheduler;</span>
	}

	/**
	 *  Vrati zoznam skupin v danej skupine
	 *
	 *@param  parent  Description of the Parameter
	 *@return         The groups value
	 */
	public List&lt;GroupDetails&gt; getGroups(int parent)
	{
<span class="fc" id="L367">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">		for (GroupDetails group : groups)</span>
		{
<span class="fc bfc" id="L370" title="All 2 branches covered.">			if (group.getParentGroupId() == parent)</span>
			{
<span class="fc" id="L372">				ret.add(group);</span>
			}
<span class="fc" id="L374">		}</span>
<span class="fc" id="L375">		return (ret);</span>
	}

	/**
	 * Vrati zoznam skupin v danej skupine dostupnych v menu
	 * @param parent
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsAvailableInMenu(int parent)
	{
<span class="nc" id="L385">		return getGroupsAvailableInMenu(parent, null);</span>
	}

	 /**
	  * Vrati zoznam skupin v danej skupine dostupnych v menu, testuje menuType pre prihlaseneho usera
	  * @param parent
	  * @param session
	  * @return
	  */
	 public List&lt;GroupDetails&gt; getGroupsAvailableInMenu(int parent, HttpSession session)
	 {
<span class="nc" id="L396">		  List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">		 for (GroupDetails group : groups)</span>
		  {
<span class="nc bnc" id="L399" title="All 6 branches missed.">				if (group.getParentGroupId() == parent &amp;&amp; group.isInternal()==false &amp;&amp; group.getMenuType(session)!=GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L401">					 ret.add(group);</span>
				}
<span class="nc" id="L403">		  }</span>
<span class="nc" id="L404">		  return (ret);</span>
	 }

	/**
	 *  Vrati GroupDetails so zadanym ID
	 *
	 *@param  group_id - id adresara
	 *@return           The group value
	 */
	public GroupDetails getGroup(int group_id)
	{
<span class="fc" id="L415">		return idToGroups.get(group_id);</span>
	}

	/**
	 * Ziska adresar podla zadanej full path
	 * @param fullPath
	 * @return
	 */
	public GroupDetails getGroupByPath(String fullPath)
	{
<span class="pc bpc" id="L425" title="3 of 4 branches missed.">		if (fullPath.endsWith(&quot;/&quot;) &amp;&amp; fullPath.length()&gt;1)</span>
		{
			//odstran koncove lomitko
<span class="nc" id="L428">			fullPath = fullPath.substring(0, fullPath.length()-1);</span>
		}

<span class="fc" id="L431">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="fc" id="L432">		GroupDetails firstGroup = null;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">		for (GroupDetails group : getGroupsAll())</span>
		{
<span class="fc bfc" id="L435" title="All 2 branches covered.">			if (group.getFullPath().equals(fullPath))</span>
			{
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">				if (firstGroup == null) firstGroup = group;</span>
<span class="pc bpc" id="L438" title="3 of 6 branches missed.">				if (rb != null &amp;&amp; Tools.isNotEmpty(rb.getDomain()) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true) {</span>
					//mame presnu zhodu aj podla domenoveho mena
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">					if (rb.getDomain().equals(group.getDomainName())) return group;</span>
				}
			}
<span class="fc" id="L443">		}</span>
<span class="fc" id="L444">		return firstGroup;</span>
	}



	/**
	 *  Gets the group attribute of the GroupsDB object
	 *
	 *@param  groupName  Description of the Parameter
	 *@return           The group value
	 */
	public GroupDetails getGroup(String groupName)
	{
<span class="nc" id="L457">		return getGroup(groupName,false);</span>
	}

	/**
	 *  Gets the group attribute of the GroupsDB object
	 *
	 *@param  groupName  Description of the Parameter
	 *@param internationalToEnglish ci sa maju nazvy adresarov upravit z international do english
	 *@return           The group value
	 */
	public GroupDetails getGroup(String groupName, boolean internationalToEnglish)
	{
<span class="nc" id="L469">		groupName = sanitizeGroupName(groupName, true);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">		if (Tools.isNotEmpty(groupName))</span>
		{
<span class="nc bnc" id="L472" title="All 2 branches missed.">			for (GroupDetails group : getGroupsAll())</span>
			{
<span class="nc bnc" id="L474" title="All 2 branches missed.">				if(internationalToEnglish)</span>
				{
<span class="nc bnc" id="L476" title="All 2 branches missed.">					if (DB.internationalToEnglish(groupName).equalsIgnoreCase(DB.internationalToEnglish(group.getGroupName())))</span>
					{
<span class="nc" id="L478">						return (group);</span>
					}
				}
				else
				{
<span class="nc bnc" id="L483" title="All 2 branches missed.">					if (groupName.equalsIgnoreCase(group.getGroupName()))</span>
					{
<span class="nc" id="L485">						return (group);</span>
					}
				}
<span class="nc" id="L488">			}</span>
		}
<span class="nc" id="L490">		return (null);</span>
	}

	/**
	 * Ziska adresar so zadanym menom v zadanom adresari
	 * @param groupName
	 * @param parentGroupId
	 * @return
	 */
	public GroupDetails getGroup(String groupName, int parentGroupId)
	{
<span class="fc" id="L501">		GroupDetails firstGroup = null;</span>
<span class="fc" id="L502">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="fc" id="L503">		groupName = sanitizeGroupName(groupName, true);</span>
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">		if (Tools.isNotEmpty(groupName))</span>
		{
<span class="fc bfc" id="L506" title="All 2 branches covered.">			for (GroupDetails group : getGroupsAll())</span>
			{
<span class="fc bfc" id="L508" title="All 4 branches covered.">				if (group.getParentGroupId() == parentGroupId &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()))</span>
				{
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">					if (firstGroup==null) firstGroup = group;</span>
<span class="pc bpc" id="L511" title="3 of 6 branches missed.">					if (rb != null &amp;&amp; Tools.isNotEmpty(rb.getDomain()) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true) {</span>
						//mame presnu zhodu aj podla domenoveho mena
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">						if (rb.getDomain().equals(group.getDomainName())) return group;</span>
					}
				}
<span class="fc" id="L516">			}</span>
		}
<span class="fc" id="L518">		return (firstGroup);</span>
	}

	 /**
	  * Ziska adresar so zadanym menom v zadanom adresari, ak neexistuje tak ho vytvori
	  * @param groupName
	  * @param parentGroupId
	  * @return
	  */
	public GroupDetails getOrCreateGroup(String groupName, int parentGroupId)
	{
<span class="nc" id="L529">		 GroupDetails group = getGroup(groupName, parentGroupId);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">		 if (group == null) {</span>
<span class="nc" id="L531">			  group = addNewGroup(groupName, parentGroupId);</span>
		 }
<span class="nc" id="L533">		 return group;</span>
	}


	/**
	 *  Ziska stromovu strukturu adresarov
	 *
	 *@return    The groupsTree value
	 */
	public List&lt;GroupDetails&gt; getGroupsTree()
	{
<span class="nc" id="L544">		List&lt;GroupDetails&gt; p_groups = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L545">		getGroupsTree(0, p_groups, true);</span>
<span class="nc" id="L546">		return (p_groups);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov iba pre userom editovatelne adresare
	 * @param editableGroups
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(String editableGroups)
	{
		//cache pre groupslist-tree.jsp
<span class="nc bnc" id="L557" title="All 4 branches missed.">		if (Tools.isEmpty(editableGroups) &amp;&amp; groupsTreeAllCache!=null)</span>
		{
<span class="nc" id="L559">			Logger.debug(GroupsDB.class, &quot;getGroupsTree - returning from cache&quot;);</span>
<span class="nc" id="L560">			List&lt;GroupDetails&gt; cloned = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L561">			cloned.addAll(groupsTreeAllCache);</span>
<span class="nc" id="L562">			return cloned;</span>
		}

<span class="nc" id="L565">		List&lt;GroupDetails&gt; p_groups = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L567" title="All 4 branches missed.">		if (editableGroups != null &amp;&amp; editableGroups.length() &gt; 0)</span>
		{
<span class="nc" id="L569">			StringTokenizer st = new StringTokenizer(editableGroups, &quot;,&quot;);</span>
			String id;
			int i_id;
<span class="nc bnc" id="L572" title="All 2 branches missed.">			while (st.hasMoreTokens())</span>
			{
<span class="nc" id="L574">				id = st.nextToken().trim();</span>
				try
				{
<span class="nc" id="L577">					i_id = Integer.parseInt(id);</span>
					//pridaj to do stromu editovatelnych stranok
<span class="nc" id="L579">					GroupDetails parentGroup = findGroup(i_id);</span>
<span class="nc" id="L580">					GroupDetails parentGroupCopy = new GroupDetails(parentGroup);</span>
<span class="nc" id="L581">					parentGroupCopy.setParentGroupId(0);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">					if (parentGroup.getFullPath().length() &gt; 200)</span>
					{
<span class="nc" id="L584">						parentGroupCopy.setGroupName(&quot;...&quot;+parentGroup.getFullPath().substring(parentGroup.getFullPath().length()-198));</span>
					}
					else
					{
<span class="nc" id="L588">						parentGroupCopy.setGroupName(parentGroup.getFullPath());</span>
					}
<span class="nc" id="L590">					p_groups.add(parentGroupCopy);</span>
<span class="nc" id="L591">					getGroupsTree(i_id, p_groups, true);</span>
				}
<span class="nc" id="L593">				catch (Exception ex)</span>
				{

<span class="nc" id="L596">				}</span>
			}
<span class="nc" id="L598">		}</span>
		else
		{
<span class="nc" id="L601">			getGroupsTree(0, p_groups, true);</span>

<span class="nc bnc" id="L603" title="All 2 branches missed.">			if (Tools.isEmpty(editableGroups))</span>
			{
<span class="nc" id="L605">				groupsTreeAllCache = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L606">				groupsTreeAllCache.addAll(p_groups);</span>
<span class="nc" id="L607">				Logger.debug(GroupsDB.class, &quot;getGroupsTree - SETTING cache&quot;);</span>
			}
		}

<span class="nc" id="L611">		return (p_groups);</span>
	}


	/**
	 *  Ziska stromovu strukturu adresarov
	 *
	 *@param  parent          rodicovsky adresar
	 *@param  includeParent  ak true, vratane rodica
	 *@param  includeInternals ak true, vratane internych adresarov
	 *@return                 The groupsTree value
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(int parent, boolean includeParent, boolean includeInternals)
	{
<span class="fc" id="L625">		return getGroupsTree(parent, includeParent, includeInternals, false);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov
	 * @param parent -  rodicovsky adresar
	 * @param includeParent - ak true, vratane rodica
	 * @param includeInternals - ak true, vratane internych adresarov
	 * @param onlyAvailableInMenu - ak true, iba dostupne v menu
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsTree(int parent, boolean includeParent, boolean includeInternals, boolean onlyAvailableInMenu)
	{
<span class="fc" id="L638">		List&lt;GroupDetails&gt; p_groups = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">		if (includeParent)</span>
		{
<span class="fc" id="L641">			GroupDetails parentGroup = findGroup(parent);</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">			if (parentGroup != null) p_groups.add(parentGroup);</span>
		}
<span class="fc" id="L644">		getGroupsTree(parent, p_groups, includeInternals, onlyAvailableInMenu);</span>
<span class="fc" id="L645">		return (p_groups);</span>
	}

	/**
	 * Ziska stromovu strukturu adresarov. Rekurzivna metoda!
	 * @param parent
	 * @param p_groups
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups)
	{
<span class="nc" id="L655">		getGroupsTree(parent, p_groups, true);</span>
<span class="nc" id="L656">	}</span>

	/**
	 *  Ziska stromovu strukturu adresarov. Rekurzivna metoda!
	 *
	 *@param  parent    rodicovsky adresar
	 *@param  p_groups  array list, do ktoreho sa to plni
	 *@param  includeInternals ak true, vratane internych adresarov
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals)
	{
<span class="nc" id="L667">		getGroupsTree(parent, p_groups, includeInternals, false);</span>
<span class="nc" id="L668">	}</span>

	/**
	 *
	 * @param parent
	 * @param p_groups
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 */
	public void getGroupsTree(int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals, boolean onlyAvailableInMenu)
	{
<span class="fc" id="L679">		Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable = prepareChildsTable();</span>
<span class="fc" id="L680">		getGroupsTree(childsTable, parent, p_groups, includeInternals, onlyAvailableInMenu, 1);</span>
<span class="fc" id="L681">	}</span>

	/**
	 * Pripravi hash tabulku kde klucom je groupId a hodnotou je zoznam childov
	 * @return
	 */
	private Map&lt;Integer, List&lt;GroupDetails&gt;&gt; prepareChildsTable()
	{
<span class="fc" id="L689">		Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable = new Hashtable&lt;&gt;();</span>

<span class="fc bfc" id="L691" title="All 2 branches covered.">		for (GroupDetails group : groups)</span>
		{
<span class="fc" id="L693">			List&lt;GroupDetails&gt; childsList = childsTable.get(group.getParentGroupId());</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">			if (childsList == null)</span>
			{
<span class="fc" id="L696">				childsList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L697">				childsTable.put(group.getParentGroupId(), childsList);</span>
			}
<span class="fc" id="L699">			childsList.add(group);</span>
<span class="fc" id="L700">		}</span>

<span class="fc" id="L702">		return childsTable;</span>
	}

	/**
	 * Do listu p_groups rekurzivne naplni zoznam childov pre zadane parent group id
	 * @param childsTable
	 * @param parent
	 * @param p_groups
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 */
	private void getGroupsTree(Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable, int parent, List&lt;GroupDetails&gt; p_groups, boolean includeInternals, boolean onlyAvailableInMenu, int iteration)
	{
<span class="fc" id="L715">		List&lt;GroupDetails&gt; childs = childsTable.get(parent);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">		if (childs == null) return;</span>

<span class="pc bpc" id="L718" title="1 of 2 branches missed.">		if (iteration &gt; 500) return;</span>

<span class="fc" id="L720">		GroupDetails system = null;</span>

<span class="fc bfc" id="L722" title="All 2 branches covered.">		for (GroupDetails group : childs)</span>
		{
<span class="fc bfc" id="L724" title="All 4 branches covered.">			if (includeInternals == false &amp;&amp; group.isInternal()) continue;</span>
<span class="pc bpc" id="L725" title="3 of 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_HIDDEN) continue;</span>

<span class="pc bpc" id="L727" title="3 of 4 branches missed.">			if (&quot;cloud&quot;.equals(Constants.getInstallName()) &amp;&amp; &quot;System&quot;.equals(group.getGroupName()))</span>
			{
				//system grupu presunieme uplne na koniec
<span class="nc" id="L730">				system = group;</span>
<span class="nc" id="L731">				continue;</span>
			}

<span class="fc" id="L734">			p_groups.add(group);</span>

<span class="pc bpc" id="L736" title="3 of 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_NOSUB) continue;</span>

			//recursive call
<span class="fc" id="L739">			getGroupsTree(childsTable, group.getGroupId(), p_groups, includeInternals, onlyAvailableInMenu, iteration);</span>
<span class="fc" id="L740">		}</span>

<span class="pc bpc" id="L742" title="1 of 2 branches missed.">		if (system != null)</span>
		{
<span class="nc" id="L744">			p_groups.add(system);</span>
<span class="nc bnc" id="L745" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; system.getMenuType()==GroupDetails.MENU_TYPE_NOSUB)</span>
			{
				//continue;
			}
			else
			{
				//recursive call
<span class="nc" id="L752">				getGroupsTree(childsTable, system.getGroupId(), p_groups, includeInternals, onlyAvailableInMenu, iteration);</span>
			}
		}
<span class="fc" id="L755">	}</span>

	/**
	 * Vytvori List parent adresarov pre rendering v select boxe namiesto standardneho vyberu, kazde meno adresara je odsadene medzerami aby bola zrozumitelna struktura
	 * @param parent
	 * @param includeParent
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 * @return
	 */
	public List&lt;LabelValueDetails&gt; getGroupsTreeForSelect(int parent, boolean includeParent, boolean includeInternals, boolean onlyAvailableInMenu)
	{
<span class="nc" id="L767">		List&lt;LabelValueDetails&gt; list = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L769">		int level = 0;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">		if (includeParent)</span>
		{
<span class="nc" id="L772">			GroupDetails parentGroup = findGroup(parent);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">			if (parentGroup != null) list.add(new LabelValueDetails(parentGroup.getGroupName(), String.valueOf(parentGroup.getGroupId())));</span>
<span class="nc" id="L774">			level++;</span>
		}

<span class="nc" id="L777">		Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable = prepareChildsTable();</span>
<span class="nc" id="L778">		getGroupsTreeForSelect(childsTable, parent, list, includeInternals, onlyAvailableInMenu, level);</span>

<span class="nc" id="L780">		return list;</span>
	}

	/**
	 * Vytvori List parent adresarov pre rendering v select boxe namiesto standardneho vyberu, kazde meno adresara je odsadene medzerami aby bola zrozumitelna struktura
	 * @param childsTable
	 * @param parent
	 * @param list
	 * @param includeInternals
	 * @param onlyAvailableInMenu
	 * @param level
	 */
	private void getGroupsTreeForSelect(Map&lt;Integer, List&lt;GroupDetails&gt;&gt; childsTable, int parent, List&lt;LabelValueDetails&gt; list, boolean includeInternals, boolean onlyAvailableInMenu, int level)
	{
<span class="nc" id="L794">		List&lt;GroupDetails&gt; childs = childsTable.get(parent);</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">		if (childs == null) return;</span>

<span class="nc" id="L797">		GroupDetails system = null;</span>

<span class="nc" id="L799">		StringBuilder spacer = new StringBuilder();</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">		for (int i=0; i&lt;level; i++)</span>
		{
<span class="nc" id="L802">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L803">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L804">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L805">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
<span class="nc" id="L806">			spacer.append(Constants.NON_BREAKING_SPACE);</span>
		}

<span class="nc bnc" id="L809" title="All 2 branches missed.">		for (GroupDetails group : childs)</span>
		{
<span class="nc bnc" id="L811" title="All 4 branches missed.">			if (includeInternals == false &amp;&amp; group.isInternal()) continue;</span>
<span class="nc bnc" id="L812" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_HIDDEN) continue;</span>

<span class="nc bnc" id="L814" title="All 4 branches missed.">			if (&quot;cloud&quot;.equals(Constants.getInstallName()) &amp;&amp; &quot;System&quot;.equals(group.getGroupName()))</span>
			{
				//system grupu presunieme uplne na koniec
<span class="nc" id="L817">				system = group;</span>
<span class="nc" id="L818">				continue;</span>
			}

<span class="nc" id="L821">			list.add(new LabelValueDetails(spacer.toString()+group.getGroupName(), String.valueOf(group.getGroupId())));</span>

<span class="nc bnc" id="L823" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; group.getMenuType()==GroupDetails.MENU_TYPE_NOSUB) continue;</span>

			//recursive call
<span class="nc" id="L826">			getGroupsTreeForSelect(childsTable, group.getGroupId(), list, includeInternals, onlyAvailableInMenu, level+1);</span>
<span class="nc" id="L827">		}</span>

<span class="nc bnc" id="L829" title="All 2 branches missed.">		if (system != null)</span>
		{
<span class="nc" id="L831">			list.add(new LabelValueDetails(spacer.toString()+system.getGroupName(), String.valueOf(system.getGroupId())));</span>
<span class="nc bnc" id="L832" title="All 4 branches missed.">			if (onlyAvailableInMenu &amp;&amp; system.getMenuType()==GroupDetails.MENU_TYPE_NOSUB)</span>
			{
				//continue;
			}
			else
			{
				//recursive call
<span class="nc" id="L839">				getGroupsTreeForSelect(childsTable, system.getGroupId(), list, includeInternals, onlyAvailableInMenu, level+1);</span>
			}
		}
<span class="nc" id="L842">	}</span>

	/**
	 *  najde GroupDetails pre zadane groupId
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          Description of the Return Value
	 */
	public GroupDetails findGroup(int groupId)
	{
<span class="fc" id="L852">		return getGroup(groupId);</span>
	}

	public static GroupDetails findGroup(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="nc bnc" id="L857" title="All 2 branches missed.">		for (GroupDetails group : allGroups)</span>
		{
<span class="nc bnc" id="L859" title="All 2 branches missed.">			if (group.getGroupId() == groupId)</span>
			{
<span class="nc" id="L861">				return (group);</span>
			}
<span class="nc" id="L863">		}</span>
<span class="nc" id="L864">		return (null);</span>
	}

	/**
	 * Ulozenie adresara do databazy
	 * @param group
	 * @return
	 */
	public boolean save(GroupDetails group)
	{
<span class="fc" id="L874">		return setGroup(group);</span>
	}

	/**
	 * Ulozenie adresara do databazy
	 * @param group
	 * @return
	 */
	public boolean setGroup(GroupDetails group)
	{
<span class="fc" id="L884">		return setGroup(group, true);</span>
	}

	/**
	 * Ulozenie adresara, ak je nastavene doNotPublishEvents na true nie su vyvolane udalosti
	 * @param group
	 * @param publishEvents - ak je true, su vyvolane udalosti (false potrebne ak napr. reagujeme na udalost a potrebujeme znova upravit adresar a nechceme aby doslo k zacykleniu)
	 * @return
	 */
	public boolean setGroup(GroupDetails group, boolean publishEvents)
	{
<span class="fc bfc" id="L895" title="All 2 branches covered.">		if (publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(group, WebjetEventType.ON_START)).publishEvent();</span>

<span class="pc bpc" id="L897" title="5 of 6 branches missed.">		if (InitServlet.isTypeCloud() &amp;&amp; group.getGroupId()&gt;0 &amp;&amp; Tools.isNotEmpty(group.getDomainName()))</span>
		{
			//kontrola prav
<span class="nc" id="L900">			GroupDetails oldGroup = getGroup(group.getGroupId());</span>
<span class="nc bnc" id="L901" title="All 4 branches missed.">			if (oldGroup == null || oldGroup.getDomainName().equals(CloudToolsForCore.getDomainName())==false)</span>
			{
<span class="nc" id="L903">				return false;</span>
			}
		}

<span class="fc" id="L907">		java.sql.Connection db_conn = null;</span>
<span class="fc" id="L908">		java.sql.PreparedStatement ps = null;</span>
<span class="fc" id="L909">		ResultSet rs = null;</span>
		try
		{
<span class="fc" id="L912">			GroupDetails newGroup = (GroupDetails)group.clone();	//Hlasilo CloneNotSupportedException</span>

<span class="pc bpc" id="L914" title="1 of 2 branches missed.">			if (InitServlet.isTypeCloud())</span>
			{
<span class="nc bnc" id="L916" title="All 2 branches missed.">				if (Tools.isEmpty(newGroup.getDomainName()))</span>
				{
<span class="nc" id="L918">					newGroup.setDomainName(CloudToolsForCore.getDomainName());</span>
				}

<span class="nc bnc" id="L921" title="All 2 branches missed.">				if (newGroup.getParentGroupId()&lt;1)</span>
				{
<span class="nc" id="L923">					int domainId = CloudToolsForCore.getDomainId();</span>
					//test &gt; 1 musi byt kvoli moznosti zalozit root group pre domenu (ak este neexistuje vrati sa 1)
<span class="nc bnc" id="L925" title="All 4 branches missed.">					if (domainId &gt; 1 &amp;&amp; domainId != newGroup.getGroupId()) newGroup.setParentGroupId(domainId);</span>
<span class="nc" id="L926">				}</span>
				else
				{
<span class="nc" id="L929">					GroupDetails parentGroup = getGroup(newGroup.getParentGroupId());</span>
<span class="nc bnc" id="L930" title="All 4 branches missed.">					if (parentGroup == null || parentGroup.getDomainName().equals(newGroup.getDomainName())==false)</span>
					{
<span class="nc" id="L932">						newGroup.setDomainName(CloudToolsForCore.getDomainName());</span>
<span class="nc" id="L933">						newGroup.setParentGroupId(CloudToolsForCore.getDomainId());</span>
					}
				}
			}

			//nahradim vyskyty &quot;/&quot; a &quot;\&quot; za &quot;-&quot;
<span class="fc" id="L939">			newGroup.setGroupName(Tools.replace(Tools.replace(newGroup.getGroupName(), &quot;\\&quot;, &quot;-&quot;), &quot;/&quot;, &quot;&amp;#47;&quot;));</span>
<span class="fc" id="L940">			newGroup.setNavbar(Tools.replace(Tools.replace(newGroup.getNavbarName(), &quot;\\&quot;, &quot;-&quot;), &quot;/&quot;, &quot;&amp;#47;&quot;));</span>

			//premenovanie nazvu hlavnej stranky Grupy, podla nazvu Grupy
<span class="pc bpc" id="L943" title="1 of 4 branches missed.">			if(Constants.getBoolean(&quot;syncGroupAndWebpageTitle&quot;) &amp;&amp; newGroup.getDefaultDocId() &gt; 0)</span>
<span class="fc" id="L944">				changeDocTitle(newGroup);</span>

<span class="fc" id="L946">			Logger.println(this,&quot;GroupsDB.setGroup: &quot; + newGroup.getGroupName());</span>

<span class="fc" id="L948">			String[] additionalFields = DataAccessHelper.getGroupFields();</span>
<span class="fc" id="L949">			StringBuilder addFieldsInsert = new StringBuilder();</span>
<span class="fc" id="L950">			StringBuilder addFieldsInsertParams = new StringBuilder();</span>
<span class="fc" id="L951">			StringBuilder addFieldsUpdate = new StringBuilder();</span>
<span class="pc bpc" id="L952" title="2 of 4 branches missed.">			if (additionalFields != null &amp;&amp; additionalFields.length&gt;0) {</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">				for (String field : additionalFields) {</span>
<span class="fc" id="L954">					addFieldsInsert.append(&quot;, &quot;).append(field);</span>
<span class="fc" id="L955">					addFieldsInsertParams.append(&quot;, ?&quot;);</span>
<span class="fc" id="L956">					addFieldsUpdate.append(&quot;, &quot;).append(field).append(&quot;=?&quot;);</span>
				}
			}

<span class="fc" id="L960">			String sql = &quot;INSERT INTO groups (group_name, internal, parent_group_id, navbar, default_doc_id, temp_id, sort_priority, password_protected, menu_type, url_dir_name, html_head, logon_page_doc_id, domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d, logged_menu_type, link_group_id, lng, hidden_in_admin, force_group_template&quot;+addFieldsInsert.toString()+&quot;) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?&quot;+addFieldsInsertParams.toString()+&quot;)&quot;;</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">			if (newGroup.getGroupId()&gt;0)</span>
			{
<span class="fc" id="L963">				sql = &quot;UPDATE groups SET group_name=?, internal=?, parent_group_id=?, navbar=?, default_doc_id=?, temp_id=?, sort_priority=?, password_protected=?, menu_type=?, url_dir_name=?, sync_status=1, html_head=?, logon_page_doc_id=?, domain_name=?, new_page_docid_template=?, install_name=?, field_a=?, field_b=?, field_c=?, field_d=?, logged_menu_type=?, link_group_id=?, lng=?, hidden_in_admin=?, force_group_template=?&quot;+addFieldsUpdate.toString()+&quot; WHERE group_id=?&quot;;</span>
			}

<span class="fc" id="L966">			db_conn = DBPool.getConnection();</span>

<span class="fc" id="L968">			ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L969">			ps.setString(1, newGroup.getGroupName());</span>
<span class="fc" id="L970">			ps.setBoolean(2, newGroup.isInternal());</span>
<span class="fc" id="L971">			ps.setInt(3, newGroup.getParentGroupId());</span>
<span class="fc" id="L972">			ps.setString(4, newGroup.getNavbarName());</span>
<span class="fc" id="L973">			ps.setInt(5, newGroup.getDefaultDocId());</span>
<span class="fc" id="L974">			ps.setInt(6, newGroup.getTempId());</span>
<span class="fc" id="L975">			ps.setInt(7, newGroup.getSortPriority());</span>
<span class="fc" id="L976">			ps.setString(8, newGroup.getPasswordProtected());</span>
			//#20018, #15784 - pre Plusku ak je nazov noveho adresara cislo, tak daj Nezobrazovat a URL nazov adresara na pomlcku
<span class="pc bpc" id="L978" title="3 of 4 branches missed.">			if(Tools.getIntValue(newGroup.getGroupName(),0) &gt; 0 &amp;&amp; Constants.getBoolean(&quot;editorGroupReplaceNumberWithDashInUrl&quot;))</span>
			{
<span class="nc" id="L980">				newGroup.setMenuType(0);</span>
<span class="nc" id="L981">				newGroup.setUrlDirName(&quot;-&quot;);</span>
<span class="nc" id="L982">				Logger.println(GroupsDB.class, &quot;nazov adresara &quot;+newGroup.getGroupName()+&quot; {id:&quot;+newGroup.getGroupId()+&quot;} je cislo, nastavujem urlDirName na pomlcku a menuType=0&quot;);</span>
			}

<span class="fc" id="L985">			ps.setInt(9, newGroup.getMenuType());</span>
<span class="fc" id="L986">			ps.setString(10, newGroup.getUrlDirName());</span>
<span class="fc" id="L987">			DB.setClob(ps, 11, newGroup.getHtmlHead());</span>
<span class="fc" id="L988">			ps.setInt(12, newGroup.getLogonPageDocId());</span>

			//domain_name, new_page_docid_template, install_name, field_a, field_b, field_c, field_d
<span class="pc bpc" id="L991" title="1 of 4 branches missed.">			if (Constants.getBoolean(&quot;multiDomainEnabled&quot;) &amp;&amp; newGroup.getParentGroupId()&gt;0)</span>
			{
<span class="pc bpc" id="L993" title="1 of 4 branches missed.">				if (Tools.isEmpty(newGroup.getDomainName()) || Constants.getBoolean(&quot;multiDomainEnableNested&quot;)==false) {</span>
					//ak sa niekde zabudla nastavit domena / alebo nie je zapnute nested, pouzijem parent
<span class="fc" id="L995">					GroupDetails parentGroup = getGroup(newGroup.getParentGroupId());</span>
<span class="pc bpc" id="L996" title="2 of 4 branches missed.">					if (parentGroup != null &amp;&amp; Tools.isNotEmpty(parentGroup.getDomainName()))</span>
					{
<span class="fc" id="L998">						newGroup.setDomainName(parentGroup.getDomainName());</span>
					}
				}
			}
<span class="fc" id="L1002">			ps.setString(13, newGroup.getDomainName());</span>
<span class="fc" id="L1003">			ps.setInt(14, newGroup.getNewPageDocIdTemplate());</span>
<span class="fc" id="L1004">			ps.setString(15, newGroup.getInstallName());</span>
<span class="fc" id="L1005">			ps.setString(16, newGroup.getFieldA());</span>
<span class="fc" id="L1006">			ps.setString(17, newGroup.getFieldB());</span>
<span class="fc" id="L1007">			ps.setString(18, newGroup.getFieldC());</span>
<span class="fc" id="L1008">			ps.setString(19, newGroup.getFieldD());</span>

<span class="fc" id="L1010">			ps.setInt(20, newGroup.getLoggedMenuType());</span>
<span class="fc" id="L1011">			ps.setInt(21, newGroup.getLinkGroupId());</span>

<span class="fc" id="L1013">			ps.setString(22, newGroup.getLng());</span>
<span class="fc" id="L1014">			ps.setBoolean(23, newGroup.isHiddenInAdmin());</span>

<span class="fc" id="L1016">			ps.setBoolean(24, newGroup.isForceTheUseOfGroupTemplate());</span>

<span class="fc" id="L1018">			int psCounter = DataAccessHelper.setGroupPreparedStatement(ps, newGroup, 25);</span>

<span class="fc bfc" id="L1020" title="All 2 branches covered.">			if (newGroup.getGroupId()&gt;0)</span>
			{
<span class="fc" id="L1022">				ps.setInt(psCounter++, newGroup.getGroupId());</span>
			}

<span class="fc" id="L1025">			ps.execute();</span>
<span class="fc" id="L1026">			ps.close();</span>
<span class="fc" id="L1027">			ps = null;</span>

<span class="fc bfc" id="L1029" title="All 2 branches covered.">			boolean isNew = newGroup.getGroupId()&lt;1;</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">			if (isNew)</span>
			{
				//ziskaj group ID
<span class="fc" id="L1033">				sql = &quot;SELECT max(group_id) AS group_id FROM groups WHERE group_name=? AND parent_group_id=?&quot;;</span>
<span class="fc" id="L1034">				ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L1035">				ps.setString(1, newGroup.getGroupName());</span>
<span class="fc" id="L1036">				ps.setInt(2, newGroup.getParentGroupId());</span>
<span class="fc" id="L1037">				rs = ps.executeQuery();</span>
<span class="pc bpc" id="L1038" title="1 of 2 branches missed.">				if (rs.next())</span>
				{
<span class="fc" id="L1040">					newGroup.setGroupId(rs.getInt(&quot;group_id&quot;));</span>
<span class="fc" id="L1041">					group.setGroupId(newGroup.getGroupId());</span>
				}
<span class="fc" id="L1043">				rs.close();</span>
<span class="fc" id="L1044">				ps.close();</span>
<span class="fc" id="L1045">				rs = null;</span>
<span class="fc" id="L1046">				ps = null;</span>
			}

<span class="fc" id="L1049">			db_conn.close();</span>
<span class="fc" id="L1050">			db_conn = null;</span>

			//ak su nastavene syncId tak zapis aj to, potrebne pre synchronizaciu struktury
<span class="fc bfc" id="L1053" title="All 2 branches covered.">			if (newGroup.getSyncId()&gt;0) {</span>
<span class="fc" id="L1054">				new SimpleQuery().execute(&quot;UPDATE groups SET sync_id=? WHERE group_id=?&quot;, newGroup.getSyncId(), newGroup.getGroupId());</span>
			}

			//groups_scheduler(history)
<span class="fc" id="L1058">			int userId = -1;</span>
<span class="fc" id="L1059">			RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">			if(rb != null)</span>
<span class="fc" id="L1061">				userId = rb.getUserId();</span>

<span class="fc" id="L1063">			GroupPublisher.addRecord(newGroup, null, userId);</span>
			//GroupPublisher.addRecord(newGroup, null);

<span class="fc" id="L1066">			StringBuilder logMessage = new StringBuilder();</span>
			//refresh data
<span class="fc bfc" id="L1068" title="All 2 branches covered.">			if (isNew)</span>
			{
<span class="fc" id="L1070">				insertGroupInCache(newGroup);</span>
				//nastavovanie full pathu musi byt aj v if aj v else kvoli logovaniu...
<span class="fc" id="L1072">				newGroup.setFullPath(getPath(newGroup.getGroupId()));</span>
<span class="fc" id="L1073">				group.setFullPath(newGroup.getFullPath());</span>
<span class="fc" id="L1074">				logMessage.append(&quot;Vytvoreny adresar &quot;).append(newGroup.getFullPath());</span>
			}
			else
			{
				//vymaz staru a vloz novu - mozu ist na ine miesto v zozname
<span class="fc" id="L1079">				GroupDetails oldGroup = getGroup(newGroup.getGroupId());</span>
<span class="fc" id="L1080">				replaceGroupInCache(oldGroup, newGroup);</span>
<span class="fc" id="L1081">				newGroup.setFullPath(getPath(newGroup.getGroupId()));</span>
<span class="fc" id="L1082">				group.setFullPath(newGroup.getFullPath());</span>

<span class="fc" id="L1084">				BeanDiff diff = new BeanDiff().setNew(newGroup).setOriginal(oldGroup).blacklist(&quot;syncStatus&quot;, &quot;groupIdName&quot;, &quot;fullPath&quot;);</span>
<span class="fc" id="L1085">				logMessage.append(&quot;Zmeneny adresar: &quot;).append(newGroup.getFullPath());</span>
<span class="fc" id="L1086">				logMessage.append('\n').append(new BeanDiffPrinter(diff).toString());</span>
			}
			//zresetuj all tree cache
<span class="fc" id="L1089">			groupsTreeAllCache = null;</span>

<span class="fc" id="L1091">			Adminlog.add(Adminlog.TYPE_GROUP, logMessage.toString(), newGroup.getGroupId(), newGroup.getParentGroupId());</span>
			//oznam ostatnym, ze nastala zmena
<span class="fc" id="L1093">			ClusterDB.addRefresh(GroupsDB.class);</span>

			//aktualizuj FT fieldy
<span class="fc" id="L1096">			DocDB.updateFileNameField(newGroup.getGroupId());</span>

			//ak sa jedna o system adresar, refreshnem zoznam tychto stranok
<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">			if(&quot;System&quot;.equalsIgnoreCase(newGroup.getGroupName())) getAllSystemFolders(true);</span>

<span class="fc bfc" id="L1101" title="All 2 branches covered.">			if (publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(newGroup, WebjetEventType.AFTER_SAVE)).publishEvent();</span>

<span class="fc" id="L1103">			return(true);</span>
		}
<span class="nc" id="L1105">		catch (Exception ex){sk.iway.iwcm.Logger.error(ex);}</span>
		finally{
			try{
<span class="pc bpc" id="L1108" title="1 of 2 branches missed.">				if (rs != null) rs.close();</span>
<span class="pc bpc" id="L1109" title="1 of 2 branches missed.">				if (ps != null) ps.close();</span>
<span class="pc bpc" id="L1110" title="1 of 2 branches missed.">				if (db_conn != null) db_conn.close();</span>
<span class="pc" id="L1111">			}catch (Exception e) {sk.iway.iwcm.Logger.error(e);}</span>
		}
<span class="nc" id="L1113">		return(false);</span>
	}

	/**
	 *  Vrati meno grupy pre zadane group_id
	 *
	 *@param  groupId  id grupy
	 *@return          nazov grupy
	 */
	public String getGroupName(int groupId)
	{
<span class="nc" id="L1124">		GroupDetails group = findGroup(groupId);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">		if (group == null)</span>
<span class="nc" id="L1126">			return (&quot;&quot;);</span>
<span class="nc" id="L1127">		return group.getGroupName();</span>
	}

	/**
	 *  vrati zoznam potomkov
	 *
	 *@param  groupId     Description of the Parameter
	 *@param  noInternal  Description of the Parameter
	 *@return             Description of the Return Value
	 */
	public List&lt;GroupDetails&gt; findChilds(int groupId, boolean noInternal)
	{
<span class="nc" id="L1139">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">		for (GroupDetails group : groups)</span>
		{
<span class="nc bnc" id="L1142" title="All 2 branches missed.">			if (group.getParentGroupId() == groupId)</span>
			{
<span class="nc bnc" id="L1144" title="All 2 branches missed.">				if (noInternal == true)</span>
				{
<span class="nc bnc" id="L1146" title="All 2 branches missed.">					if (!group.isInternal())</span>
					{
<span class="nc" id="L1148">						ret.add(group);</span>
					}
				}
				else
				{
<span class="nc" id="L1153">					ret.add(group);</span>
				}

			}
<span class="nc" id="L1157">		}</span>
<span class="nc" id="L1158">		return (ret);</span>
	}

	/**
	 *  vrati cestu k zadanej skupine napr.: /iwcm/Produkty
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The path value
	 */
	public String getPath(int groupId)
	{
<span class="fc bfc" id="L1169" title="All 2 branches covered.">		if (groupId &lt; 1) return(&quot;/&quot;);</span>
<span class="fc" id="L1170">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1171">		boolean finished = false;</span>
<span class="fc" id="L1172">		int currentGroupId = groupId;</span>
<span class="fc" id="L1173">		int depth = 0;</span>
<span class="fc" id="L1174">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L1176" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1178">			group = findGroup(currentGroupId);</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">			if (group != null)</span>
			{
<span class="fc" id="L1181">				path.insert(0, &quot;/&quot; + group.getGroupName());</span>
<span class="fc" id="L1182">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L1187">				finished = true;</span>
			}
<span class="fc" id="L1189">			depth++;</span>
<span class="fc bfc" id="L1190" title="All 2 branches covered.">			if (depth &gt; max_depth)</span>
			{
<span class="fc" id="L1192">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1195" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1197">				finished = true;</span>
			}
		}
<span class="fc" id="L1200">		return (path.toString());</span>
	}

	/**
	 * Vrati zoznam GroupDetails ako cestu k zadanemu groupId
	 * @param groupId
	 * @return
	 */
	public List&lt;GroupDetails&gt; getPathList(int groupId)
	{
<span class="fc" id="L1210">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">		if (groupId &lt; 1) return(ret);</span>

<span class="fc" id="L1213">		boolean finished = false;</span>
<span class="fc" id="L1214">		int currentGroupId = groupId;</span>
<span class="fc" id="L1215">		int depth = 0;</span>
<span class="fc" id="L1216">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L1218" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1220">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">			if (group != null)</span>
			{
				//pridavame na zaciatok
<span class="fc" id="L1224">				ret.add(0, group);</span>
<span class="fc" id="L1225">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1230">				finished = true;</span>
			}
<span class="fc" id="L1232">			depth++;</span>
<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1235">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1238" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1240">				finished = true;</span>
			}
		}
<span class="fc" id="L1243">		return (ret);</span>
	}

	public String getPathLinkForward(int groupId, String forward)
	{
<span class="fc" id="L1248">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1249">		boolean finished = false;</span>
<span class="fc" id="L1250">		int currentGroupId = groupId;</span>
<span class="fc" id="L1251">		int depth = 0;</span>
<span class="fc" id="L1252">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc" id="L1254">		String forwardLink = &quot;&quot;;</span>
<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">		if (forward!=null)</span>
		{
<span class="nc" id="L1257">			forwardLink = &quot;&amp;forward=&quot;+forward;</span>
		}
<span class="fc bfc" id="L1259" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1261">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="fc" id="L1264">				path.insert(0, &quot;/&lt;a class='groups' href='/admin/v9/webpages/web-pages-list/?groupid=&quot;+group.getGroupId()+forwardLink+&quot;'&gt;&quot; + ResponseUtils.filter(group.getGroupName()) + &quot;&lt;/a&gt;&quot;);</span>
<span class="fc" id="L1265">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1270">				finished = true;</span>
			}
<span class="fc" id="L1272">			depth++;</span>
<span class="pc bpc" id="L1273" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1275">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1278" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1280">				finished = true;</span>
			}
		}
<span class="fc" id="L1283">		return (path.toString());</span>
	}

	/**
	 * Vrati cestu k suboru ak je v subor v ListGroup inak vrati cestu s groupid = 0 (root)
	 * @param groupId
	 * @param forward
	 * @param listGroup
	 * @return
	 */
	public String getPathLinkForwardExceptNotAllow(int groupId, String forward, List&lt;GroupDetails&gt; listGroup)
	{
<span class="nc" id="L1295">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1296">		boolean finished = false;</span>
<span class="nc" id="L1297">		int currentGroupId = groupId;</span>
<span class="nc" id="L1298">		int depth = 0;</span>
<span class="nc" id="L1299">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc" id="L1301">		String forwardLink = &quot;&quot;;</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">		if (forward!=null)</span>
		{
<span class="nc" id="L1304">			forwardLink = &quot;&amp;forward=&quot;+forward;</span>
		}
<span class="nc bnc" id="L1306" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1308">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">			if (group != null)</span>
			{
				//is_allow
				String replaceID;
<span class="nc bnc" id="L1313" title="All 2 branches missed.">				if(  isAllow(listGroup, group.getGroupId())  )</span>
<span class="nc" id="L1314">					replaceID = group.getGroupId()+&quot;&quot;;</span>
				else
<span class="nc" id="L1316">					replaceID = &quot;0&quot; ;</span>
<span class="nc" id="L1317">				path.insert(0, &quot;/&lt;a class='groups' href='/admin/v9/webpages/web-pages-list/?groupid=&quot;+replaceID+forwardLink+&quot;'&gt;&quot; + group.getGroupName() + &quot;&lt;/a&gt;&quot;);</span>
<span class="nc" id="L1318">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1319">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1323">				finished = true;</span>
			}
<span class="nc" id="L1325">			depth++;</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1328">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1331" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1333">				finished = true;</span>
			}
		}
<span class="nc" id="L1336">		return (path.toString());</span>
	}

	/**
	 * Vrati true ak v danom ListGroup je adresar s ID =  groupId
	 * @param ListGroup - zoznam vsetkych suborov
	 * @param groupId - id aktualneho adresara
	 */
	private static boolean isAllow(List&lt;GroupDetails&gt; listGroup,int groupId)
	{
<span class="nc bnc" id="L1346" title="All 2 branches missed.">		if(groupId == 0)</span>
<span class="nc" id="L1347">			return true;</span>

<span class="nc" id="L1349">		boolean finded = false;</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">		for(int i = 0; i &lt; listGroup.size() ; i++)</span>
		{
<span class="nc bnc" id="L1352" title="All 2 branches missed.">			if( (listGroup.get(i).getGroupId()+&quot;&quot;).equals(groupId+&quot;&quot;) )</span>
<span class="nc" id="L1353">				return true;</span>
		}
<span class="nc" id="L1355">		return finded;</span>
	}
	/**
	 * Vrati naformatovanu cestu priorit k danemu adresaru (napr. 1.20.14)
	 * @param groupId
	 * @return
	 */
	public String getPathPriorityNumbers(int groupId)
	{
<span class="nc" id="L1364">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1365">		boolean finished = false;</span>
<span class="nc" id="L1366">		int currentGroupId = groupId;</span>
<span class="nc" id="L1367">		int depth = 0;</span>
<span class="nc" id="L1368">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc bnc" id="L1370" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1372">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">			if (group != null)</span>
			{
<span class="nc" id="L1375">				path.insert(0, group.getSortPriority() + &quot;.&quot;);</span>
<span class="nc" id="L1376">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1381">				finished = true;</span>
			}
<span class="nc" id="L1383">			depth++;</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1386">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1389" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1391">				finished = true;</span>
			}
		}
<span class="nc" id="L1394">		return (path.toString());</span>
	}

	/**
	 * Vrati retazec s cestou k adresaru (napr. /sk/nieco/podnieco).
	 * Pouziva UrlDirName groupDetails
	 * @param groupId
	 * @return
	 */
	public String getURLPath(int groupId)
	{
<span class="fc" id="L1405">		return(getURLPathGroup(groups, groupId));</span>
	}

	/**
	 * Vrati retazec s cestou k adresaru (napr. /sk/nieco/podnieco).
	 * @param allGroups
	 * @param groupId
	 * @return
	 */
	public static String getURLPathGroup(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1416">		String[] retData = getURLPathDomainGroup(allGroups, groupId);</span>
<span class="fc" id="L1417">		return retData[0];</span>
	}

	/**
	 * Vrati domenu pre zadane groupId
	 * @param groupId
	 * @return
	 */
	public String getDomain(int groupId)
	{
<span class="pc bpc" id="L1427" title="1 of 2 branches missed.">		if (InitServlet.isTypeCloud())</span>
		{
<span class="nc" id="L1429">			GroupDetails group = getGroup(groupId);</span>
<span class="nc bnc" id="L1430" title="All 4 branches missed.">			if (group != null &amp;&amp; Tools.isNotEmpty(group.getDomainName())) return group.getDomainName();</span>
		}

<span class="fc" id="L1433">		return(getDomain(groups, groupId));</span>
	}

	/**
	 * Vrati domenu pre zadane groupId a zadany list
	 * @param allGroups
	 * @param groupId
	 * @return
	 */
	public static String getDomain(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1444">		String[] retData = getURLPathDomainGroup(allGroups, groupId);</span>
<span class="fc" id="L1445">		return retData[1];</span>
	}

	public static String[] getURLPathDomainGroup(List&lt;GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1450">		Map&lt;Integer, GroupDetails&gt; table = new Hashtable&lt;&gt;();</span>
<span class="fc bfc" id="L1451" title="All 2 branches covered.">		for (GroupDetails group : allGroups)</span>
		{
<span class="fc" id="L1453">			table.put(group.getGroupId(), group);</span>
<span class="fc" id="L1454">		}</span>

<span class="fc" id="L1456">		return getURLPathDomainGroup(table, groupId);</span>
	}

	/**
	 * Vrati pole stringov, kde ret[0]=URL cesta k adresaru a ret[1]=nazov domeny root adresara
	 * @param allGroups
	 * @param groupId
	 * @return
	 */
	public static String[] getURLPathDomainGroup(Map&lt;Integer, GroupDetails&gt; allGroups, int groupId)
	{
<span class="fc" id="L1467">		String[] retData = new String[2];</span>

<span class="fc" id="L1469">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1470">		boolean finished = false;</span>
<span class="fc" id="L1471">		int currentGroupId = groupId;</span>
<span class="fc" id="L1472">		int depth = 0;</span>
<span class="fc" id="L1473">		int max_depth = 30;</span>
		GroupDetails group;

<span class="fc" id="L1476">		String domain = null;</span>
		//pouzije sa ak je nastavene multiDomainEnableNested
<span class="fc" id="L1478">		String domainOnFirstGroup = null;</span>

<span class="fc bfc" id="L1480" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1482">			group = allGroups.get(Integer.valueOf(currentGroupId));</span>

<span class="fc bfc" id="L1484" title="All 2 branches covered.">			if (group==null)</span>
			{
<span class="fc" id="L1486">				retData[0] = &quot;--------------------------&quot;;</span>
<span class="fc" id="L1487">				retData[1] = &quot;&quot;;</span>
<span class="fc" id="L1488">				return(retData);</span>
			}
			else
			{
<span class="fc bfc" id="L1492" title="All 4 branches covered.">				if (domainOnFirstGroup == null &amp;&amp; Tools.isNotEmpty(group.getDomainName()))</span>
				{
<span class="fc" id="L1494">					domainOnFirstGroup = group.getDomainName();</span>
<span class="fc" id="L1495">					domain = domainOnFirstGroup;</span>
				}

				//Logger.println(this,&quot;group=&quot;+group.getGroupId()+&quot; p=&quot;+group.getParentGroupId()+&quot; n=&quot;+group.getNavbarName());

<span class="fc bfc" id="L1500" title="All 2 branches covered.">				if (group.getUrlDirName().startsWith(&quot;/&quot;))</span>
				{
					//ak sa adresaru nastavi cesta zacinajuca / tak sa zrusi predchadzajuca URL cesta
<span class="fc" id="L1503">					path.insert(0, group.getUrlDirName());</span>
<span class="fc" id="L1504">					finished = true;</span>
				}
<span class="fc bfc" id="L1506" title="All 2 branches covered.">				else if(&quot;-&quot;.equals(group.getUrlDirName())==false)</span>
				{
<span class="fc" id="L1508">					path.insert(0, &quot;/&quot; + group.getUrlDirName());</span>
				}
<span class="fc" id="L1510">				currentGroupId = group.getParentGroupId();</span>
			}


			//Logger.println(this,&quot;path=&quot;+path);

<span class="fc" id="L1516">			depth++;</span>
<span class="fc bfc" id="L1517" title="All 2 branches covered.">			if (depth &gt; max_depth)</span>
			{
<span class="fc" id="L1519">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1522" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1524">				finished = true;</span>
<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">				if (group != null) domain = group.getDomainName();</span>
			}
		}

		//ak sme skoncili iteraciu predcasne
<span class="pc bpc" id="L1530" title="3 of 4 branches missed.">		while (domain == null &amp;&amp; depth++ &lt; max_depth)</span>
		{
<span class="nc" id="L1532">			group = allGroups.get(Integer.valueOf(currentGroupId));</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">			if (group == null)</span>
			{
<span class="nc" id="L1535">				domain = &quot;&quot;;</span>
<span class="nc" id="L1536">				break;</span>
			}
			else
			{
<span class="nc" id="L1540">				currentGroupId = group.getParentGroupId();</span>

<span class="nc bnc" id="L1542" title="All 2 branches missed.">				if (currentGroupId == 0)</span>
				{
<span class="nc" id="L1544">					domain = group.getDomainName();</span>
				}
			}
		}

<span class="pc bpc" id="L1549" title="1 of 2 branches missed.">		if (domain == null) domain=&quot;&quot;;</span>

<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;multiDomainEnableNested&quot;)) domain = domainOnFirstGroup;</span>

<span class="fc" id="L1553">		retData[0] = Tools.replace(path.toString(), &quot;//&quot;, &quot;/&quot;);</span>
<span class="fc" id="L1554">		retData[1] = domain;</span>
<span class="fc" id="L1555">		return(retData);</span>
	}

	/**
	 * Vrati cestu k adresaru s pouzitim NavbarName (napr. /Slovensky/O Nás/Kontakt)
	 * @param groupId
	 * @return
	 */
	public String getNavbarPath(int groupId)
	{
<span class="nc" id="L1565">		StringBuilder path = new StringBuilder();</span>
<span class="nc" id="L1566">		boolean finished = false;</span>
<span class="nc" id="L1567">		int currentGroupId = groupId;</span>
<span class="nc" id="L1568">		int depth = 0;</span>
<span class="nc" id="L1569">		int max_depth = 30;</span>
		GroupDetails group;

<span class="nc bnc" id="L1572" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L1574">			group = findGroup(currentGroupId);</span>


<span class="nc bnc" id="L1577" title="All 2 branches missed.">			if (group==null)</span>
			{
<span class="nc" id="L1579">				return(&quot;--------------------------&quot;);</span>
			}
			else
			{
<span class="nc bnc" id="L1583" title="All 2 branches missed.">				if (&quot;-&quot;.equals(group.getUrlDirName())==false)</span>
				{
<span class="nc" id="L1585">					path.insert(0, &quot;/&quot; + group.getNavbarName());</span>
				}
<span class="nc" id="L1587">				currentGroupId = group.getParentGroupId();</span>
			}


			//Logger.println(this,&quot;path=&quot;+path);

<span class="nc" id="L1593">			depth++;</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1596">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1599" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1601">				finished = true;</span>
			}
		}

<span class="nc" id="L1605">		return (path.toString());</span>
	}

	/**
	 * Vrati cestu k adresaru s pouzitim Title (napr. /Slovensky/O Nás/Kontakt)
	 * @param groupId
	 * @return
	 */
	public String getGroupNamePath(int groupId)
	{
<span class="fc" id="L1615">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1616">		boolean finished = false;</span>
<span class="fc" id="L1617">		int currentGroupId = groupId;</span>
<span class="fc" id="L1618">		int depth = 0;</span>
<span class="fc" id="L1619">		int max_depth = 30;</span>
		GroupDetails group;

<span class="fc bfc" id="L1622" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1624">			group = findGroup(currentGroupId);</span>

<span class="fc bfc" id="L1626" title="All 2 branches covered.">			if (group==null)</span>
			{
<span class="fc" id="L1628">				return(&quot;--------------------------&quot;);</span>
			}
			else
			{
<span class="fc" id="L1632">				path.insert(0, &quot;/&quot; + group.getGroupName());</span>
<span class="fc" id="L1633">				currentGroupId = group.getParentGroupId();</span>
			}

			//Logger.println(this,&quot;path=&quot;+path);

<span class="fc" id="L1638">			depth++;</span>
<span class="pc bpc" id="L1639" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L1641">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1644" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1646">				finished = true;</span>
			}
		}

<span class="fc" id="L1650">		return (path.toString());</span>
	}

	/**
	 *  vrati navigacnu listu (podobne ako cestu) len je to iwcm &gt; Produkty
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The navbar value
	 */
	public String getNavbar(int groupId)
	{
<span class="fc" id="L1661">		return(getNavbar(groupId, -99, null));</span>
	}

	/**
	 * Vrati navigacnu listup, pre zadane docId (aktualne) nezrenderuje odkaz
	 * @param groupId
	 * @param docId
	 * @param session
	 * @return
	 */
	public String getNavbar(int groupId, int docId, HttpSession session)
	{
<span class="fc" id="L1673">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1674">		boolean finished = false;</span>
<span class="fc" id="L1675">		int currentGroupId = groupId;</span>
<span class="fc" id="L1676">		int depth = 0;</span>
<span class="fc" id="L1677">		int max_depth = 30;</span>
		GroupDetails group;
<span class="pc bpc" id="L1679" title="1 of 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="fc" id="L1681">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L1682" title="2 of 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="pc bpc" id="L1684" title="2 of 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1686">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1687">					continue;</span>
				}

<span class="pc bpc" id="L1690" title="2 of 4 branches missed.">				if (group.getNavbar().length() &gt; 1 &amp;&amp; &quot;&amp;nbsp;&quot;.equals(group.getNavbarName())==false)</span>
				{
<span class="pc bpc" id="L1692" title="3 of 4 branches missed.">					if (Constants.getBoolean(&quot;navbarRenderAllLinks&quot;)==false &amp;&amp; group.getDefaultDocId()==docId)</span>
					{
<span class="nc" id="L1694">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + group.getNavbarName().replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;,&quot;&quot;);</span>
						//ochrana pred duplikovanim cesty (ak mame root a v nom mame hlavnu stranku v podadresari s rovnakym nazvom)
<span class="nc bnc" id="L1696" title="All 2 branches missed.">						if (path.indexOf(newPath)!=0) path.insert(0, newPath);</span>
<span class="nc" id="L1697">					}</span>
					else
					{
<span class="fc" id="L1700">						String navbarName = group.getNavbar();</span>
<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">						if (navbarName.contains(&quot;*||&quot;)) navbarName = Tools.replace(navbarName, &quot;*||&quot;, &quot;&lt;/&quot;);</span>
<span class="pc bpc" id="L1702" title="1 of 2 branches missed.">						if (navbarName.contains(&quot;*|&quot;)) navbarName = Tools.replace(navbarName, &quot;*|&quot;, &quot;&lt;&quot;);</span>
<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">						if (navbarName.contains(&quot;|*&quot;)) navbarName = Tools.replace(navbarName, &quot;|*&quot;, &quot;&gt;&quot;);</span>
<span class="fc" id="L1704">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + navbarName;</span>
<span class="pc bpc" id="L1705" title="1 of 2 branches missed.">						if (path.indexOf(newPath)!=0) path.insert(0, newPath);</span>
					}
				}
<span class="fc" id="L1708">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L1713">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L1716" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L1718">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="pc bpc" id="L1724" title="1 of 2 branches missed.">			if (path.indexOf(&quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot;)==0)</span>
			{
<span class="fc" id="L1726">				return path.toString().substring(Constants.getString(&quot;navbarSeparator&quot;).length() + 2).trim();</span>
			}
		}
<span class="nc" id="L1729">		catch (Exception ex)</span>
		{
<span class="nc" id="L1731">		}</span>
<span class="nc" id="L1732">		return (path.toString());</span>
	}
	/**
	 * Vrati HTML kod pre Breadcrumb navigaciu vo formate schema.org
	 * @param groupId - ID adresara
	 * @param docId - ID aktualnej web stranky
	 * @param session
	 * @return
	 */
	public String getNavbarSchema(int groupId, int docId, HttpSession session)
	{
<span class="nc" id="L1743">		StringBuilder htmlCode = new StringBuilder();</span>
<span class="nc" id="L1744">		DocDB docDB = DocDB.getInstance();</span>

<span class="nc" id="L1746">		boolean finished = false;</span>
<span class="nc" id="L1747">		int currentGroupId = groupId;</span>
<span class="nc" id="L1748">		int depth = 0;</span>
<span class="nc" id="L1749">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc" id="L1751">		int realMaxDepth = 1;</span>

		// potrebujem zistit realny pocet urovni
<span class="nc bnc" id="L1754" title="All 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="nc" id="L1756">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1757" title="All 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="nc bnc" id="L1759" title="All 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1761">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1762">					continue;</span>
				}

<span class="nc" id="L1765">				Map&lt;String, String&gt; aparams = parseAparam(group.getNavbarName());</span>
<span class="nc bnc" id="L1766" title="All 8 branches missed.">				if (group.getDefaultDocId() &gt; 0 &amp;&amp; (!aparams.containsKey(&quot;class&quot;) || aparams.containsKey(&quot;class&quot;) &amp;&amp; !aparams.get(&quot;class&quot;).equalsIgnoreCase(&quot;is-headline&quot;))) {</span>
<span class="nc" id="L1767">					realMaxDepth++;</span>
				}
<span class="nc" id="L1769">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1770">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1774">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1777" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1779">				finished = true;</span>
			}
		}

<span class="nc" id="L1783">		depth = 0;</span>
<span class="nc" id="L1784">		currentGroupId = groupId;</span>
<span class="nc" id="L1785">		finished = false;</span>
<span class="nc" id="L1786">		int skippedCount = 0;</span>

<span class="nc bnc" id="L1788" title="All 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="nc" id="L1790">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1791" title="All 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="nc bnc" id="L1793" title="All 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1795">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1796">					skippedCount++;</span>
<span class="nc" id="L1797">					continue;</span>
				}

<span class="nc" id="L1800">				String groupNavbar = Tools.convertToHtmlTags(group.getNavbarName());</span>

<span class="nc" id="L1802">				Map&lt;String, String&gt; aparams = parseAparam(groupNavbar);</span>
<span class="nc bnc" id="L1803" title="All 6 branches missed.">				if (group.getDefaultDocId() &lt; 1 || aparams.containsKey(&quot;class&quot;) &amp;&amp; aparams.get(&quot;class&quot;).equalsIgnoreCase(&quot;is-headline&quot;)) {</span>
<span class="nc" id="L1804">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1805">					skippedCount++;</span>
<span class="nc" id="L1806">					continue;</span>
				}

<span class="nc bnc" id="L1809" title="All 8 branches missed.">				if (group.getDefaultDocId() &gt; 0 &amp;&amp; groupNavbar.length() &gt; 1 &amp;&amp; (groupNavbar.indexOf(&quot;&lt;a&quot;) &lt; 0 || groupNavbar.toLowerCase().indexOf(&quot;&lt;aparam&quot;) &gt;= 0))</span>
				{
					//odstrani &lt;aparam&gt;
<span class="nc" id="L1812">					String text = groupNavbar.replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;, &quot;&quot;);</span>
<span class="nc" id="L1813">					groupNavbar = &quot;\n\t&lt;li class=\&quot;is-item\&quot; itemprop=\&quot;itemListElement\&quot; itemscope itemtype=\&quot;http://schema.org/ListItem\&quot;&gt;&quot; +</span>
<span class="nc" id="L1814">							&quot;&lt;a href='&quot; + docDB.getDocLink(group.getDefaultDocId()) + &quot;' class='navbar' itemprop=\&quot;item\&quot;&gt;&quot; +</span>
<span class="nc" id="L1815">							&quot;&lt;span itemprop=\&quot;name\&quot;&gt;&quot; + Tools.convertToHtmlTags(text) + &quot;&lt;/span&gt;&quot; +</span>
							&quot;&lt;/a&gt;&quot; +
							&quot;&lt;meta itemprop=\&quot;position\&quot; content=\&quot;&quot; + (realMaxDepth - depth + skippedCount) + &quot;\&quot; /&gt;&lt;/li&gt;&quot;;
				}

<span class="nc bnc" id="L1820" title="All 4 branches missed.">				if (groupNavbar.length() &gt; 1 &amp;&amp; &quot;&amp;nbsp;&quot;.equals(group.getNavbarName())==false)</span>
				{
<span class="nc bnc" id="L1822" title="All 4 branches missed.">					if (Constants.getBoolean(&quot;navbarRenderAllLinks&quot;)==false &amp;&amp; group.getDefaultDocId()==docId)</span>
					{
<span class="nc" id="L1824">						String text = group.getNavbarName().replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;, &quot;&quot;);</span>
<span class="nc" id="L1825">						String newPath = Tools.convertToHtmlTags(text);</span>

						//ochrana pred duplikovanim cesty (ak mame root a v nom mame hlavnu stranku v podadresari s rovnakym nazvom)
<span class="nc bnc" id="L1828" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
<span class="nc" id="L1829">					}</span>
					else
					{
						//tu nepotrebujeme nahradu, tu uz len pridavame moznosti dokopy
<span class="nc" id="L1833">						String newPath = groupNavbar;</span>

<span class="nc bnc" id="L1835" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
					}
				}
<span class="nc" id="L1838">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1839">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1843">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1846" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1848">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="nc bnc" id="L1854" title="All 2 branches missed.">			if (htmlCode.indexOf(&quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot;)==0)</span>
			{
<span class="nc" id="L1856">				htmlCode = new StringBuilder(htmlCode.toString().substring(Constants.getString(&quot;navbarSeparator&quot;).length() + 2).trim());</span>
			}
		}
<span class="nc" id="L1859">		catch (Exception ex)</span>
		{
<span class="nc" id="L1861">		}</span>

<span class="nc" id="L1863">		htmlCode.insert(0, &quot;\n&lt;ol itemscope itemtype=\&quot;http://schema.org/BreadcrumbList\&quot;&gt;&quot;);</span>
<span class="nc" id="L1864">		htmlCode.append(&quot;\n&lt;/ol&gt;&quot;);</span>
<span class="nc" id="L1865">		return (htmlCode.toString());</span>
	}

	protected Map&lt;String, String&gt; parseAparam(String str) {
<span class="nc bnc" id="L1869" title="All 2 branches missed.">		if (!str.contains(&quot;&lt;aparam&quot;)) {</span>
<span class="nc" id="L1870">			return Collections.emptyMap();</span>
		}

		try {
<span class="nc" id="L1874">			String string = str.substring(str.indexOf(&quot;&lt;aparam&quot;), str.length());</span>
<span class="nc" id="L1875">			string = string.substring(0, string.indexOf(&quot;&gt;&quot;) - 1);</span>
<span class="nc" id="L1876">			string = string.substring(7, string.length()).trim();</span>

<span class="nc" id="L1878">			String[] arr = Tools.getTokens(string, &quot;&quot;);</span>
<span class="nc" id="L1879">			Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L1881" title="All 2 branches missed.">			for (String item : arr) {</span>
<span class="nc" id="L1882">				String[] items = Tools.getTokens(item, &quot;=&quot;);</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">				String value = items[1] != null ? Tools.replace(items[1], &quot;\&quot;&quot;, &quot;&quot;) : &quot;&quot;;</span>
<span class="nc" id="L1884">				result.put(items[0], value);</span>
			}

<span class="nc" id="L1887">			return result;</span>
		}
<span class="nc" id="L1889">		catch (Exception ex) {</span>
<span class="nc" id="L1890">			sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L1891">			return Collections.emptyMap();</span>
		}
	}

	/**
	 * Vrati HTML kod pre Breadcrumb navigaciu vo formate RDF
	 * http://support.google.com/webmasters/bin/answer.py?hl=en&amp;topic=1088474&amp;hlrm=en&amp;answer=185417&amp;ctx=topic
	 * @param groupId - ID adresara
	 * @param docId - ID aktualnej web stranky
	 * @param session
	 * @return
	 */
	public String getNavbarRDF(int groupId, int docId, HttpSession session)
	{
<span class="nc" id="L1905">		StringBuilder htmlCode = new StringBuilder();</span>
<span class="nc" id="L1906">		DocDB docDB = DocDB.getInstance();</span>

<span class="nc" id="L1908">		boolean finished = false;</span>
<span class="nc" id="L1909">		int currentGroupId = groupId;</span>
<span class="nc" id="L1910">		int depth = 0;</span>
<span class="nc" id="L1911">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc bnc" id="L1913" title="All 4 branches missed.">		while (finished == false &amp;&amp; depth++&lt;max_depth)</span>
		{
<span class="nc" id="L1915">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L1916" title="All 4 branches missed.">			if (group != null &amp;&amp; group.getGroupId()!=group.getParentGroupId())</span>
			{
<span class="nc bnc" id="L1918" title="All 4 branches missed.">				if (group.isInternal()==true || group.getMenuType(session)==GroupDetails.MENU_TYPE_HIDDEN)</span>
				{
<span class="nc" id="L1920">					currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1921">					continue;</span>
				}

<span class="nc" id="L1924">				String groupNavbar = group.getNavbarName();</span>
<span class="nc bnc" id="L1925" title="All 8 branches missed.">				if (group.getDefaultDocId() &gt; 0 &amp;&amp; groupNavbar.length() &gt; 1 &amp;&amp; (groupNavbar.indexOf(&quot;&lt;a&quot;) &lt; 0 || groupNavbar.toLowerCase().indexOf(&quot;&lt;aparam&quot;) &gt;= 0))</span>
				{
					//odstrani &lt;aparam&gt;
<span class="nc" id="L1928">					String text = groupNavbar.replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;,&quot;&quot;);</span>
<span class="nc" id="L1929">					groupNavbar = &quot;&lt;span typeof=\&quot;v:Breadcrumb\&quot;&gt;&lt;a href='&quot;+docDB.getDocLink(group.getDefaultDocId())+&quot;' class='navbar' rel=\&quot;v:url\&quot; property=\&quot;v:title\&quot;&gt;&quot; + text + &quot;&lt;/a&gt;&lt;/span&gt;&quot;;</span>
				}

<span class="nc bnc" id="L1932" title="All 4 branches missed.">				if (groupNavbar.length() &gt; 1 &amp;&amp; &quot;&amp;nbsp;&quot;.equals(group.getNavbarName())==false)</span>
				{
<span class="nc bnc" id="L1934" title="All 4 branches missed.">					if (Constants.getBoolean(&quot;navbarRenderAllLinks&quot;)==false &amp;&amp; group.getDefaultDocId()==docId)</span>
					{
<span class="nc" id="L1936">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + group.getNavbarName().replaceAll(&quot;(?i)&lt;aparam.*&gt;&quot;,&quot;&quot;);</span>
						//ochrana pred duplikovanim cesty (ak mame root a v nom mame hlavnu stranku v podadresari s rovnakym nazvom)
<span class="nc bnc" id="L1938" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
<span class="nc" id="L1939">					}</span>
					else
					{
<span class="nc" id="L1942">						String newPath = &quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot; + groupNavbar;</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">						if (htmlCode.indexOf(newPath)!=0) htmlCode.insert(0, newPath);</span>
					}
				}
<span class="nc" id="L1946">				currentGroupId = group.getParentGroupId();</span>
<span class="nc" id="L1947">			}</span>
			else
			{
				//group doesn't exist
<span class="nc" id="L1951">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L1954" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L1956">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="nc bnc" id="L1962" title="All 2 branches missed.">			if (htmlCode.indexOf(&quot; &quot;+Constants.getString(&quot;navbarSeparator&quot;)+&quot; &quot;)==0)</span>
			{
<span class="nc" id="L1964">				htmlCode = new StringBuilder(htmlCode.toString().substring(Constants.getString(&quot;navbarSeparator&quot;).length() + 2).trim());</span>
			}
		}
<span class="nc" id="L1967">		catch (Exception ex)</span>
		{
<span class="nc" id="L1969">		}</span>

<span class="nc" id="L1971">		htmlCode.insert(0, &quot;&lt;div class=\&quot;breadcrumbrdf\&quot; xmlns:v=\&quot;http://rdf.data-vocabulary.org/#\&quot;&gt;&quot;);</span>
<span class="nc" id="L1972">		htmlCode.append(&quot;&lt;/div&gt;&quot;);</span>
<span class="nc" id="L1973">		return (htmlCode.toString());</span>
	}


	/**
	 *  to iste ako getNavbar, len do ciest nedava linky (&lt;a href...)
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The navbarNoHref value
	 */
	public String getNavbarNoHref(int groupId)
	{
<span class="fc" id="L1985">		StringBuilder path = new StringBuilder();</span>
<span class="fc" id="L1986">		boolean finished = false;</span>
<span class="fc" id="L1987">		int currentGroupId = groupId;</span>
<span class="fc" id="L1988">		int depth = 0;</span>
<span class="fc" id="L1989">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L1991" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L1993">			group = findGroup(currentGroupId);</span>
<span class="fc bfc" id="L1994" title="All 2 branches covered.">			if (group != null)</span>
			{
<span class="pc bpc" id="L1996" title="1 of 2 branches missed.">				if (group.getNavbar().length() &gt; 1)</span>
				{
<span class="fc" id="L1998">					path.insert(0, &quot; &gt; &quot; + group.getNavbarName());</span>
				}
<span class="fc" id="L2000">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L2005">				finished = true;</span>
			}
<span class="fc" id="L2007">			depth++;</span>
<span class="pc bpc" id="L2008" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2010">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2013" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2015">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="fc bfc" id="L2021" title="All 2 branches covered.">			if (path.indexOf(&quot; &gt; &quot;)==0)</span>
			{
<span class="fc" id="L2023">				path = new StringBuilder(path.toString().substring(3).trim());</span>
			}
		}
<span class="nc" id="L2026">		catch (Exception ex)</span>
		{
<span class="fc" id="L2028">		}</span>

<span class="fc" id="L2030">		path = Tools.replace(path, &quot;href=&quot;, &quot;hrf=&quot;);</span>

<span class="fc" id="L2032">		return (path.toString());</span>
	}

	/**
	 *  vrati zoznam parent groups (pre pristupove prava)
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The parents value
	 */
	public String getParents(int groupId)
	{
<span class="fc" id="L2043">		StringBuilder path = new StringBuilder(&quot;&quot;);</span>
<span class="fc" id="L2044">		boolean finished = false;</span>
<span class="fc" id="L2045">		int currentGroupId = groupId;</span>
<span class="fc" id="L2046">		int depth = 0;</span>
<span class="fc" id="L2047">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2049" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2051">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2052" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="fc" id="L2054">				path.insert(0, group.getGroupId()).insert(0, &quot;,&quot;);</span>
<span class="fc" id="L2055">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2060">				finished = true;</span>
			}
<span class="fc" id="L2062">			depth++;</span>
<span class="pc bpc" id="L2063" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2065">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2068" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2070">				finished = true;</span>
			}
		}
		try
		{
			//odstran zobak na zaciatku
<span class="pc bpc" id="L2076" title="1 of 2 branches missed.">			if (path.toString().startsWith(&quot;,&quot;))</span>
			{
<span class="fc" id="L2078">				path.deleteCharAt(0);</span>
			}
		}
<span class="nc" id="L2081">		catch (Exception ex)</span>
		{
<span class="fc" id="L2083">		}</span>
<span class="fc" id="L2084">		return (path.toString());</span>
	}

	/**
	 * Vrati htmlHead atribut, hlada ho aj v nadradenych adresaroch
	 * @param groupId
	 * @return
	 */
	public String getHtmlHeadRecursive(int groupId)
	{
<span class="fc" id="L2094">		String htmlHead = null;</span>
<span class="fc" id="L2095">		boolean finished = false;</span>
<span class="fc" id="L2096">		int currentGroupId = groupId;</span>
<span class="fc" id="L2097">		int depth = 0;</span>
<span class="fc" id="L2098">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2100" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2102">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2103" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="pc bpc" id="L2105" title="2 of 4 branches missed.">				if (group.getHtmlHead()!=null &amp;&amp; group.getHtmlHead().length() &gt; 1)</span>
				{
<span class="nc" id="L2107">					htmlHead = group.getHtmlHead();</span>
<span class="nc" id="L2108">					finished = true;</span>
				}
<span class="fc" id="L2110">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2115">				finished = true;</span>
			}
<span class="fc" id="L2117">			depth++;</span>
<span class="pc bpc" id="L2118" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2120">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2123" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2125">				finished = true;</span>
			}
		}
<span class="pc bpc" id="L2128" title="1 of 2 branches missed.">		if (htmlHead==null)</span>
		{
<span class="fc" id="L2130">			htmlHead = &quot;&quot;;</span>
		}
<span class="fc" id="L2132">		return (htmlHead);</span>
	}

	/**
	 * Rekurzivne vrati akukolvek property pre zadany adresar
	 * @param groupId
	 * @param propertyName
	 * @return
	 */
	public String getPropertyRecursive(int groupId, String propertyName)
	{
<span class="fc" id="L2143">		boolean finished = false;</span>
<span class="fc" id="L2144">		int currentGroupId = groupId;</span>
<span class="fc" id="L2145">		int depth = 0;</span>
<span class="fc" id="L2146">		int max_depth = 30;</span>
		GroupDetails group;
		String value;
<span class="fc bfc" id="L2149" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2151">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2152" title="1 of 2 branches missed.">			if (group != null)</span>
			{
				try
				{
<span class="fc" id="L2156">					Object o = BeanUtils.getProperty(group, propertyName);</span>
					//Logger.debug(GroupsDB.class, &quot;o=&quot;+o.getClass());
<span class="fc" id="L2158">					value = (String)o;</span>
					//Logger.debug(GroupsDB.class, &quot;value=&quot;+value);
<span class="pc bpc" id="L2160" title="1 of 4 branches missed.">					if (Tools.isNotEmpty(value) &amp;&amp; &quot;0&quot;.equals(value)==false)</span>
					{
<span class="fc" id="L2162">						return(value);</span>
					}
				}
<span class="nc" id="L2165">				catch (Exception ex)</span>
				{
<span class="nc" id="L2167">					sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L2168">				}</span>
<span class="fc" id="L2169">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2174">				finished = true;</span>
			}
<span class="fc" id="L2176">			depth++;</span>
<span class="pc bpc" id="L2177" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2179">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2182" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2184">				finished = true;</span>
			}
		}
<span class="fc" id="L2187">		return (&quot;&quot;);</span>
	}

	/**
	 * Rekurzivne vrati id adresara v ktorom zadana property nadobuda hladanu hodnotu
	 * @param groupId
	 * @param propertyName
	 * @param propertyValue
	 * @return
	 */
	public int getGroupIdByPropertyValue(int groupId, String propertyName, String propertyValue)
	{
<span class="nc" id="L2199">		boolean finished = false;</span>
<span class="nc" id="L2200">		int currentGroupId = groupId;</span>
<span class="nc" id="L2201">		int depth = 0;</span>
<span class="nc" id="L2202">		int max_depth = 30;</span>
		GroupDetails group;
		String value;
<span class="nc bnc" id="L2205" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L2207">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L2208" title="All 2 branches missed.">			if (group != null)</span>
			{
				try
				{
<span class="nc" id="L2212">					Object o = BeanUtils.getProperty(group, propertyName);</span>
<span class="nc" id="L2213">					Logger.debug(GroupsDB.class, &quot;o=&quot;+o.getClass());</span>
<span class="nc" id="L2214">					value = (String)o;</span>
<span class="nc" id="L2215">					Logger.debug(GroupsDB.class, &quot;value=&quot;+value);</span>
<span class="nc bnc" id="L2216" title="All 6 branches missed.">					if (Tools.isNotEmpty(value) &amp;&amp; &quot;0&quot;.equals(value)==false &amp;&amp; propertyValue.indexOf(value) != -1)</span>
					{
<span class="nc" id="L2218">						return(currentGroupId);</span>
					}
				}
<span class="nc" id="L2221">				catch (Exception ex)</span>
				{
<span class="nc" id="L2223">					sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L2224">				}</span>
<span class="nc" id="L2225">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2230">				finished = true;</span>
			}
<span class="nc" id="L2232">			depth++;</span>
<span class="nc bnc" id="L2233" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2235">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L2238" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L2240">				finished = true;</span>
			}
		}
<span class="nc" id="L2243">		return -1;</span>
	}

	/**
	 * Rekurzivne ziska docid prihlasovacieho dialogu
	 * @param groupId
	 * @return
	 */
	public int getRecursiveLogonPageDocId(int groupId)
	{
<span class="fc" id="L2253">		int logonPageDocId = -1;</span>
<span class="fc" id="L2254">		boolean finished = false;</span>
<span class="fc" id="L2255">		int currentGroupId = groupId;</span>
<span class="fc" id="L2256">		int depth = 0;</span>
<span class="fc" id="L2257">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc bfc" id="L2259" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2261">			group = findGroup(currentGroupId);</span>
<span class="pc bpc" id="L2262" title="1 of 2 branches missed.">			if (group != null)</span>
			{
<span class="fc bfc" id="L2264" title="All 2 branches covered.">				if (group.getLogonPageDocId() &gt; 0)</span>
				{
					//Logger.println(this,&quot;logonPageDocId=&quot;+logonPageDocId+&quot; gid=&quot;+group.getGroupId());
<span class="fc" id="L2267">					logonPageDocId = group.getLogonPageDocId();</span>
<span class="fc" id="L2268">					finished = true;</span>
				}
<span class="fc" id="L2270">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2275">				finished = true;</span>
			}
<span class="fc" id="L2277">			depth++;</span>
<span class="pc bpc" id="L2278" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2280">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2283" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2285">				finished = true;</span>
			}
		}
<span class="fc" id="L2288">		return (logonPageDocId);</span>
	}

	/**
	 * vrati rootGrupu pre zadane groupId (pouziva sa koli jazykovym mutaciam)
	 * @param groupId
	 * @return
	 */
	public int getRoot(int groupId)
	{
<span class="nc" id="L2298">		int root = groupId;</span>
<span class="nc" id="L2299">		boolean finished = false;</span>
<span class="nc" id="L2300">		int currentGroupId = groupId;</span>
<span class="nc" id="L2301">		int depth = 0;</span>
<span class="nc" id="L2302">		int max_depth = 30;</span>
		GroupDetails group;
<span class="nc bnc" id="L2304" title="All 2 branches missed.">		while (finished == false)</span>
		{
<span class="nc" id="L2306">			group = findGroup(currentGroupId);</span>
<span class="nc bnc" id="L2307" title="All 2 branches missed.">			if (group != null)</span>
			{
<span class="nc bnc" id="L2309" title="All 2 branches missed.">				if (group.getNavbar().length() &gt; 1)</span>
				{
<span class="nc" id="L2311">					root = group.getGroupId();</span>
				}
<span class="nc" id="L2313">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="nc" id="L2318">				finished = true;</span>
			}
<span class="nc" id="L2320">			depth++;</span>
<span class="nc bnc" id="L2321" title="All 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2323">				finished = true;</span>
			}
			//we are on the root group
<span class="nc bnc" id="L2326" title="All 2 branches missed.">			if (currentGroupId == 0)</span>
			{
<span class="nc" id="L2328">				finished = true;</span>
			}
		}
<span class="nc" id="L2331">		return (root);</span>
	}


	/**
	 *  Vrati List zo zoznamom rodicovskych skupin (cesta k root adresaru)
	 *  VYNECHA tie, ktore maju prazdnu hodnotu v poli navbar
	 *
	 *@param  groupId  Description of the Parameter
	 *@return          The parentGroups value
	 */
	public List&lt;GroupDetails&gt; getParentGroups(int groupId) {
<span class="fc" id="L2343">		return getParentGroups(groupId, false);</span>
	}

	/**
	 * Vrati zoznam rodicovskych adresarov (vratane zadaneho groupId)
	 * @param groupId
	 * @param includeWithEmptyNavbar - ak je false pridaju sa do zoznamu len adresare, ktore naju neprazdne pole navbar
	 * @return
	 */
	public List&lt;GroupDetails&gt; getParentGroups(int groupId, boolean includeWithEmptyNavbar)
	{
<span class="fc" id="L2354">		boolean finished = false;</span>
<span class="fc" id="L2355">		int currentGroupId = groupId;</span>
<span class="fc" id="L2356">		int depth = 0;</span>
<span class="fc" id="L2357">		int max_depth = 30;</span>
		GroupDetails group;
<span class="fc" id="L2359">		List&lt;GroupDetails&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2360" title="All 2 branches covered.">		while (finished == false)</span>
		{
<span class="fc" id="L2362">			group = findGroup(currentGroupId);</span>
<span class="fc bfc" id="L2363" title="All 2 branches covered.">			if (group != null)</span>
			{
<span class="pc bpc" id="L2365" title="1 of 4 branches missed.">				if (includeWithEmptyNavbar || group.getNavbar().length() &gt; 1)</span>
				{
					//path = path + &quot;,&quot; + group.getGroupId();
<span class="fc" id="L2368">					ret.add(group);</span>
				}
<span class="fc" id="L2370">				currentGroupId = group.getParentGroupId();</span>
			}
			else
			{
				//group doesn't exist
<span class="fc" id="L2375">				finished = true;</span>
			}
<span class="fc" id="L2377">			depth++;</span>
<span class="pc bpc" id="L2378" title="1 of 2 branches missed.">			if (depth &gt; max_depth)</span>
			{
<span class="nc" id="L2380">				finished = true;</span>
			}
			//we are on the root group
<span class="fc bfc" id="L2383" title="All 2 branches covered.">			if (currentGroupId == 0)</span>
			{
<span class="fc" id="L2385">				finished = true;</span>
			}
		}

<span class="fc" id="L2389">		return (ret);</span>
	}

	/**
	 *  vrati nacitane skupiny, je to tu takto ako ArrayList kvoli legacy JSP kodu
	 *
	 *@return    The groups value
	 *@deprecated - pouzivajte verziu getGroupsAll
	 */
	@Deprecated
	public List&lt;GroupDetails&gt; getGroups()
	{
<span class="nc" id="L2401">		List&lt;GroupDetails&gt; arlist = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2402">		arlist.addAll(groups);</span>
<span class="nc" id="L2403">		return arlist;</span>
	}

	/**
	 * Vrati vsetky nacitane skupiny
	 * @return
	 */
	public List&lt;GroupDetails&gt; getGroupsAll()
	{
<span class="fc" id="L2412">		return groups;</span>
	}

	/**
	 *  skontroluje ci uz neexistuje skupina s danym menom v danej skupine
	 *
	 *@param  parentId  id rodica skupiny
	 *@param  name       meno novej skupiny
	 *@return            true ak uz existuje, false inak
	 */
	public boolean checkExist(int parentId, String name)
	{
<span class="fc bfc" id="L2424" title="All 2 branches covered.">		for (GroupDetails group : getGroupsAll())</span>
		{
<span class="fc bfc" id="L2426" title="All 4 branches covered.">			if (group.getParentGroupId() == parentId &amp;&amp; group.getGroupName().compareToIgnoreCase(name) == 0)</span>
			{
<span class="fc" id="L2428">				return (true);</span>
			}
<span class="fc" id="L2430">		}</span>
<span class="fc" id="L2431">		return (false);</span>
	}

	/**
	 *  skontroluje ci uz existuje skupina s danym menom v danej skupine a vrati
	 *  jej id (ak existuje)
	 *
	 *@param  name             meno novej skupiny
	 *@param  parent_group_id  Description of the Parameter
	 *@return                  id skupiny ak existuje, -1 inak
	 */
	public int checkExist2(int parent_group_id, String name)
	{
<span class="nc bnc" id="L2444" title="All 2 branches missed.">		for (GroupDetails group : getGroupsAll())</span>
		{
<span class="nc bnc" id="L2446" title="All 4 branches missed.">			if (group.getParentGroupId() == parent_group_id &amp;&amp; group.getGroupName().compareToIgnoreCase(name) == 0)</span>
			{
<span class="nc" id="L2448">				return group.getGroupId();</span>
			}
<span class="nc" id="L2450">		}</span>
<span class="nc" id="L2451">		return -1;</span>
	}

	/**
	 * Vrati String s rekurzivny zoznamom groupId, ktore mame zadane ako origPerexGroup. Pouziva sa v JSP
	 * strankach pri volani DocDB.getDocPerex()
	 * @param origGroupIds
	 * @return
	 */
	public static String getRecursiveGroupsSqlIn(String origGroupIds)
	{
		//ziskaj rekurzivne stranky
<span class="nc" id="L2463">		StringTokenizer st = new StringTokenizer(origGroupIds, &quot;,&quot;);</span>
		int groupId;
		List&lt;GroupDetails&gt; childs;
<span class="nc" id="L2466">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="nc" id="L2467">		StringBuilder groupIds = null;</span>
<span class="nc bnc" id="L2468" title="All 2 branches missed.">		while (st.hasMoreTokens())</span>
		{
			try
			{
<span class="nc" id="L2472">				groupId = Integer.parseInt(st.nextToken());</span>
<span class="nc" id="L2473">				childs = groupsDB.getGroupsTree(groupId, true, false);</span>
<span class="nc bnc" id="L2474" title="All 2 branches missed.">				for (GroupDetails group : childs)</span>
				{
<span class="nc bnc" id="L2476" title="All 2 branches missed.">					if (groupIds == null)</span>
					{
<span class="nc" id="L2478">						groupIds = new StringBuilder(String.valueOf(group.getGroupId()));</span>
					}
					else
					{
<span class="nc" id="L2482">						groupIds.append(&quot;,&quot;).append(String.valueOf(group.getGroupId()));</span>
					}
<span class="nc" id="L2484">				}</span>
			}
<span class="nc" id="L2486">			catch (Exception ex)</span>
			{
<span class="nc" id="L2488">				sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L2489">			}</span>
		}
<span class="nc bnc" id="L2491" title="All 2 branches missed.">		if (groupIds==null) return null;</span>
<span class="nc" id="L2492">		return(groupIds.toString());</span>
	}

	/**
	 * Vrati grupu podla fullPath (ak je zadane) alebo podla syncId (ak nenajde podla fullPath)
	 * @param fullPath - hodnota fullPath na remote serveri (alebo null, ak chceme hladat len podla syncId)
	 * @param syncId - hodnota groupId na remote serveri
	 * @return
	 */
	public GroupDetails getGroupBySync(String fullPath, int syncId)
	{

<span class="nc bnc" id="L2504" title="All 2 branches missed.">		if (Tools.isNotEmpty(fullPath))</span>
		{
<span class="nc bnc" id="L2506" title="All 2 branches missed.">			for (GroupDetails group : groups)</span>
			{
<span class="nc bnc" id="L2508" title="All 2 branches missed.">				if (group.getFullPath().equalsIgnoreCase(fullPath))</span>
				{
<span class="nc" id="L2510">					return(group);</span>
				}
<span class="nc" id="L2512">			}</span>
		}

<span class="nc bnc" id="L2515" title="All 2 branches missed.">		if (syncId == 0) return(null);</span>

<span class="nc bnc" id="L2517" title="All 2 branches missed.">		for (GroupDetails group : groups)</span>
		{
<span class="nc bnc" id="L2519" title="All 2 branches missed.">			if (group.getSyncId() == syncId)</span>
			{
<span class="nc" id="L2521">				return(group);</span>
			}
<span class="nc" id="L2523">		}</span>
<span class="nc" id="L2524">		return (null);</span>
	}

	/**
	 * Vrati/vytvori skupinu podla zadanej cesty
	 * @param path - cesta vo formate /adresar1/adresar2
	 * @return
	 */
	public GroupDetails getCreateGroup(String path)
	{
		//check if path is number, then get GroupDetails by ID
		try {
<span class="nc" id="L2536">			int groupId = Integer.parseInt(path);</span>
<span class="nc" id="L2537">			return(getGroup(groupId));</span>
<span class="fc" id="L2538">		} catch(Exception ex) {</span>
			//not a number, continue
		}

<span class="fc" id="L2542">		int domainSeparatorIndex = path.indexOf(&quot;:&quot;);</span>
<span class="pc bpc" id="L2543" title="1 of 2 branches missed.">		if (domainSeparatorIndex&gt;0) {</span>
<span class="nc" id="L2544">			String domain = path.substring(0, domainSeparatorIndex);</span>
<span class="nc" id="L2545">			RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="nc bnc" id="L2546" title="All 2 branches missed.">			if (rb != null) {</span>
<span class="nc" id="L2547">				rb.setDomain(domain);</span>
			}
<span class="nc" id="L2549">			path = path.substring(domainSeparatorIndex+1);</span>
		}

<span class="pc bpc" id="L2552" title="1 of 2 branches missed.">		if (path.contains(&quot;/&quot;)==false) {</span>
<span class="nc" id="L2553">			return null;</span>
		}

<span class="fc" id="L2556">		int actualParent = 0;</span>
<span class="pc bpc" id="L2557" title="1 of 2 branches missed.">		if(InitServlet.isTypeCloud())</span>
		{
			//ak sa jedna napr. o /System/Kos tak sa nastavi parent na ID hlavneho adresara namiesto na 0 (globalny System folder)
<span class="nc bnc" id="L2560" title="All 2 branches missed.">			if (path.startsWith(&quot;/&quot;+CloudToolsForCore.getDomainName())==false)	actualParent = CloudToolsForCore.getDomainId();</span>
		}
<span class="pc bpc" id="L2562" title="1 of 4 branches missed.">		else if (Constants.getBoolean(&quot;templatesUseDomainLocalSystemFolder&quot;)==true &amp;&amp; path.startsWith(&quot;/System/&quot;))</span>
		{
			//overenie lokalneho /System/Kos adresara
<span class="fc" id="L2565">			Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L2566">			String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>
<span class="pc bpc" id="L2567" title="1 of 2 branches missed.">			if (path.equals(trashDirName))</span>
			{
<span class="fc" id="L2569">				GroupDetails localSystemGroup = getLocalSystemGroup();</span>
				//pre pripad ze je /System priecinok niekde v subdomene, napr. /English/System/ zaciname hladat v /English priecinku (povazujeme ho za root)
<span class="pc bpc" id="L2571" title="1 of 4 branches missed.">				if (localSystemGroup != null &amp;&amp; localSystemGroup.getParentGroupId()&gt;0) actualParent = localSystemGroup.getParentGroupId();</span>
			}
		}

<span class="fc" id="L2575">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
		String actualGroupName;
<span class="fc" id="L2577">		StringTokenizer st = new StringTokenizer(path, &quot;/&quot;);</span>
		GroupDetails actualGroup;
<span class="fc" id="L2579">		GroupDetails parentGroup = null;</span>
<span class="pc bpc" id="L2580" title="1 of 2 branches missed.">		while (st.hasMoreTokens())</span>
		{
<span class="fc" id="L2582">			actualGroupName = st.nextToken();</span>

			//ak by boli za sebou nahodou //
<span class="pc bpc" id="L2585" title="1 of 2 branches missed.">			if (Tools.isEmpty(actualGroupName)) continue;</span>

<span class="pc bpc" id="L2587" title="1 of 6 branches missed.">			if (&quot;System&quot;.equals(actualGroupName) &amp;&amp; actualParent==0 &amp;&amp; Constants.getBoolean(&quot;templatesUseDomainLocalSystemFolder&quot;)) actualGroup = getLocalSystemGroup();</span>
<span class="fc" id="L2588">            else actualGroup = getGroup(actualGroupName, actualParent);</span>

<span class="fc bfc" id="L2590" title="All 2 branches covered.">			if (actualGroup == null)</span>
			{
<span class="fc" id="L2592">				actualGroup = new GroupDetails();</span>
				//vytvor skupinu, nastav prava podla parenta
<span class="pc bpc" id="L2594" title="1 of 2 branches missed.">				if (parentGroup != null)</span>
				{
					try
					{
<span class="fc" id="L2598">						BeanUtils.copyProperties(actualGroup, parentGroup);</span>
					}
<span class="nc" id="L2600">					catch (Exception ex)</span>
					{
<span class="nc" id="L2602">						sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L2603">					}</span>
<span class="fc" id="L2604">					actualGroup.setParentGroupId(parentGroup.getGroupId());</span>
<span class="fc" id="L2605">					actualGroup.setSyncId(0);</span>
				} else {
<span class="nc bnc" id="L2607" title="All 6 branches missed.">					if (rb != null &amp;&amp; Tools.isNotEmpty(rb.getDomain()) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true) {</span>
						//nastav domenu
<span class="nc" id="L2609">						actualGroup.setDomainName(rb.getDomain());</span>
					}
				}

<span class="fc" id="L2613">				actualGroup.setGroupId(-1);</span>
<span class="fc" id="L2614">				actualGroup.setDefaultDocId(-1);</span>
<span class="fc" id="L2615">				actualGroup.setGroupName(actualGroupName);</span>
<span class="fc" id="L2616">				actualGroup.setNavbar(actualGroupName);</span>
<span class="fc" id="L2617">				actualGroup.setUrlDirName(actualGroupName);</span>

<span class="fc" id="L2619">				actualGroup.setSortPriority(getDefaultSortPriority(actualGroup.getParentGroupId()));</span>

<span class="fc" id="L2621">				setGroup(actualGroup);</span>
			}

<span class="fc bfc" id="L2624" title="All 2 branches covered.">			if (st.hasMoreTokens()==false)</span>
			{
				//sme na konci
<span class="fc" id="L2627">				return(actualGroup);</span>
			}

<span class="fc" id="L2630">			actualParent = actualGroup.getGroupId();</span>
<span class="fc" id="L2631">			parentGroup = actualGroup;</span>
		}
<span class="nc" id="L2633">		return(null);</span>
	}

	/**
	 * Ziska docId sablony novej stranky pre zadany adresar (zvycajne vrati -1 = prazdna stranka)
	 * @param groupId
	 * @return
	 */
	public static int getNewPageDocIdTemplate(int groupId)
	{
<span class="nc" id="L2643">		GroupsDB groupsDB = GroupsDB.getInstance();</span>

<span class="nc" id="L2645">		int newPageDocIdTemplate = Constants.getInt(&quot;newDocumentId&quot;);</span>
<span class="nc" id="L2646">		int groupNewPageDocIdTemplate = Tools.getIntValue(groupsDB.getPropertyRecursive(groupId, &quot;newPageDocIdTemplate&quot;), 0);</span>
<span class="nc bnc" id="L2647" title="All 2 branches missed.">		if (groupNewPageDocIdTemplate!=0)</span>
		{
<span class="nc bnc" id="L2649" title="All 2 branches missed.">			if (groupNewPageDocIdTemplate == -1)</span>
			{
				//prehladaj podla nazvu sablony
<span class="nc" id="L2652">				GroupDetails actualGroup = groupsDB.getGroup(groupId);</span>
<span class="nc" id="L2653">				int tempId = actualGroup.getTempId();</span>
<span class="nc" id="L2654">				TemplateDetails temp = TemplatesDB.getInstance().getTemplate(tempId);</span>
<span class="nc" id="L2655">				DocDB docDB = DocDB.getInstance();</span>
<span class="nc" id="L2656">				List&lt;DocDetails&gt; temps = docDB.getDocByGroup(Constants.getInt(&quot;tempGroupId&quot;));</span>
<span class="nc bnc" id="L2657" title="All 4 branches missed.">				if (temps!=null &amp;&amp; temp!=null)</span>
				{
<span class="nc" id="L2659">					String tempName = DB.internationalToEnglish(temp.getTempName());</span>
<span class="nc bnc" id="L2660" title="All 2 branches missed.">					for (DocDetails doc : temps)</span>
					{
<span class="nc bnc" id="L2662" title="All 2 branches missed.">						if (DB.internationalToEnglish(doc.getTitle()).equalsIgnoreCase(tempName))</span>
						{
<span class="nc" id="L2664">							newPageDocIdTemplate = -doc.getDocId();</span>
<span class="nc" id="L2665">							break;</span>
						}
<span class="nc" id="L2667">					}</span>
				}
<span class="nc" id="L2669">			}</span>
			else
			{
<span class="nc" id="L2672">				newPageDocIdTemplate = -groupNewPageDocIdTemplate;</span>
			}
		}
<span class="nc" id="L2675">		return(newPageDocIdTemplate);</span>
	}

	/**
	 * Vymazanie adresara
	 * @param groupId - id adresara
	 * @param request - request (treba kvoli admin logu, ale moze byt aj null)
	 * @return
	 */
	public static boolean deleteGroup(int groupId, HttpServletRequest request)
	{
<span class="fc" id="L2686">		return deleteGroup(groupId, request, true, false);</span>
	}
	/**
	 * Vymazanie adresara
	 * @param groupId - id adresara
	 * @param request - request (treba kvoli admin logu, ale moze byt aj null)
	 * @param includeParent - urci, ci ma pri vymazani brat aj rodicovsky adresar
	 * @param permanentlyDelete - nevlozi do kosa, ale priamo vymaze
	 * @return
	 */
	public static boolean deleteGroup(int groupId, HttpServletRequest request, boolean includeParent, boolean permanentlyDelete)
	{
<span class="fc" id="L2698">		return deleteGroup(groupId, includeParent, permanentlyDelete, true);</span>
	}

	private static void deleteGroupsApprove(String groups) {
<span class="nc" id="L2702">		(new SimpleQuery()).execute(&quot;DELETE FROM groups_approve WHERE group_id IN (?)&quot;, groups);</span>
<span class="nc" id="L2703">	}</span>

	/**
	 * Vymazanie adresara
	 * @param groupId - id adresara
	 * @param request - request (treba kvoli admin logu, ale moze byt aj null)
	 * @param includeParent - urci, ci ma pri vymazani brat aj rodicovsky adresar
	 * @param permanentlyDelete - nevlozi do kosa, ale priamo vymaze
	 * @param publishEvents - ak je true, su vyvolane udalosti (false potrebne ak napr. reagujeme na udalost a potrebujeme znova upravit adresar a nechceme aby doslo k zacykleniu)
	 * @return
	 */
	public static boolean deleteGroup(int groupId, boolean includeParent, boolean permanentlyDelete, boolean publishEvents)
	{
<span class="fc" id="L2716">		Connection db_conn = null;</span>
<span class="fc" id="L2717">		PreparedStatement ps = null;</span>
<span class="fc" id="L2718">		GroupsDB groupsDB = GroupsDB.getInstance();</span>

		//kontrola prav
<span class="fc" id="L2721">		GroupDetails group = groupsDB.getGroup(groupId);</span>

<span class="pc bpc" id="L2723" title="1 of 2 branches missed.">		if (InitServlet.isTypeCloud())</span>
		{
<span class="nc bnc" id="L2725" title="All 4 branches missed.">			if (group == null || group.getDomainName().equals(CloudToolsForCore.getDomainName())==false)</span>
			{
<span class="nc" id="L2727">				return false;</span>
			}
		}

		try
		{
<span class="pc bpc" id="L2733" title="1 of 4 branches missed.">			if (group!=null &amp;&amp; publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(group, WebjetEventType.ON_DELETE)).publishEvent();</span>

			//	zmazanie grupy
<span class="fc" id="L2736">			db_conn = DBPool.getConnection();</span>

			// zisti ci sme v adresari /System/Trash (kos), ak nie presun, inak vymaz
<span class="fc" id="L2739">         String navbarNoHref = groupsDB.getURLPath(groupId);</span>
<span class="fc" id="L2740">         Logger.debug(GroupsDB.class, &quot;MAZEM: &quot; + navbarNoHref);</span>

         //tu sa vytvara adresar podla default jazyka, nie podla prihlaseneho pouzivatela!
<span class="fc" id="L2743">         Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L2744">         String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>
<span class="fc" id="L2745">         GroupDetails trashGroupDetails = null;</span>
<span class="fc" id="L2746">         boolean disableHistory = Constants.getBoolean(&quot;editorDisableHistory&quot;);</span>
<span class="fc" id="L2747">         boolean foundSystemDir = false;</span>
<span class="pc bpc" id="L2748" title="1 of 2 branches missed.">         if (disableHistory == false) trashGroupDetails = groupsDB.getCreateGroup(trashDirName);</span>

<span class="pc bpc" id="L2750" title="3 of 6 branches missed.">      	if (permanentlyDelete || trashGroupDetails==null || DB.internationalToEnglish(navbarNoHref.toLowerCase()).startsWith(DB.internationalToEnglish(groupsDB.getURLPath(trashGroupDetails.getGroupId())).toLowerCase()) ||</span>
<span class="pc bpc" id="L2751" title="2 of 4 branches missed.">				trashGroupDetails.getGroupId()==groupId || trashDirName.equals(groupsDB.getURLPath(groupId)))</span>
        {
      		//TODO: kontrola prav na mazanie stranok v adresari

      		// ziskaj zoznam groups (tejto a podskupin)
<span class="nc" id="L2756">				StringBuilder groups = new StringBuilder();</span>
				//List subGroups = groupsDB.getGroups(my_form.getGroupId());
<span class="nc" id="L2758">				List&lt;GroupDetails&gt; subGroups = groupsDB.getGroupsTree(groupId, includeParent, true);</span>

<span class="nc bnc" id="L2760" title="All 2 branches missed.">				for (GroupDetails element : subGroups)</span>
				{
<span class="nc bnc" id="L2762" title="All 2 branches missed.">					if (groups.length() &gt; 0)</span>
<span class="nc" id="L2763">						groups.append(',');</span>
<span class="nc" id="L2764">					groups.append(element.getGroupId());</span>
					//refresh cache
<span class="nc" id="L2766">					groupsDB.removeGroupFromCache(element, false);</span>

<span class="nc bnc" id="L2768" title="All 4 branches missed.">					if(foundSystemDir == false &amp;&amp; &quot;System&quot;.equalsIgnoreCase(element.getGroupName())) foundSystemDir = true;</span>
<span class="nc" id="L2769">				}</span>

<span class="nc bnc" id="L2771" title="All 2 branches missed.">				if(Tools.isNotEmpty(groups))	//ak nezaratam rodicovsky adresa, moze byt groups prazdne v pripade, ak rodicovsky adresar nemal ziadne podadresare</span>
				{
					//vymaz stranky
<span class="nc" id="L2774">					String sql = &quot;DELETE FROM documents WHERE group_id IN (&quot;+groups+&quot;)&quot;;</span>
<span class="nc" id="L2775">					ps = db_conn.prepareStatement(sql);</span>
<span class="nc" id="L2776">					ps.executeUpdate();</span>
<span class="nc" id="L2777">					ps.close();</span>
<span class="nc" id="L2778">					ps = null;</span>

					//vymaz adresare
<span class="nc" id="L2781">					sql = &quot;DELETE FROM groups WHERE group_id IN (&quot;+groups+&quot;)&quot;;</span>
<span class="nc" id="L2782">					ps = db_conn.prepareStatement(sql);</span>
<span class="nc" id="L2783">					ps.executeUpdate();</span>
<span class="nc" id="L2784">					ps.close();</span>
<span class="nc" id="L2785">					ps = null;</span>

					//Vymaz approve
<span class="nc" id="L2788">					deleteGroupsApprove(groups.toString());</span>
				}

<span class="nc" id="L2791">				Adminlog.add(Adminlog.TYPE_GROUP, &quot;Delete group: &quot; + navbarNoHref, groupId, -1);</span>
<span class="nc" id="L2792">		}</span>
      	else
      	{
      		// presun adresar do trashu
<span class="fc" id="L2796">				String sql = &quot;UPDATE groups SET parent_group_id=?, sync_status=1 WHERE group_id=?&quot;;</span>
<span class="fc" id="L2797">				ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2798">				ps.setInt(1, trashGroupDetails.getGroupId());</span>
<span class="fc" id="L2799">				ps.setInt(2, groupId);</span>
<span class="fc" id="L2800">				ps.executeUpdate();</span>
<span class="fc" id="L2801">				ps.close();</span>
<span class="fc" id="L2802">				ps = null;</span>

<span class="fc" id="L2804">				Adminlog.add(Adminlog.TYPE_GROUP, &quot;Delete group (move to trash): &quot; + navbarNoHref, groupId, -1);</span>

				//refresh cache
<span class="fc" id="L2807">				groupsDB.findGroup(groupId).setParentGroupId( trashGroupDetails.getGroupId() );</span>

				//deaktivuj vsetky stranky v tejto skupine a podskupinach
<span class="fc" id="L2810">				StringBuilder groups = new StringBuilder();</span>
<span class="fc" id="L2811">				List&lt;GroupDetails&gt; subGroups = groupsDB.getGroupsTree(groupId, true, true);</span>

<span class="fc bfc" id="L2813" title="All 2 branches covered.">				for (GroupDetails g : subGroups)</span>
				{
<span class="fc" id="L2815">					g.setFullPath(groupsDB.getPath(g.getGroupId()));</span>

<span class="fc bfc" id="L2817" title="All 2 branches covered.">					if (groups.length() &gt; 0)</span>
<span class="fc" id="L2818">						groups.append(',').append(g.getGroupId());</span>
					else
<span class="fc" id="L2820">						groups.append(g.getGroupId());</span>

<span class="pc bpc" id="L2822" title="2 of 4 branches missed.">					if(foundSystemDir == false &amp;&amp; &quot;System&quot;.equalsIgnoreCase(g.getGroupName())) foundSystemDir = true;</span>
<span class="fc" id="L2823">				}</span>
				// zakaz zobrazovanie stranok
<span class="fc" id="L2825">				sql = &quot;UPDATE documents SET available=?, sync_status=1 WHERE group_id IN (&quot;+groups.toString()+&quot;)&quot;;</span>
<span class="fc" id="L2826">				ps = db_conn.prepareStatement(sql);</span>
<span class="fc" id="L2827">				ps.setBoolean(1, false);</span>
<span class="fc" id="L2828">				ps.executeUpdate();</span>
<span class="fc" id="L2829">				ps.close();</span>
<span class="fc" id="L2830">				ps = null;</span>

				//aktualizuj FT stplce
<span class="fc" id="L2833">				DocDB.updateFileNameField(groupId);</span>
      	}

      	//ak sa jedna o system adresar, refreshnem zoznam tychto stranok
<span class="pc bpc" id="L2837" title="1 of 2 branches missed.">			if(foundSystemDir) groupsDB.getAllSystemFolders(true);</span>

<span class="fc" id="L2839">			db_conn.close();</span>
<span class="fc" id="L2840">			db_conn = null;</span>
			//oznam ostatnym Node-om, ze sa nieco zmenilo
<span class="fc" id="L2842">			ClusterDB.addRefresh(GroupsDB.class);</span>
<span class="fc" id="L2843">			ClusterDB.addRefresh(DocDB.class);</span>
<span class="fc" id="L2844">			GroupsDB.getInstance(true);</span>
<span class="fc" id="L2845">			DocDB.getInstance(true);</span>

<span class="pc bpc" id="L2847" title="1 of 4 branches missed.">			if (group!=null &amp;&amp; publishEvents) (new WebjetEvent&lt;GroupDetails&gt;(group, WebjetEventType.AFTER_DELETE)).publishEvent();</span>

<span class="fc" id="L2849">			return(true);</span>
		}
<span class="nc" id="L2851">		catch (Exception ex)</span>
		{
<span class="nc" id="L2853">			sk.iway.iwcm.Logger.error(ex);</span>
		}
		finally
		{
			try
			{
<span class="pc bpc" id="L2859" title="1 of 2 branches missed.">				if (ps != null)</span>
<span class="nc" id="L2860">					ps.close();</span>
<span class="pc bpc" id="L2861" title="1 of 2 branches missed.">				if (db_conn != null)</span>
<span class="nc" id="L2862">					db_conn.close();</span>
			}
<span class="nc" id="L2864">			catch (Exception ex2)</span>
			{
<span class="fc" id="L2866">			}</span>
		}
<span class="nc" id="L2868">		return(false);</span>
	}

	/**
	 * Vrati TreeMap so zoznamom = retazec id adresarov oddelenych ciarkami pridelenych ku skupine obsiahnutej v hodnote kluca
	 * @return
	 */
	public static Map&lt;Integer, String&gt; getProtectedGroups()
	{
<span class="nc" id="L2877">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="nc" id="L2878">		List&lt;GroupDetails&gt; groups = groupsDB.getGroupsAll();</span>
<span class="nc" id="L2879">		TreeMap&lt;Integer, String&gt; tm = new TreeMap&lt;&gt;();</span>
<span class="nc bnc" id="L2880" title="All 2 branches missed.">		for (GroupDetails groupDetails : groups)</span>
		{
<span class="nc bnc" id="L2882" title="All 2 branches missed.">			if(Tools.isNotEmpty(groupDetails.getPasswordProtected()))</span>
			{
<span class="nc bnc" id="L2884" title="All 2 branches missed.">				if(groupDetails.getPasswordProtected().indexOf(',') &lt; 0)</span>
				{
<span class="nc bnc" id="L2886" title="All 2 branches missed.">					if(tm.containsKey(Integer.valueOf(groupDetails.getPasswordProtected())))</span>
					{
<span class="nc" id="L2888">						String tmp = tm.get(Integer.valueOf(groupDetails.getPasswordProtected()));</span>
<span class="nc" id="L2889">						tm.put(Integer.valueOf(groupDetails.getPasswordProtected()), tmp.concat(groupDetails.getGroupId()+&quot;,&quot;));</span>

<span class="nc" id="L2891">					}else{</span>
<span class="nc" id="L2892">						tm.put(Integer.valueOf(groupDetails.getPasswordProtected()), groupDetails.getGroupId()+&quot;,&quot;);</span>
					}
				}else{
<span class="nc" id="L2895">					String[] tmp = groupDetails.getPasswordProtected().split(&quot;,&quot;);</span>
<span class="nc bnc" id="L2896" title="All 2 branches missed.">					for (int i = 0; i &lt; tmp.length; i++)</span>
					{
<span class="nc bnc" id="L2898" title="All 2 branches missed.">						if(tm.containsKey(Integer.valueOf(tmp[i])))</span>
						{
<span class="nc" id="L2900">							String tmp2 = tm.get(Integer.valueOf(tmp[i]));</span>
<span class="nc" id="L2901">							tm.put(Integer.valueOf(tmp[i]), tmp2.concat(groupDetails.getGroupId()+&quot;,&quot;));</span>

<span class="nc" id="L2903">						}else{</span>
<span class="nc" id="L2904">							tm.put(Integer.valueOf(tmp[i]), groupDetails.getGroupId()+&quot;,&quot;);</span>
						}
					}
				}
			}
<span class="nc" id="L2909">		}</span>
		/*
		for (Iterator iterator = tm.entrySet().iterator(); iterator.hasNext();)
		{
			Map.Entry&lt;Integer, String&gt; key = (Map.Entry&lt;Integer, String&gt;)iterator.next();
			System.out.println(&quot;&gt;&gt; KEY: &quot;+key.getKey()+&quot; &gt; VALUE: &quot;+key.getValue());
		}
		*/
<span class="nc" id="L2917">		return tm;</span>
	}

	/**
	 * Vrati zoznam ID podadresarov zadaneho adresara (vratane)
	 * napr 1,5,77,28
	 * @param groupId
	 * @return
	 */
	public String getSubgroupsIds(int groupId)
	{
<span class="fc" id="L2928">		List&lt;GroupDetails&gt; subGroups = getGroupsTree(groupId, false, true);</span>
<span class="fc" id="L2929">		StringBuilder groupIds = new StringBuilder().append(groupId);</span>
<span class="fc bfc" id="L2930" title="All 2 branches covered.">		for (GroupDetails grp : subGroups)</span>
		{
<span class="fc" id="L2932">			groupIds.append(',').append(grp.getGroupId());</span>
<span class="fc" id="L2933">		}</span>

<span class="fc" id="L2935">		return groupIds.toString();</span>
	}

	/**
	 * Vrati zoznam ID adresarov so zadanou domenou (pouzitelne pre IN select)
	 * @param domainName
	 * @return
	 */
	public String getSubgroupsIds(String domainName)
	{
<span class="pc bpc" id="L2945" title="1 of 2 branches missed.">		if (Tools.isEmpty(domainName)) domainName = &quot;&quot;;</span>

<span class="fc" id="L2947">		StringBuilder groupIds = new StringBuilder(&quot;-1&quot;);</span>
<span class="fc bfc" id="L2948" title="All 2 branches covered.">		for (GroupDetails grp : groups)</span>
		{
<span class="fc bfc" id="L2950" title="All 2 branches covered.">			if (domainName.equals(grp.getDomainName()))</span>
			{
<span class="fc" id="L2952">				groupIds.append(',').append(grp.getGroupId());</span>
			}
<span class="fc" id="L2954">		}</span>

<span class="pc bpc" id="L2956" title="1 of 2 branches missed.">		if (Tools.isEmpty(groupIds.toString())) return &quot;-1&quot;;</span>

<span class="fc" id="L2958">		return groupIds.toString();</span>
	}

	/**
	 * expanduje zadany zoznam skupin na podadresare (vratane rodica), neprejde cez interne adresare
	 * @param rootGroups
	 * @return
	 */
	public int[] expandGroupIdsToChilds(int[] rootGroups)
	{
<span class="fc" id="L2968">		return expandGroupIdsToChilds(rootGroups, false);</span>
	}

	/**
	 * expanduje zadany zoznam skupin na podadresare (vratane rodica)
	 * @param rootGroups
	 * @param includeInternal
	 * @return
	 */
	public int[] expandGroupIdsToChilds(int[] rootGroups, boolean includeInternal)
	{
<span class="pc bpc" id="L2979" title="1 of 4 branches missed.">		if (rootGroups == null || rootGroups.length==0) return new int[0];</span>

<span class="fc" id="L2981">		StringBuilder searchGroups = null;</span>
<span class="fc bfc" id="L2982" title="All 2 branches covered.">		for (int searchRootGroupId : rootGroups)</span>
		{
<span class="fc" id="L2984">			List&lt;GroupDetails&gt; searchGroupsArray = getGroupsTree(searchRootGroupId, true, true);</span>
<span class="fc bfc" id="L2985" title="All 2 branches covered.">			for (GroupDetails group : searchGroupsArray)</span>
			{
<span class="pc bpc" id="L2987" title="1 of 6 branches missed.">				if (group != null &amp;&amp; (includeInternal || group.isInternal()==false))</span>
				{
					//hladaj iba v grupach co nie su pass protected
<span class="fc bfc" id="L2990" title="All 2 branches covered.">					if (searchGroups == null)</span>
					{
<span class="fc" id="L2992">						searchGroups = new StringBuilder(String.valueOf(group.getGroupId()));</span>
					}
					else
					{
<span class="fc" id="L2996">						searchGroups.append(&quot;,&quot;).append(String.valueOf(group.getGroupId()));</span>
					}
				}
<span class="fc" id="L2999">			}</span>
		}

<span class="fc bfc" id="L3002" title="All 2 branches covered.">		if (searchGroups == null) return new int[0];</span>

<span class="fc" id="L3004">		return Tools.getTokensInt(searchGroups.toString(), &quot;,&quot;);</span>
	}

	/**
	 * Vypocita hodnotu sortPriority pre novy adresar v zadanom sub adresari
	 * @param parentGroupId
	 * @return
	 */
	public int getDefaultSortPriority(int parentGroupId)
	{
<span class="pc bpc" id="L3014" title="3 of 4 branches missed.">		if (parentGroupId &lt; 1 &amp;&amp; Constants.getBoolean(&quot;enableStaticFilesExternalDir&quot;))</span>
		{
			//pre multidomain s externymi vraciame pre root natvrdo 100 aby sa sortovali podla abecedy
<span class="nc" id="L3017">			return 100;</span>
		}

<span class="fc" id="L3020">		int maxSortOrder = 0;</span>
<span class="pc bpc" id="L3021" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;sortPriorityIncremental&quot;))</span>
		{
<span class="fc" id="L3023">			GroupDetails parentGroup = getGroup(parentGroupId);</span>
<span class="pc bpc" id="L3024" title="1 of 2 branches missed.">			if (parentGroup!=null)</span>
			{
<span class="fc" id="L3026">				maxSortOrder = (int)Math.ceil(parentGroup.getSortPriority()/10.0f) * 100;</span>
			}
		}

<span class="fc bfc" id="L3030" title="All 2 branches covered.">		for (GroupDetails grp : getGroups(parentGroupId))</span>
		{
<span class="fc bfc" id="L3032" title="All 2 branches covered.">			if (grp.getSortPriority() &gt; maxSortOrder) maxSortOrder = grp.getSortPriority();</span>
<span class="fc" id="L3033">		}</span>
<span class="fc" id="L3034">		return maxSortOrder + 10;</span>
	}

	/**
	 * Removes a group from current cache
	 *
	 * @param group group, which will be erased from cache
	 */
	private void removeGroupFromCache(GroupDetails group, boolean isUpdateProcess)
	{
		try
		{
<span class="fc" id="L3046">			synchronized(groups)</span>
			{
<span class="pc bpc" id="L3048" title="1 of 2 branches missed.">				if (groups.remove(group)==false)</span>
				{
<span class="nc" id="L3050">					int index = Collections.binarySearch(groups, group, groupsDbSorter);</span>
<span class="nc bnc" id="L3051" title="All 2 branches missed.">					if (index &gt; 0)</span>
<span class="nc" id="L3052">						groups.remove(index);</span>
					else
					{
						//zmenilo sa jej sort priority - nemozeme vyhladat binarne, musime sekvencne
<span class="nc" id="L3056">						group = getGroup(group.getGroupId());</span>
<span class="nc" id="L3057">						index = groups.indexOf(group);</span>
<span class="nc" id="L3058">						groups.remove(index);</span>
					}
				}
<span class="fc" id="L3061">			}</span>
<span class="fc" id="L3062">			getGroupDetailsMap().remove(group.getGroupId());</span>

			//zresetuj all tree cache
<span class="fc" id="L3065">			groupsTreeAllCache = null;</span>

<span class="fc" id="L3067">			idToGroups.remove(group.getGroupId());</span>

<span class="pc bpc" id="L3069" title="2 of 6 branches missed.">			if(Tools.isNotEmpty(group.getDomainName()) &amp;&amp; group.getParentGroupId() == 0 &amp;&amp; isUpdateProcess==false)</span>
			{
				//najdi najnizsie groupId v tejto domene (domainId je najnizsie groupId v domene)
<span class="nc" id="L3072">				int lowestGroupId = group.getGroupId();</span>
<span class="nc bnc" id="L3073" title="All 2 branches missed.">				for (GroupDetails domainGroup : groups) {</span>
<span class="nc bnc" id="L3074" title="All 4 branches missed.">					if (domainGroup.getParentGroupId()==0 &amp;&amp; group.getDomainName().equals(domainGroup.getDomainName())) {</span>
<span class="nc bnc" id="L3075" title="All 2 branches missed.">						if (domainGroup.getGroupId()&lt;lowestGroupId) lowestGroupId = domainGroup.getGroupId();</span>
					}
<span class="nc" id="L3077">				}</span>
				//ak mazana grupa je s najnizsim groupId, zmazme aj so zoznamu domen
<span class="nc bnc" id="L3079" title="All 2 branches missed.">				if (lowestGroupId==group.getGroupId()) {</span>
<span class="nc" id="L3080">					domainIds.remove(group.getDomainName());</span>
					//musime aj tak spravit reload, lebo hladame teraz nove domainId
<span class="nc" id="L3082">					GroupsDB.getInstance(true);</span>
				}
			}
		}
<span class="nc" id="L3086">		catch (ConcurrentModificationException|ArrayIndexOutOfBoundsException e)</span>
		{
			//nastala nam chyba, najrozumnejsie je spravit nacitanie novej instancie
<span class="nc" id="L3089">			GroupsDB.getInstance(true);</span>
<span class="fc" id="L3090">		}</span>
<span class="fc" id="L3091">	}</span>

	/**
	 * Inserts a group into cache, preserving GroupsDB sort invariant
	 *
	 * @param newGroup a group to be inserted
	 */
	private void insertGroupInCache(GroupDetails newGroup)
	{
		try
		{
<span class="fc" id="L3102">			synchronized(groups)</span>
			{
<span class="fc" id="L3104">				int index = Collections.binarySearch(groups, newGroup, groupsDbSorter);</span>
				//vlastnost binarySearch - ak neobsahuje takyto prvok, tak vrati zaporny index
				//toho, kde by sa mal nachadzat zmenseny o 1
<span class="pc bpc" id="L3107" title="1 of 2 branches missed.">				if (index &lt; 0)</span>
<span class="fc" id="L3108">					index = - index - 1;</span>

				//double check
<span class="pc bpc" id="L3111" title="1 of 2 branches missed.">				Optional&lt;GroupDetails&gt; existing = groups.stream().filter(g -&gt; g.getGroupId()==newGroup.getGroupId()).findFirst();</span>
<span class="pc bpc" id="L3112" title="1 of 2 branches missed.">				if (existing.isPresent()==false) {</span>
<span class="fc" id="L3113">					groups.add(index, newGroup);</span>
				}
<span class="fc" id="L3115">			}</span>
<span class="fc" id="L3116">			getGroupDetailsMap().put(newGroup.getGroupId(), newGroup);</span>

			//zresetuj all tree cache
<span class="fc" id="L3119">			groupsTreeAllCache = null;</span>

<span class="pc bpc" id="L3121" title="1 of 4 branches missed.">			if(Tools.isNotEmpty(newGroup.getDomainName()) &amp;&amp; newGroup.getParentGroupId() == 0)</span>
			{
<span class="pc bpc" id="L3123" title="1 of 2 branches missed.">			   if (domainIds.get(newGroup.getDomainName())==null) domainIds.put(newGroup.getDomainName(), newGroup.getGroupId());</span>
			}
<span class="fc" id="L3125">			idToGroups.put(newGroup.getGroupId(), newGroup);</span>

<span class="pc bpc" id="L3127" title="1 of 2 branches missed.">			if (Tools.isNotEmpty(newGroup.getDomainName()))</span>
			{
				//oznam DocDB ze mame taku domenu (vytvori hash tabulku pre danu domenu)
<span class="fc" id="L3130">				DocDB docDB = DocDB.getInstance();</span>
<span class="fc" id="L3131">				docDB.getUrlsByUrlDomains(newGroup.getDomainName(), true);</span>
			}
		}
<span class="nc" id="L3134">		catch (ConcurrentModificationException|ArrayIndexOutOfBoundsException ex)</span>
		{
			//nastala nam chyba, najrozumnejsie je spravit nacitanie novej instancie
<span class="nc" id="L3137">			GroupsDB.getInstance(true);</span>
<span class="fc" id="L3138">		}</span>
<span class="fc" id="L3139">	}</span>

	/**
	 * Replaces a group already existing in cache with a new one, preserving
	 * their natural sort.
	 * @param inCache old one
	 * @param notInCache new one
	 */
	private static void replaceGroupInCache(GroupDetails inCache,GroupDetails notInCache)
	{
<span class="fc" id="L3149">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L3150">		groupsDB.removeGroupFromCache(inCache, true);</span>
<span class="fc" id="L3151">		groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L3152">		groupsDB.insertGroupInCache(notInCache);</span>
<span class="fc" id="L3153">	}</span>

	private static Map&lt;Integer ,GroupDetails&gt; getGroupDetailsMap()
	{
<span class="fc" id="L3157">		return getInstance().idToGroups;</span>
	}


	/**
	 * Vrati korenove adresare
	 * @return
	 */
	public static List&lt;GroupDetails&gt; getRootGroups()
	{
<span class="fc" id="L3167">		return new ComplexQuery().setSql(&quot;SELECT * FROM groups WHERE parent_group_id &lt;= 0 ORDER BY sort_priority ASC, group_name ASC&quot;).list(new Mapper&lt;GroupDetails&gt;()</span>
<span class="fc" id="L3168">		{</span>
			public GroupDetails map(ResultSet rs) throws SQLException
			{
<span class="fc" id="L3171">				return fillFieldsByResultSet(rs);</span>
			}

		});
	}

	public void resetGroupsTreeAllCache()
	{
<span class="nc" id="L3179">		groupsTreeAllCache = null;</span>
<span class="nc" id="L3180">	}</span>

	/**
	 * Otestuje, ci zadany adresar je pouzivatelom nastaveny ako editovatelny (user.getEditableGroups)
	 * @param user
	 * @param groupId
	 * @return
	 */
	public static boolean isGroupEditable(UserDetails user, int groupId)
	{
<span class="fc bfc" id="L3190" title="All 2 branches covered.">		if (groupId &lt; 1) return true;</span>

<span class="pc bpc" id="L3192" title="1 of 2 branches missed.">		if (user == null) return false;</span>
<span class="pc bpc" id="L3193" title="1 of 4 branches missed.">		if (user.getEditableGroups() != null &amp;&amp; user.getEditableGroups().length() &gt; 0)</span>
		{
<span class="fc" id="L3195">			GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L3196">			String parentGroups = &quot;,&quot; + groupId + &quot;,&quot; + groupsDB.getParents(groupId)+&quot;,&quot;;</span>
<span class="fc" id="L3197">			StringTokenizer st = new StringTokenizer(user.getEditableGroups(), &quot;,&quot;);</span>
			String id;
			int i_id;
<span class="fc bfc" id="L3200" title="All 2 branches covered.">			while (st.hasMoreTokens())</span>
			{
<span class="fc" id="L3202">				id = st.nextToken().trim();</span>
				try
				{
<span class="fc" id="L3205">					i_id = Integer.parseInt(id);</span>
<span class="fc bfc" id="L3206" title="All 2 branches covered.">					if (parentGroups.indexOf(&quot;,&quot; + i_id + &quot;,&quot;) != -1)</span>
					{
<span class="fc" id="L3208">						return true;</span>
					}
				}
<span class="nc" id="L3211">				catch (Exception ex)</span>
				{

<span class="pc" id="L3214">				}</span>
			}
<span class="fc" id="L3216">		}</span>
		else
		{
<span class="fc" id="L3219">			return true;</span>
		}
<span class="fc" id="L3221">		return false;</span>
	}

	/**
	 * Testuje, ci moze user vidiet adresar, pouziva sa na overenie ked ma editaciu az niekde
	 * do poadresara, ale v FE potrebujeme zobrazit aj parentov v stromovej strukture
	 * @param user
	 * @param groupId
	 * @return
	 */
    public static boolean isGroupViewable(UserDetails user, int groupId) {
<span class="fc bfc" id="L3232" title="All 2 branches covered.">        if (groupId &lt; 1) return true;</span>

<span class="pc bpc" id="L3234" title="1 of 2 branches missed.">        if (user == null) return false;</span>

<span class="pc bpc" id="L3236" title="1 of 4 branches missed.">        if (user.getEditableGroups() == null || user.getEditableGroups().isEmpty()) {</span>
<span class="fc" id="L3237">            return true;</span>
        }

<span class="fc" id="L3240">        List&lt;GroupDetails&gt; editableGroups = getGroupsList(user.getEditableGroups());</span>
<span class="fc" id="L3241">        GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc bfc" id="L3242" title="All 2 branches covered.">        for (GroupDetails editableGroup : editableGroups) {</span>
<span class="fc" id="L3243">            List&lt;GroupDetails&gt; parents = groupsDB.getParentGroups(editableGroup.getGroupId(), true);</span>
<span class="fc bfc" id="L3244" title="All 4 branches covered.">            if (parents.stream().anyMatch(groupDetails -&gt; groupDetails.getGroupId() == groupId)) {</span>
<span class="fc" id="L3245">                return true;</span>
            }
<span class="fc" id="L3247">        }</span>

        //over aj zoznam pridelenych stranok
<span class="fc bfc" id="L3250" title="All 2 branches covered.">        if (Tools.isNotEmpty(user.getEditablePages())) {</span>
<span class="fc" id="L3251">            List&lt;DocDetails&gt; docs = UserTools.getEditablePages(user.getEditablePages());</span>
<span class="fc bfc" id="L3252" title="All 2 branches covered.">            for (DocDetails doc : docs) {</span>
<span class="fc" id="L3253">                List&lt;GroupDetails&gt; parents = groupsDB.getParentGroups(doc.getGroupId());</span>
<span class="fc" id="L3254">                parents.add(doc.getGroup());</span>
<span class="fc bfc" id="L3255" title="All 4 branches covered.">                if (parents.stream().anyMatch(groupDetails -&gt; groupDetails.getGroupId() == groupId)) {</span>
<span class="fc" id="L3256">                    return true;</span>
                }
<span class="fc" id="L3258">            }</span>
        }

<span class="fc" id="L3261">        return false;</span>
    }

    /**
     * Vrati list GroupDetails na zaklade ciarkou oddeleneho zoznamu ID adresarov
     * @param tokens - ciarkou oddeleny zoznam adresarov (z UserDetails.editableGroups)
     * @return
     */
    public static List&lt;GroupDetails&gt; getGroupsList(String tokens) {
<span class="fc" id="L3270">        List&lt;GroupDetails&gt; result = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L3272" title="1 of 2 branches missed.">        if (Tools.isEmpty(tokens)) {</span>
<span class="nc" id="L3273">            return Collections.emptyList();</span>
        }

<span class="fc" id="L3276">        String[] ids = Tools.getTokens(tokens, &quot;,&quot;);</span>

<span class="pc bpc" id="L3278" title="1 of 2 branches missed.">        if (ids.length == 0) {</span>
<span class="nc" id="L3279">            return Collections.emptyList();</span>
        }

<span class="fc" id="L3282">        GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="fc bfc" id="L3283" title="All 2 branches covered.">        for (String id : ids) {</span>
<span class="fc" id="L3284">        	int intId = Tools.getIntValue(id, 0);</span>
<span class="fc" id="L3285">            GroupDetails group = groupsDB.getGroup(intId);</span>
<span class="fc bfc" id="L3286" title="All 2 branches covered.">            if (group != null) {</span>
<span class="fc" id="L3287">                result.add(group);</span>
            }
        }

<span class="fc" id="L3291">        return result;</span>
    }

	/**
	 * Zrusi z nazvu adresara nepovolene znaky
	 * @param groupName
	 * @return
	 */
	public static String sanitizeGroupName(String groupName, boolean alsoSlash)
	{
<span class="fc bfc" id="L3301" title="All 2 branches covered.">		if (isEmpty(groupName))</span>
<span class="fc" id="L3302">			return &quot;&quot;;</span>
		//znak / nemozeme nahradzat priamo v GroupDetails.setGroupName(), pretoze pre userov s obmedzenymi pravami sa potom zle zobrazoval adresar (lebo sa mu do nazvu klonuje cela cesta, napr. /Interway/Novinky/
<span class="fc bfc" id="L3304" title="All 2 branches covered.">		if (alsoSlash)</span>
		{
<span class="fc" id="L3306">			groupName = Tools.replace(Tools.replace(groupName, &quot;\\&quot;, &quot;-&quot;), &quot;/&quot;, &quot;-&quot;);</span>
		}

<span class="fc" id="L3309">		return groupName.replace(&quot;/\n/gi&quot;, &quot; &quot;).replaceAll(&quot;/\\s+/gi&quot;, &quot; &quot;).replace('\\', '/').trim();</span>
	}

	/**
	 * Vrati  id root adresara danej domeny
	 * @param domain meno domeny
	 * @return
	 */
	public static int getDomainId(String domain)
	{
<span class="fc" id="L3319">		Integer id = getInstance().domainIds.get(domain);</span>
<span class="pc bpc" id="L3320" title="1 of 2 branches missed.">		if(id == null) id = -1;</span>
<span class="fc" id="L3321">		return id;</span>
	}

	/**
	 * Vrati adresar System ktory je v root adresari aktualnej domeny, teda napr. /www.interway.sk/System/
	 * @return
	 */
	public GroupDetails getLocalSystemGroup()
	{
		//TODO: doplnit nejake cachovania hladania ID daneho adresara, aby sme ho mohli potom vratit okamzite z cache / hash tabulky

<span class="fc" id="L3332">		String groupName = &quot;System&quot;;</span>
<span class="fc" id="L3333">		RequestBean rb = SetCharacterEncodingFilter.getCurrentRequestBean();</span>
<span class="pc bpc" id="L3334" title="1 of 2 branches missed.">		if (rb == null)</span>
		{
<span class="nc" id="L3336">			return null;</span>
		}

<span class="fc" id="L3339">		String domain = rb.getDomain();</span>
<span class="pc bpc" id="L3340" title="1 of 2 branches missed.">		if (Tools.isEmpty(domain)) return null;</span>
<span class="fc" id="L3341">		int rootGroupId = GroupsDB.getDomainId(domain);</span>
<span class="pc bpc" id="L3342" title="1 of 2 branches missed.">		if (rootGroupId &lt; 1) return null;</span>

<span class="pc bpc" id="L3344" title="1 of 2 branches missed.">		for (GroupDetails group : groups)</span>
		{
<span class="fc bfc" id="L3346" title="All 4 branches covered.">			if (group.getParentGroupId()==rootGroupId &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()))</span>
			{
				//vratime adresar, System v hlavnom priecinku domeny (stary system)
<span class="fc" id="L3349">				return (group);</span>
			}
<span class="fc bfc" id="L3351" title="All 6 branches covered.">			else if (group.getParentGroupId()&lt;1 &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()) &amp;&amp; domain.equalsIgnoreCase(group.getDomainName()))</span>
			{
				//ak sa jedna o ROOT priecinok System v aktualnej domene, vrat ten (WJ9 rezim)
<span class="fc" id="L3354">				return group;</span>
			}
<span class="fc" id="L3356">		}</span>

<span class="nc" id="L3358">		return (null);</span>
	}

	/**
	 * Vrati ID adresara System ktory je v root adresari aktualnej domeny, teda napr. /www.interway.sk/System/
	 * @return
	 */
	public int getLocalSystemGroupId()
	{
<span class="fc" id="L3367">		GroupDetails localSystem = getLocalSystemGroup();</span>
<span class="pc bpc" id="L3368" title="1 of 2 branches missed.">		if (localSystem != null) return localSystem.getGroupId();</span>

<span class="nc" id="L3370">		return -1;</span>
	}

	/**
	 * Vytvori novy root adresar a nastavi mu domenu
	 * ak uz domena existuje, vrati -1
	 * @param localDomainName
	 * @return
	 */
	public int createLocalDomain(String localDomainName)
	{
<span class="nc bnc" id="L3381" title="All 2 branches missed.">		if (Tools.isEmpty(localDomainName)) return -1;</span>

<span class="nc" id="L3383">		localDomainName = localDomainName.toLowerCase();</span>

<span class="nc bnc" id="L3385" title="All 2 branches missed.">		if(GroupsDB.getInstance().domainIds.containsKey(localDomainName))</span>
		{
<span class="nc" id="L3387">			Logger.debug(getClass(), &quot;Domain already exists: &quot; + localDomainName);</span>
<span class="nc" id="L3388">			return -1;</span>
		}
<span class="nc" id="L3390">		Logger.debug(getClass(), &quot;Creating domain root folder for domain: &quot; + localDomainName);</span>
<span class="nc" id="L3391">		int actualParent = 0;</span>
		String actualGroupName;
		GroupDetails actualGroup;
<span class="nc" id="L3394">		actualGroupName = localDomainName;</span>
<span class="nc" id="L3395">		actualGroup = getGroup(actualGroupName, actualParent);</span>
<span class="nc bnc" id="L3396" title="All 2 branches missed.">		if (actualGroup == null)</span>
		{
<span class="nc" id="L3398">			actualGroup = new GroupDetails();</span>
<span class="nc" id="L3399">			actualGroup.setParentGroupId(0);</span>
<span class="nc" id="L3400">			actualGroup.setGroupId(-1);</span>
<span class="nc" id="L3401">			actualGroup.setDefaultDocId(-1);</span>
<span class="nc" id="L3402">			actualGroup.setGroupName(actualGroupName);</span>
<span class="nc" id="L3403">			actualGroup.setNavbar(actualGroupName);</span>
<span class="nc" id="L3404">			actualGroup.setUrlDirName(&quot;/&quot;);</span>
<span class="nc" id="L3405">			actualGroup.setSortPriority(getDefaultSortPriority(actualGroup.getParentGroupId()));</span>
<span class="nc" id="L3406">			actualGroup.setDomainName(localDomainName);</span>
<span class="nc" id="L3407">			setGroup(actualGroup);</span>
<span class="nc" id="L3408">			Logger.debug(getClass(), &quot;Domain root folder for domain: &quot; + localDomainName + &quot; created, id: &quot; + actualGroup.getGroupId());</span>
		}
		else
		{
<span class="nc" id="L3412">			Logger.debug(getClass(), &quot;Domain root folder for domain: &quot; + localDomainName + &quot; already exists, id: &quot; + actualGroup.getGroupId());</span>
		}
<span class="nc" id="L3414">		return actualGroup.getGroupId();</span>
	}

	/**
	 * Zmeni nazov hlavnej stranky groupy podla nazvu grupy, v ktorej sa stranka nachadza
	 * @param gd - ID grupy ktorej ktorej GroupName sa nastavi ako Title pre document.
	 * 				Ak je null, nic sa nevykona.
	 */
	private boolean changeDocTitle(GroupDetails gd)
	{
<span class="pc bpc" id="L3424" title="3 of 12 branches missed.">		if(gd != null &amp;&amp; gd.isInternal()==false &amp;&amp; gd.getMenuType()!=GroupDetails.MENU_TYPE_HIDDEN &amp;&amp; gd.getFullPath()!=null &amp;&amp; gd.getFullPath().indexOf(&quot;/System&quot;)==-1 &amp;&amp; gd.getParentGroupId()&gt;0)</span>
		{
<span class="fc" id="L3426">			DocDetails docDetails = DocDB.getInstance().getDoc(gd.getDefaultDocId());</span>
<span class="pc bpc" id="L3427" title="3 of 6 branches missed.">			if(docDetails != null &amp;&amp; (docDetails.getTitle() != null &amp;&amp; !gd.getGroupName().equals(docDetails.getTitle())))</span>
			{
<span class="nc" id="L3429">				Logger.debug(DocDB.class, &quot;Renaming document: &quot;+docDetails.getDocId()+&quot; to name :&quot;+gd.getGroupName());</span>
<span class="nc" id="L3430">				docDetails.setTitle(gd.getGroupName());</span>
<span class="nc" id="L3431">				docDetails.setNavbar(gd.getGroupName());</span>
<span class="nc" id="L3432">				DocDB.saveDoc(docDetails);</span>
<span class="nc" id="L3433">				return true;</span>
			}
<span class="fc" id="L3435">			return false;</span>
		}
		else
		{
<span class="fc" id="L3439">			return false;</span>
		}
	}

	/**
	 * Zmeni domenu pre adresar aj podadresare (pouzitie v cloud nodoch - zmena domeny
	 *
	 * @param oldDomain povodna domena
	 * @param newDomain nova domena
	 * @return
	 */
	public static boolean changeDomain(String oldDomain, String newDomain)
	{
<span class="nc" id="L3452">		GroupsDB groupsDb = GroupsDB.getInstance();</span>
<span class="nc" id="L3453">		DocDB docDb = DocDB.getInstance();</span>
<span class="nc" id="L3454">		GroupDetails group = groupsDb.getGroup(oldDomain, 0);</span>
<span class="nc" id="L3455">		StringBuilder messageToAdminlog = new StringBuilder();</span>
<span class="nc" id="L3456">		messageToAdminlog.append(&quot;Pozadovana zmena domeny OLD: '&quot;).append(oldDomain).append(&quot;', NEW: '&quot;).append(newDomain).append(&quot;' \n&quot;);</span>
<span class="nc" id="L3457">	 	String groupIds = GroupsDB.getInstance().getSubgroupsIds(group.getGroupId());</span>
<span class="nc" id="L3458">	 	messageToAdminlog.append(&quot;Zoznam ID adresarov: &quot;).append(groupIds).append(&quot;\n&quot;);</span>
<span class="nc" id="L3459">	 	int[] ids = Tools.getTokensInt(groupIds, &quot;,&quot;);</span>
<span class="nc" id="L3460">	 	List&lt;DocDetails&gt; oldDocs = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L3462" title="All 2 branches missed.">		for (int i=0;i&lt;ids.length;i++)</span>
		{
<span class="nc" id="L3464">			List&lt;DocDetails&gt; docsInGroup = docDb.getBasicDocDetailsByGroup(ids[i], DocDB.ORDER_PRIORITY);</span>
<span class="nc bnc" id="L3465" title="All 4 branches missed.">			if (docsInGroup!=null &amp;&amp; docsInGroup.size()&gt;0)</span>
<span class="nc" id="L3466">				oldDocs.addAll(docsInGroup);</span>
		}
<span class="nc bnc" id="L3468" title="All 2 branches missed.">		for (DocDetails doc : oldDocs)</span>
		{
<span class="nc" id="L3470">			messageToAdminlog.append(&quot;Zmena domeny pre Doc (docId) &quot;).append(doc.getDocId()).append(&quot; :&quot;);</span>
<span class="nc bnc" id="L3471" title="All 4 branches missed.">			if (doc.getFieldT()!=null &amp;&amp; doc.getFieldT().equals(oldDomain))</span>
			{
<span class="nc" id="L3473">				messageToAdminlog.append(&quot;-povolena\n&quot;);</span>
<span class="nc" id="L3474">				doc.setFieldT(newDomain);</span>
			} else
			{
<span class="nc" id="L3477">				messageToAdminlog.append(&quot;-zamietnuta\n&quot;);</span>
			}
<span class="nc" id="L3479">		}</span>

<span class="nc" id="L3481">		Adminlog.add(Adminlog.TYPE_CLIENT_SPECIFIC, messageToAdminlog.toString(), 0, 0);</span>
<span class="nc" id="L3482">		SimpleQuery sq = new SimpleQuery();</span>
<span class="nc" id="L3483">	  	sq.execute(&quot;UPDATE groups SET domain_name=? WHERE group_id IN (&quot;+groupIds+&quot;)&quot;, newDomain);</span>
<span class="nc" id="L3484">	  	sq.execute(&quot;UPDATE groups SET group_name=?, navbar=? WHERE group_id=?&quot;, newDomain, newDomain, group.getGroupId());</span>
<span class="nc" id="L3485">	  	sq.execute(&quot;UPDATE url_redirect SET domain_name=? WHERE domain_name=?&quot;, newDomain, oldDomain);</span>

	  	//premenovanie liniek
<span class="nc" id="L3488">	  	sq.execute(&quot;UPDATE documents SET external_link=REPLACE(external_link, ?, ?) WHERE group_id IN (&quot;+groupIds+&quot;)&quot;, &quot;http://&quot;+oldDomain, &quot;http://&quot;+newDomain);</span>
<span class="nc" id="L3489">	  	sq.execute(&quot;UPDATE documents SET data=REPLACE(data, ?, ?) WHERE group_id IN (&quot;+groupIds+&quot;)&quot;, &quot;http://&quot;+oldDomain, &quot;http://&quot;+newDomain);</span>

<span class="nc" id="L3491">	  	Adminlog.add(Adminlog.TYPE_CLIENT_SPECIFIC, &quot;Changed domain for cloud web, old domain: '&quot;+oldDomain+&quot;', new domain: '&quot;+newDomain+&quot;'&quot;, 0, 0);</span>

<span class="nc" id="L3493">	  	docDb.changeUrlInUrlmap(oldDomain, newDomain);</span>

<span class="nc" id="L3495">	  	IwcmFile oldDir = new IwcmFile(FilePathTools.getDomainBaseFolder(oldDomain));</span>
<span class="nc" id="L3496">	  	IwcmFile newDir = new IwcmFile(FilePathTools.getDomainBaseFolder(newDomain));</span>
<span class="nc" id="L3497">	  	newDir.mkdirs();</span>

	  	//toto asi nezbehne, kedze je to v roznych adresaroch, bude potrebne spravit move
	  	//oldDir.renameTo(newDir);
	  	try
		{
<span class="nc" id="L3503">	  		FileTools.copyDirectory(oldDir, newDir);</span>
<span class="nc" id="L3504">	  		Adminlog.add(Adminlog.TYPE_CLIENT_SPECIFIC, &quot;Changed domain, old domain: '&quot;+oldDomain+&quot;', new domain: '&quot;+newDomain+&quot;', files from &quot;+oldDir.getAbsolutePath()+&quot; to &quot;+newDir.getAbsolutePath(), 0, 0);</span>

<span class="nc" id="L3506">	  		FileTools.deleteDirTree(oldDir);</span>
		}
<span class="nc" id="L3508">		catch (Exception e)</span>
		{
<span class="nc" id="L3510">			sk.iway.iwcm.Logger.error(e);</span>
<span class="nc" id="L3511">		}</span>

	  	//reloadneme singletona aby sa nam prejavili vsetky zmeny
<span class="nc" id="L3514">	  	GroupsDB.getInstance(true);</span>
	  	//toto by asi ani nebolo treba, ale pre istotu pridavam
<span class="nc" id="L3516">	  	DocDB.getInstance(true);</span>

<span class="nc" id="L3518">	  	return true;</span>
	}

	/**
	 * Vrati zoznam hlavnych adresarov pre prava pouzivatela
	 * @param editableGroups
	 * @return
	 */
	public List&lt;GroupDetails&gt; getRootGroups(String editableGroups)
	{
<span class="fc" id="L3528">		List&lt;GroupDetails&gt; rootGroups = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L3530" title="All 2 branches covered.">		if (Tools.isNotEmpty(editableGroups))</span>
		{
<span class="fc" id="L3532">			StringTokenizer st = new StringTokenizer(editableGroups, &quot;,&quot;);</span>
			String id;
			int i_id;
<span class="fc bfc" id="L3535" title="All 2 branches covered.">			while (st.hasMoreTokens())</span>
			{
<span class="fc" id="L3537">				id = st.nextToken().trim();</span>
				try
				{
<span class="fc" id="L3540">					i_id = Integer.parseInt(id);</span>
					//pridaj to do stromu editovatelnych stranok
<span class="fc" id="L3542">					GroupDetails parentGroup = findGroup(i_id);</span>
<span class="fc" id="L3543">					GroupDetails parentGroupCopy = new GroupDetails(parentGroup);</span>
<span class="fc" id="L3544">					parentGroupCopy.setParentGroupId(0);</span>
<span class="pc bpc" id="L3545" title="1 of 2 branches missed.">					if (parentGroup.getFullPath().length() &gt; 200)</span>
					{
<span class="nc" id="L3547">						parentGroupCopy.setGroupName(&quot;...&quot;+parentGroup.getFullPath().substring(parentGroup.getFullPath().length()-198));</span>
					}
					else
					{
<span class="fc" id="L3551">						parentGroupCopy.setGroupName(parentGroup.getFullPath());</span>
					}

<span class="fc" id="L3554">					String userEditableTreeMenuType = Constants.getString(&quot;userEditableTreeMenuType&quot;, &quot;rows&quot;);</span>
<span class="pc bpc" id="L3555" title="1 of 2 branches missed.">					if (&quot;tree&quot;.equalsIgnoreCase(userEditableTreeMenuType)) {</span>

<span class="nc" id="L3557">						GroupDetails root = getGroup(getRoot(parentGroup.getGroupId()));</span>

<span class="nc bnc" id="L3559" title="All 4 branches missed.">						if (rootGroups.stream().noneMatch(r-&gt;r.getGroupId() == root.getGroupId())) {</span>
<span class="nc" id="L3560">							rootGroups.add(root);</span>
						}
<span class="nc" id="L3562">					}</span>
					else {
<span class="pc bpc" id="L3564" title="2 of 4 branches missed.">						if (rootGroups.stream().noneMatch(r-&gt;r.getGroupId() == parentGroupCopy.getGroupId())) {</span>
<span class="fc" id="L3565">							rootGroups.add(parentGroupCopy);</span>
						}
					}
				}
<span class="fc" id="L3569">				catch (Exception ex)</span>
				{

<span class="fc" id="L3572">				}</span>
			}
<span class="fc" id="L3574">		}</span>
		else
		{
<span class="fc" id="L3577">			rootGroups.addAll(getRootGroups());</span>
		}

<span class="fc" id="L3580">		return (rootGroups);</span>
	}

	/**
	 * vrati zoznam nazvov root domen pre ktore ma pouzivatel pravo
	 * @param editableGroups
	 * @return
	 */
	public List&lt;String&gt; getUserRootDomainNames(String editableGroups)
	{
<span class="fc" id="L3590">		List&lt;String&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L3591" title="All 2 branches covered.">		for(GroupDetails gd : getRootGroups(editableGroups))</span>
		{
<span class="fc bfc" id="L3593" title="All 4 branches covered.">			if(Tools.isNotEmpty(gd.getDomainName()) &amp;&amp; ret.contains(gd.getDomainName()) == false)</span>
<span class="fc" id="L3594">				ret.add(gd.getDomainName());</span>
<span class="fc" id="L3595">		}</span>

<span class="fc" id="L3597">		return ret;</span>
	}

	/**
	 * Otestuje ci ma adresar akehokolvek potomka - podadresar alebo web stranku
	 * @param groupId
	 * @return
	 */
	public boolean hasAnyChild(int groupId)
	{
<span class="nc" id="L3607">		return hasAnyChild(groupId, true);</span>
	}

	/**
	 * Otestuje, ci ma podadresar potomka
	 * @param groupId
	 * @param includePages - ak je true, testuju sa aj web stranky
	 * @return
	 */
	public boolean hasAnyChild(int groupId, boolean includePages)
	{
<span class="fc bfc" id="L3618" title="All 2 branches covered.">		for (GroupDetails group : groups)</span>
		{
<span class="fc bfc" id="L3620" title="All 2 branches covered.">			if (group.getParentGroupId() == groupId)</span>
			{
<span class="fc" id="L3622">				return true;</span>
			}
<span class="fc" id="L3624">		}</span>

<span class="fc bfc" id="L3626" title="All 2 branches covered.">		if (includePages)</span>
		{
<span class="fc" id="L3628">			List&lt;DocDetails&gt; docs = DocDB.getInstance().getBasicDocDetailsByGroup(groupId, -1);</span>
<span class="pc bpc" id="L3629" title="1 of 4 branches missed.">			if (docs != null &amp;&amp; docs.size() &gt; 0) return true;</span>
		}

<span class="fc" id="L3632">		return false;</span>
	}

	public GroupDetails addNewRootGroup(String newGroupName)
	{
<span class="nc" id="L3637">		GroupDetails ctxGroup = getNewGroupDetails(newGroupName, 0);</span>
<span class="nc" id="L3638">		GroupsDB.getInstance().setGroup(ctxGroup);</span>

<span class="nc" id="L3640">		return ctxGroup;</span>
	}

	/**
	 * Vytvori novy adresar so zadanym menom v danom parent adresari
	 * @param newGroupName
	 * @param parentGroupId
	 * @return
	 */
	public GroupDetails addNewGroup(String newGroupName, int parentGroupId)
	{
<span class="nc" id="L3651">		GroupDetails ctxGroup = getNewGroupDetails(newGroupName, parentGroupId);</span>
<span class="nc" id="L3652">		GroupsDB.getInstance().setGroup(ctxGroup);</span>

<span class="nc" id="L3654">		return ctxGroup;</span>
	}

	/**
	 * Pripravi groupDetails objekt pre ulozenie do zadaneho parenta
	 * Nastavi potrebne (dedene) atributy a objekty
	 */
	public GroupDetails getNewGroupDetails(String newGroupName, int parentGroupId) {
		GroupDetails parentGroup;
<span class="pc bpc" id="L3663" title="1 of 2 branches missed.">		if (parentGroupId&gt;0) parentGroup = getGroup(parentGroupId);</span>
<span class="nc" id="L3664">		else parentGroup = getGroup(Constants.getInt(&quot;rootGroupId&quot;));</span>

<span class="fc" id="L3666">		GroupDetails ctxGroup = null;</span>
		try
		{
<span class="fc" id="L3669">			ctxGroup = (GroupDetails)parentGroup.clone();</span>
<span class="fc" id="L3670">			ctxGroup.setParentGroupId(parentGroupId);</span>
<span class="fc" id="L3671">			ctxGroup.setDefaultDocId(-1);</span>
<span class="fc" id="L3672">			ctxGroup.setNewPageDocIdTemplate(-1);</span>
<span class="fc" id="L3673">			ctxGroup.setHtmlHead(&quot;&quot;);</span>
<span class="fc" id="L3674">			ctxGroup.setGroupName(newGroupName);</span>
<span class="fc" id="L3675">			ctxGroup.setNavbar(newGroupName);</span>
<span class="fc" id="L3676">			ctxGroup.setUrlDirName(newGroupName);</span>
<span class="fc" id="L3677">			ctxGroup.setUrlDirName(ctxGroup.getUrlDirName());</span>

<span class="fc" id="L3679">			ctxGroup.setSortPriority(GroupsDB.getInstance().getDefaultSortPriority(parentGroupId));</span>

<span class="pc bpc" id="L3681" title="1 of 2 branches missed.">			if (parentGroupId == 0) {</span>
				//pre root foldre toto dava zmysel
<span class="nc" id="L3683">				ctxGroup.setInternal(false);</span>
<span class="nc" id="L3684">				ctxGroup.setMenuType(GroupDetails.MENU_TYPE_ONLYDEFAULT);</span>
			}

<span class="fc" id="L3687">			ctxGroup.setLogonPageDocId(-1);</span>

<span class="fc" id="L3689">			ctxGroup.setGroupId(-1);</span>
<span class="fc" id="L3690">			ctxGroup.setSyncId(0);</span>
<span class="fc" id="L3691">			ctxGroup.setSyncStatus(0);</span>

			//ticket 11208
<span class="pc bpc" id="L3694" title="2 of 4 branches missed.">			if(Tools.isNotEmpty(ctxGroup.getDomainName()) &amp;&amp; ctxGroup.getParentGroupId() &lt; 1)</span>
			{
<span class="nc" id="L3696">				ctxGroup.setDomainName(&quot;www.&quot;+ctxGroup.getUrlDirName()+&quot;.sk&quot;);</span>
			}

<span class="pc bpc" id="L3699" title="1 of 2 branches missed.">			if (parentGroupId&gt;0) {</span>
				//zaskis - neklonujme field_a az field_d pretoze to je nezmysel (mame tam info pre root a daju sa ziskat rekurzivne)
<span class="fc" id="L3701">				ctxGroup.setFieldA(&quot;&quot;);</span>
<span class="fc" id="L3702">				ctxGroup.setFieldB(&quot;&quot;);</span>
<span class="fc" id="L3703">				ctxGroup.setFieldC(&quot;&quot;);</span>
<span class="fc" id="L3704">				ctxGroup.setFieldD(&quot;&quot;);</span>
			}
		}
<span class="nc" id="L3707">		catch (CloneNotSupportedException e)</span>
		{
<span class="nc" id="L3709">			sk.iway.iwcm.Logger.error(e);</span>
<span class="fc" id="L3710">		}</span>

<span class="fc" id="L3712">		return ctxGroup;</span>
	}

	/**
	 * ziskanie vsetkych System adresarov
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public List&lt;GroupDetails&gt; getAllSystemFolders(boolean forceRefresh)
	{
<span class="pc bpc" id="L3722" title="1 of 2 branches missed.">		if(Constants.getBoolean(&quot;templatesUseRecursiveSystemFolder&quot;) == false) return null;</span>

<span class="nc" id="L3724">		String groupName = &quot;System&quot;;</span>
<span class="nc" id="L3725">		String cacheName = &quot;sk.iway.iwcm.doc.groupsdb.all-system-folders&quot;;</span>
<span class="nc" id="L3726">		int cacheInMinutes = Constants.getInt(&quot;allSystemFoldersCacheMinutes&quot;);</span>

<span class="nc" id="L3728">		Cache c = Cache.getInstance();</span>
<span class="nc bnc" id="L3729" title="All 2 branches missed.">		if(forceRefresh == false)</span>
		{
<span class="nc" id="L3731">			Object o = c.getObject(cacheName);</span>
<span class="nc bnc" id="L3732" title="All 2 branches missed.">			if (o instanceof List&lt;?&gt;)</span>
			{
<span class="nc" id="L3734">				Logger.debug(GroupsDB.class, &quot;citam vsetky system adresare z cache (forceRefresh=&quot;+forceRefresh+&quot;; cacheInMinutes=&quot;+cacheInMinutes+&quot;)&quot;);</span>
<span class="nc" id="L3735">				return (List&lt;GroupDetails&gt;)o;</span>
			}
		}

<span class="nc" id="L3739">		List&lt;GroupDetails&gt; systemFolders = null;</span>
<span class="nc bnc" id="L3740" title="All 2 branches missed.">		if(groups != null)</span>
		{
<span class="nc bnc" id="L3742" title="All 2 branches missed.">			for (GroupDetails group : groups)</span>
			{
<span class="nc bnc" id="L3744" title="All 4 branches missed.">				if (group.isInternal() &amp;&amp; groupName.equalsIgnoreCase(group.getGroupName()))</span>
				{
<span class="nc bnc" id="L3746" title="All 2 branches missed.">					if(systemFolders == null) systemFolders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3747">					systemFolders.add(group);</span>
				}
<span class="nc" id="L3749">			}</span>
		}

<span class="nc" id="L3752">		Logger.debug(GroupsDB.class, &quot;pisem vsetky system adresare do cache (forceRefresh=&quot;+forceRefresh+&quot;; cacheInMinutes=&quot;+cacheInMinutes+&quot;)&quot;);</span>
<span class="nc bnc" id="L3753" title="All 2 branches missed.">		if(cacheInMinutes &gt; 0) c.setObjectSeconds(cacheName, systemFolders, cacheInMinutes*60, true);</span>

<span class="nc" id="L3755">		return systemFolders;</span>
	}

	/**
	 * Vrati prvy vyskyt adresara System od root adresara az po aktualny adresar groupId
	 * @return
	 */
	public GroupDetails getSystemGroupRecursive(int groupId)
	{
<span class="nc" id="L3764">		List&lt;GroupDetails&gt; pathListGroups = getPathList(groupId);</span>
<span class="nc bnc" id="L3765" title="All 2 branches missed.">		if(pathListGroups != null)</span>
		{
<span class="nc" id="L3767">			List&lt;GroupDetails&gt; getAllSystemFolders = getAllSystemFolders(false);</span>
<span class="nc bnc" id="L3768" title="All 2 branches missed.">			if(getAllSystemFolders != null)</span>
			{
<span class="nc bnc" id="L3770" title="All 2 branches missed.">				for (GroupDetails plGroup : pathListGroups)</span>
				{
<span class="nc bnc" id="L3772" title="All 2 branches missed.">					for (GroupDetails group : getAllSystemFolders)</span>
					{
<span class="nc bnc" id="L3774" title="All 2 branches missed.">						if (group.getParentGroupId() == plGroup.getGroupId())</span>
						{
<span class="nc" id="L3776">							return group;</span>
						}
<span class="nc" id="L3778">					}</span>
<span class="nc" id="L3779">				}</span>
			}
		}

<span class="nc" id="L3783">		return (null);</span>
	}

	/**
	 * Vrati list vsetkych domen
	 * @return
	 */
	public List&lt;String&gt; getAllDomainsList(){
<span class="fc" id="L3791">		HashSet&lt;String&gt; domainsSet=new HashSet&lt;&gt;();</span>

<span class="fc" id="L3793">		List&lt;GroupDetails&gt; allGroups = getGroupsAll();</span>
<span class="fc bfc" id="L3794" title="All 2 branches covered.">		for(GroupDetails g: allGroups){</span>
<span class="fc bfc" id="L3795" title="All 4 branches covered.">				if(g.getParentGroupId() == 0 &amp;&amp; !g.getDomainName().isEmpty()){</span>
<span class="fc" id="L3796">					domainsSet.add(g.getDomainName());</span>
				}
<span class="fc" id="L3798">		}</span>

<span class="fc" id="L3800">		return new ArrayList&lt;&gt;(domainsSet);</span>
	}

    /**
     * Nastav jazyk na podadresare
     *
     * @param parentGroupId
     * @param language
     */
    public void setLngToSubGroups(int parentGroupId, String language) {

<span class="fc" id="L3811">        Connection db_conn = null;</span>
<span class="fc" id="L3812">        PreparedStatement ps = null;</span>
<span class="fc" id="L3813">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>

<span class="fc" id="L3815">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force language [&quot; + language + &quot;] to subgroups: &quot; + groupIds, parentGroupId, -1);</span>
        try {
<span class="fc" id="L3817">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3818">            ps = db_conn.prepareStatement(&quot;UPDATE groups SET lng=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3819">            ps.setString(1, language);</span>
<span class="fc" id="L3820">            ps.execute();</span>
<span class="nc" id="L3821">        } catch (Exception ex) {</span>
<span class="nc" id="L3822">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3825" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3826">                    ps.close();</span>
<span class="pc bpc" id="L3827" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3828">                    db_conn.close();</span>
<span class="nc" id="L3829">            } catch (Exception ex) {</span>
<span class="nc" id="L3830">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3831">            }</span>
        }
<span class="fc" id="L3833">    }</span>

    /**
     * nastav sposob zobrazovania a interny podadresarom
     * @param parentGroupId
     * @param internal
     * @param menuType
     * @param loggedMenuType
     */
    public void setInternalAndMenuTypeToSubgroups(int parentGroupId, boolean internal, int menuType, int loggedMenuType) {

<span class="nc" id="L3844">        String groupMenuIds = this.getSubgroupsIds(parentGroupId);</span>

<span class="nc bnc" id="L3846" title="All 2 branches missed.">        if (Tools.isNotEmpty(groupMenuIds)) {</span>
<span class="nc" id="L3847">            Connection db_conn = null;</span>
<span class="nc" id="L3848">            PreparedStatement ps = null;</span>

<span class="nc" id="L3850">            Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force Show Menu Setings to subgroups: &quot; + groupMenuIds, parentGroupId, -1);</span>
            try {
<span class="nc" id="L3852">				db_conn = DBPool.getConnection();</span>
<span class="nc" id="L3853">                ps = db_conn.prepareStatement(&quot;UPDATE groups SET internal=?, menu_type=?, logged_menu_type=?  WHERE group_id IN (&quot; + groupMenuIds + &quot;)&quot;);</span>
<span class="nc" id="L3854">                ps.setBoolean(1, internal);</span>
<span class="nc" id="L3855">                ps.setInt(2, menuType);</span>
<span class="nc" id="L3856">                ps.setInt(3, loggedMenuType);</span>
<span class="nc" id="L3857">                ps.execute();</span>
<span class="nc" id="L3858">            } catch (Exception ex) {</span>
<span class="nc" id="L3859">                sk.iway.iwcm.Logger.error(ex);</span>
            } finally {
                try {
<span class="nc bnc" id="L3862" title="All 2 branches missed.">                    if (ps != null)</span>
<span class="nc" id="L3863">                        ps.close();</span>
<span class="nc bnc" id="L3864" title="All 2 branches missed.">                    if (db_conn != null)</span>
<span class="nc" id="L3865">                        db_conn.close();</span>
<span class="nc" id="L3866">                } catch (Exception ex) {</span>
<span class="nc" id="L3867">                    sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L3868">                }</span>
            }
        }
<span class="nc" id="L3871">    }</span>

    /**
     * nastav prava podadresarom
     */
    public void setPermissionToSubgroups(int parentGroupId, String passwordProtectedString) {

<span class="fc" id="L3878">        Connection db_conn = null;</span>
<span class="fc" id="L3879">        PreparedStatement ps = null;</span>
<span class="fc" id="L3880">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>

<span class="fc" id="L3882">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force perms to subgroups: &quot; + groupIds + &quot; perms=&quot; + passwordProtectedString, parentGroupId, -1);</span>

        try {
<span class="fc" id="L3885">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3886">            ps = db_conn.prepareStatement(&quot;UPDATE groups SET password_protected=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3887">            ps.setString(1, passwordProtectedString);</span>
<span class="fc" id="L3888">            ps.execute();</span>
<span class="nc" id="L3889">        } catch (Exception ex) {</span>
<span class="nc" id="L3890">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3893" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3894">                    ps.close();</span>
<span class="pc bpc" id="L3895" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3896">                    db_conn.close();</span>
<span class="nc" id="L3897">            } catch (Exception ex) {</span>
<span class="nc" id="L3898">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3899">            }</span>
		  }

		  //mame zmeny je najlepsie refreshnut celu GroupsDB
<span class="fc" id="L3903">		  GroupsDB.getInstance(true);</span>
<span class="fc" id="L3904">    }</span>

    /**
     * nastav sablonu podadresarom
     * @param parentGroupId
     */
    public void setTemplateToSubgroups(int parentGroupId, int templateId) {

<span class="fc" id="L3912">        Connection db_conn = null;</span>
<span class="fc" id="L3913">        PreparedStatement ps = null;</span>

<span class="fc" id="L3915">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>
<span class="fc" id="L3916">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force template to subgroups: &quot; + groupIds, parentGroupId, templateId);</span>

        try {
<span class="fc" id="L3919">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3920">            ps = db_conn.prepareStatement(&quot;UPDATE groups SET temp_id=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3921">            ps.setInt(1, templateId);</span>
<span class="fc" id="L3922">            ps.execute();</span>
<span class="nc" id="L3923">        } catch (Exception ex) {</span>
<span class="nc" id="L3924">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3927" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3928">                    ps.close();</span>
<span class="pc bpc" id="L3929" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3930">                    db_conn.close();</span>
<span class="nc" id="L3931">            } catch (Exception ex) {</span>
<span class="nc" id="L3932">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3933">            }</span>
        }
<span class="fc" id="L3935">    }</span>

    /**
     * nastav sablonu podstrankam
     */
    public void setTemplateToSubpages(int parentGroupId, int templateId) {
<span class="fc" id="L3941">        Connection db_conn = null;</span>
<span class="fc" id="L3942">        PreparedStatement ps = null;</span>

<span class="fc" id="L3944">        String groupIds = this.getSubgroupsIds(parentGroupId);</span>
<span class="fc" id="L3945">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;Force template to subpages: &quot; + groupIds, parentGroupId, templateId);</span>

        try {
<span class="fc" id="L3948">			db_conn = DBPool.getConnection();</span>
<span class="fc" id="L3949">            ps = db_conn.prepareStatement(&quot;UPDATE documents SET temp_id=? WHERE group_id IN (&quot; + groupIds + &quot;)&quot;);</span>
<span class="fc" id="L3950">            ps.setInt(1, templateId);</span>
<span class="fc" id="L3951">            ps.execute();</span>
<span class="nc" id="L3952">        } catch (Exception ex) {</span>
<span class="nc" id="L3953">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="pc bpc" id="L3956" title="1 of 2 branches missed.">                if (ps != null)</span>
<span class="fc" id="L3957">                    ps.close();</span>
<span class="pc bpc" id="L3958" title="1 of 2 branches missed.">                if (db_conn != null)</span>
<span class="fc" id="L3959">                    db_conn.close();</span>
<span class="nc" id="L3960">            } catch (Exception ex) {</span>
<span class="nc" id="L3961">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="fc" id="L3962">            }</span>
        }
<span class="fc" id="L3964">    }</span>

    /**
     * nastav zobrazenie pre podstranky
     * @param parentGroupId
     * @param loggedMenuTypeSubdocs
     */
    public void setMenuVisibilityToSubpages(int parentGroupId, String loggedMenuTypeSubdocs) {
<span class="nc" id="L3972">        Connection db_conn = null;</span>
<span class="nc" id="L3973">        PreparedStatement ps = null;</span>

<span class="nc" id="L3975">        boolean allVisible = &quot;allVisible&quot;.equals(loggedMenuTypeSubdocs);</span>
<span class="nc bnc" id="L3976" title="All 2 branches missed.">        Adminlog.add(Adminlog.TYPE_GROUP, &quot;MenuVisibility: all dir documents set to &quot;+(!allVisible ? &quot;NOT&quot; : &quot;&quot;)+&quot; visible in menu&quot;, parentGroupId, -1);</span>
        try {
<span class="nc" id="L3978">			db_conn = DBPool.getConnection();</span>
<span class="nc" id="L3979">            ps = db_conn.prepareStatement(&quot;UPDATE documents SET show_in_menu=? WHERE group_id=?&quot;);</span>
<span class="nc" id="L3980">            ps.setBoolean(1, allVisible);</span>
<span class="nc" id="L3981">            ps.setInt(2,parentGroupId);</span>
<span class="nc" id="L3982">            ps.execute();</span>
<span class="nc" id="L3983">        } catch (Exception ex) {</span>
<span class="nc" id="L3984">            sk.iway.iwcm.Logger.error(ex);</span>
        } finally {
            try {
<span class="nc bnc" id="L3987" title="All 2 branches missed.">                if (ps != null)</span>
<span class="nc" id="L3988">                    ps.close();</span>
<span class="nc bnc" id="L3989" title="All 2 branches missed.">                if (db_conn != null)</span>
<span class="nc" id="L3990">                    db_conn.close();</span>
<span class="nc" id="L3991">            } catch (Exception ex) {</span>
<span class="nc" id="L3992">                sk.iway.iwcm.Logger.error(ex);</span>
<span class="nc" id="L3993">            }</span>
        }
<span class="nc" id="L3995">    }</span>

	/**
	 * Rekurzivne pregeneruje prioritu stranok a podadresarov.
	 * @param groupId
	 */
	public void regenerateSortPriority(int groupId) {

<span class="nc" id="L4003">		int priority = GroupsDB.getInstance().getGroup(groupId).getSortPriority();</span>

<span class="nc" id="L4005">    	List&lt;DocDetails&gt; docDetailsList = DocDB.getInstance().getDocByGroup(groupId, DocDB.ORDER_PRIORITY, true, 0, 0, false);</span>

<span class="nc bnc" id="L4007" title="All 2 branches missed.">		for (DocDetails docDetails : docDetailsList) {</span>
<span class="nc" id="L4008">			docDetails.setSortPriority(priority);</span>
<span class="nc" id="L4009">			priority += 10;</span>
<span class="nc" id="L4010">			DocDB.saveDoc(docDetails);</span>
<span class="nc" id="L4011">		}</span>

<span class="nc" id="L4013">		List&lt;GroupDetails&gt; groupDetailsList = GroupsDB.getInstance().getGroups(groupId);</span>

<span class="nc" id="L4015">		priority = (int)Math.ceil(GroupsDB.getInstance().getGroup(groupId).getSortPriority()/10.0f) * 100;</span>

<span class="nc bnc" id="L4017" title="All 2 branches missed.">		for (GroupDetails groupDetails : groupDetailsList) {</span>
<span class="nc" id="L4018">			priority += 10;</span>
<span class="nc" id="L4019">			groupDetails.setSortPriority(priority);</span>
<span class="nc" id="L4020">			GroupsDB.getInstance().setGroup(groupDetails);</span>
<span class="nc" id="L4021">			this.regenerateSortPriority(groupDetails.getGroupId());</span>
<span class="nc" id="L4022">		}</span>
<span class="nc" id="L4023">	}</span>

	/**
	 * Opravi poradie adresarov po presunuti zadaneho adresara cez drag&amp;drop v adresari (precisluje poradie nasledovnych adresarov)
	 * @param group
	 * @param position
	 */
	public void fixGroupSortOrder(GroupDetails group, int position)
	{
		//ziskaj pocet adresarov v tomto adresari, tie musime odpocitat
<span class="nc" id="L4033">		GroupsDB groupsDB = GroupsDB.getInstance();</span>
<span class="nc" id="L4034">		List&lt;GroupDetails&gt; groupsList = groupsDB.getGroups(group.getParentGroupId());</span>
<span class="nc bnc" id="L4035" title="All 2 branches missed.">		if (position &lt; 0) position = 0;</span>

		//v adresari nic nie je, nemusime menit sort priority
<span class="nc bnc" id="L4038" title="All 2 branches missed.">		if (groupsList.size()==0) return;</span>

<span class="nc" id="L4040">		StringBuilder updateSortOrderList = null;</span>
<span class="nc" id="L4041">		int maxSortPriority = 0;</span>
<span class="nc bnc" id="L4042" title="All 2 branches missed.">		for (GroupDetails g : groupsList)</span>
		{
<span class="nc" id="L4044">			maxSortPriority = g.getSortPriority();</span>

<span class="nc bnc" id="L4046" title="All 2 branches missed.">			if (g.getGroupId() == group.getGroupId())</span>
			{
				//netreba nic menit
<span class="nc" id="L4049">				Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, ZHODA groupID, position=&quot;+position);</span>
<span class="nc bnc" id="L4050" title="All 2 branches missed.">				if (position == 0) return;</span>
				continue;
			}

<span class="nc" id="L4054">			position--;</span>

<span class="nc" id="L4056">			Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, group=&quot;+g.getGroupName()+&quot; &quot;+g.getGroupId()+&quot; position=&quot;+position);</span>

<span class="nc bnc" id="L4058" title="All 2 branches missed.">			if (position == -1)</span>
			{
<span class="nc" id="L4060">				Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, position==-1, setting priority: &quot;+g.getSortPriority());</span>
<span class="nc" id="L4061">				group.setSortPriority(g.getSortPriority());</span>
			}
<span class="nc bnc" id="L4063" title="All 2 branches missed.">			if (position &lt; 0)</span>
			{
<span class="nc bnc" id="L4065" title="All 2 branches missed.">				if (updateSortOrderList == null) updateSortOrderList = new StringBuilder(String.valueOf(g.getGroupId()));</span>
<span class="nc" id="L4066">				else updateSortOrderList.append(&quot;,&quot;).append(String.valueOf(g.getGroupId()));</span>

				//update cache hodnoty
<span class="nc" id="L4069">				g.setSortPriority(g.getSortPriority() + 10);</span>
<span class="nc" id="L4070">				setGroup(g);</span>
			}

<span class="nc" id="L4073">			Logger.debug(GroupsDB.class, &quot;fixGroupSortOrder, toUpdate=&quot;+updateSortOrderList);</span>
<span class="nc" id="L4074">		}</span>

<span class="nc bnc" id="L4076" title="All 2 branches missed.">		if (updateSortOrderList == null)</span>
		{
<span class="nc" id="L4078">			Logger.debug(GroupsDB.class, &quot;updateSortOrderList, updatujem self, maxSortPriority=&quot;+maxSortPriority);</span>
<span class="nc" id="L4079">			group.setSortPriority(maxSortPriority + 10);</span>
		}
<span class="nc" id="L4081">	}</span>

	/**
	 * Cached list of parentGroups
	 *
	 * @param groupId
	 * @return
	 */
	public static List&lt;GroupDetails&gt; getParentGroupsCached(int groupId)
	{
<span class="fc" id="L4091">		final String CACHE_KEY =  &quot;GroupsDB.getListParentGroups(&quot;+groupId+&quot;)&quot;;</span>
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L4093">		List&lt;GroupDetails&gt; listParentGroups = (List&lt;GroupDetails&gt;) Cache.getInstance().getObject(CACHE_KEY);</span>
<span class="fc bfc" id="L4094" title="All 2 branches covered.">		if(listParentGroups == null)</span>
		{
<span class="fc" id="L4096">			listParentGroups = GroupsDB.getInstance().getParentGroups(groupId);</span>
<span class="fc" id="L4097">			Cache.getInstance().setObject(CACHE_KEY, listParentGroups, Constants.getInt(&quot;GroupsDB.parentGroupsCacheMinutes&quot;, 10));</span>
		}
<span class="fc" id="L4099">		return listParentGroups;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>