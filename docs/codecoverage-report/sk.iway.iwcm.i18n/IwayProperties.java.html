<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sk"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IwayProperties.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">webjet8v9</a> &gt; <a href="index.source.html" class="el_package">sk.iway.iwcm.i18n</a> &gt; <span class="el_source">IwayProperties.java</span></div><h1>IwayProperties.java</h1><pre class="source lang-java linenums">package sk.iway.iwcm.i18n;

/*
 *  @(#)Properties.java	1.69 02/03/18
 *
 *  Copyright 2002 Sun Microsystems, Inc. All rights reserved.
 *  SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;

import javax.servlet.jsp.JspWriter;

import net.sourceforge.stripes.action.FileBean;
import sk.iway.iwcm.Logger;
import sk.iway.iwcm.Tools;
import sk.iway.iwcm.io.IwcmFile;
import sk.iway.iwcm.io.IwcmInputStream;

/**
 *  The &lt;code&gt;Properties&lt;/code&gt; class represents a persistent set of properties.
 *  The &lt;code&gt;Properties&lt;/code&gt; can be saved to a stream or loaded from a
 *  stream. Each key and its corresponding value in the property list is a
 *  string. &lt;p&gt;
 *
 *  A property list can contain another property list as its &quot;defaults&quot;; this
 *  second property list is searched if the property key is not found in the
 *  original property list. &lt;p&gt;
 *
 *  Because &lt;code&gt;Properties&lt;/code&gt; inherits from &lt;code&gt;Hashtable&lt;/code&gt;, the
 *  &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;putAll&lt;/code&gt; methods can be applied to a &lt;code&gt;Properties&lt;/code&gt;
 *  object. Their use is strongly discouraged as they allow the caller to insert
 *  entries whose keys or values are not &lt;code&gt;Strings&lt;/code&gt;. The &lt;code&gt;setProperty&lt;/code&gt;
 *  method should be used instead. If the &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;save&lt;/code&gt;
 *  method is called on a &quot;compromised&quot; &lt;code&gt;Properties&lt;/code&gt; object that
 *  contains a non-&lt;code&gt;String&lt;/code&gt; key or value, the call will fail. &lt;p&gt;
 *
 *  &lt;a name=&quot;encoding&quot;&gt;&lt;/a&gt; When saving properties to a stream or loading them
 *  from a stream, the ISO 8859-1 character encoding is used. For characters
 *  that cannot be directly represented in this encoding, &lt;a
 *  href=&quot;http://java.sun.com/docs/books/jls/html/3.doc.html#100850&quot;&gt;Unicode
 *  escapes&lt;/a&gt; are used; however, only a single 'u' character is allowed in an
 *  escape sequence. The native2ascii tool can be used to convert property files
 *  to and from other character encodings.
 *
 *@Title        magma-web
 *@Company      Interway s.r.o. (www.interway.sk)
 *@Copyright    Interway s.r.o. (c) 2001-2002
 *@author       Arthur van Hoff
 *@author       Michael McCloskey
 *@version      1.64, 06/26/00
 *@created      Streda, 2003, m√°j 21
 *@modified     $Date: 2003/05/21 15:35:43 $
 *@see          &lt;a href=&quot;../../../tooldocs/solaris/native2ascii.html&quot;&gt;
 *      native2ascii tool for Solaris&lt;/a&gt;
 *@see          &lt;a href=&quot;../../../tooldocs/windows/native2ascii.html&quot;&gt;
 *      native2ascii tool for Windows&lt;/a&gt;
 *@since        JDK1.0
 */

public class IwayProperties extends Hashtable&lt;String, String&gt;
{
   /**
    *  use serialVersionUID from JDK 1.1.X for interoperability
    */
   private static final long serialVersionUID = 4112578634029874840L;

   /**
    *  A property list that contains default values for any keys not found in
    *  this property list.
    *
    *@serial
    */
   protected IwayProperties defaults;

<span class="pc" id="L89">   private String encoding = &quot;windows-1250&quot;;</span>

   /**
    *  Creates an empty property list with no default values.
    */
   public IwayProperties()
<span class="fc" id="L95">   {</span>

<span class="fc" id="L97">   }</span>

   public IwayProperties(String encoding)
<span class="fc" id="L100">   {</span>
<span class="fc" id="L101">      this.encoding = encoding;</span>
<span class="fc" id="L102">   }</span>


   /**
    *  Creates an empty property list with the specified defaults.
    *
    *@param  defaults  the defaults.
    */
   public IwayProperties(IwayProperties defaults)
<span class="nc" id="L111">   {</span>
<span class="nc" id="L112">      this.defaults = defaults;</span>
<span class="nc" id="L113">   }</span>

   /**
    *  Calls the &lt;tt&gt;Hashtable&lt;/tt&gt; method &lt;code&gt;put&lt;/code&gt;. Provided for
    *  parallelism with the &lt;tt&gt;getProperty&lt;/tt&gt; method. Enforces use of strings
    *  for property keys and values. The value returned is the result of the
    *  &lt;tt&gt;Hashtable&lt;/tt&gt; call to &lt;code&gt;put&lt;/code&gt;.
    *
    *@param  key    the key to be placed into this property list.
    *@param  value  the value corresponding to &lt;tt&gt;key&lt;/tt&gt; .
    *@return        the previous value of the specified key in this property
    *      list, or &lt;code&gt;null&lt;/code&gt; if it did not have one.
    *@see           #getProperty
    *@since         1.2
    */
   public synchronized Object setProperty(String key, String value)
   {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">      if (value == null) return null;</span>
<span class="fc" id="L131">      return put(key, value);</span>
   }

   private static final String keyValueSeparators = &quot;=: \t\r\n\f&quot;; //NOSONAR

   private static final String strictKeyValueSeparators = &quot;=:&quot;; //NOSONAR

   private static final String specialSaveChars = &quot;=: \t\r\n\f#!&quot;; //NOSONAR

   private static final String whiteSpaceChars = &quot; \t\r\n\f&quot;; //NOSONAR

   /**
    *  Reads a property list (key and element pairs) from the input stream. The
    *  stream is assumed to be using the ISO 8859-1 character encoding. &lt;p&gt;
    *
    *  Every property occupies one line of the input stream. Each line is
    *  terminated by a line terminator (&lt;code&gt;\n&lt;/code&gt; or &lt;code&gt;\r&lt;/code&gt; or
    *  &lt;code&gt;\r\n&lt;/code&gt;). Lines from the input stream are processed until end
    *  of file is reached on the input stream. &lt;p&gt;
    *
    *  A line that contains only whitespace or whose first non-whitespace
    *  character is an ASCII &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; is ignored (thus,
    *  &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; indicate comment lines). &lt;p&gt;
    *
    *  Every line other than a blank line or a comment line describes one
    *  property to be added to the table (except that if a line ends with \,
    *  then the following line, if it exists, is treated as a continuation line,
    *  as described below). The key consists of all the characters in the line
    *  starting with the first non-whitespace character and up to, but not
    *  including, the first ASCII &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt;, or whitespace
    *  character. All of the key termination characters may be included in the
    *  key by preceding them with a \. Any whitespace after the key is skipped;
    *  if the first non-whitespace character after the key is &lt;code&gt;=&lt;/code&gt; or
    *  &lt;code&gt;:&lt;/code&gt;, then it is ignored and any whitespace characters after it
    *  are also skipped. All remaining characters on the line become part of the
    *  associated element string. Within the element string, the ASCII escape
    *  sequences &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\\&lt;/code&gt;
    *  , &lt;code&gt;\&quot;&lt;/code&gt;, &lt;code&gt;\'&lt;/code&gt;, &lt;code&gt;\ &amp;#32;&lt;/code&gt; &amp;#32;(a
    *  backslash and a space), and &lt;code&gt;&amp;#92;u&lt;/code&gt;&lt;i&gt;xxxx&lt;/i&gt; are recognized
    *  and converted to single characters. Moreover, if the last character on
    *  the line is &lt;code&gt;\&lt;/code&gt;, then the next line is treated as a
    *  continuation of the current line; the &lt;code&gt;\&lt;/code&gt; and line terminator
    *  are simply discarded, and any leading whitespace characters on the
    *  continuation line are also discarded and are not part of the element
    *  string. &lt;p&gt;
    *
    *  As an example, each of the following four lines specifies the key &lt;code&gt;&quot;Truth&quot;&lt;/code&gt;
    *  and the associated element value &lt;code&gt;&quot;Beauty&quot;&lt;/code&gt;: &lt;p&gt;
    *
    *  &lt;pre&gt;
    * Truth = Beauty
    *	Truth:Beauty
    * Truth			:Beauty
    * &lt;/pre&gt; As another example, the following three lines specify a single
    *  property: &lt;p&gt;
    *
    *  &lt;pre&gt;
    * fruits				apple, banana, pear, \
    *                                  cantaloupe, watermelon, \
    *                                  kiwi, mango
    * &lt;/pre&gt; The key is &lt;code&gt;&quot;fruits&quot;&lt;/code&gt; and the associated element is: &lt;p&gt;
    *
    *  &lt;pre&gt;&quot;apple, banana, pear, cantaloupe, watermelon, kiwi, mango&quot;&lt;/pre&gt;
    *  Note that a space appears before each &lt;code&gt;\&lt;/code&gt; so that a space will
    *  appear after each comma in the final result; the &lt;code&gt;\&lt;/code&gt;, line
    *  terminator, and leading whitespace on the continuation line are merely
    *  discarded and are &lt;i&gt;not&lt;/i&gt; replaced by one or more other characters.
    *  &lt;p&gt;
    *
    *  As a third example, the line: &lt;p&gt;
    *
    *  &lt;pre&gt;cheeses
    * &lt;/pre&gt; specifies that the key is &lt;code&gt;&quot;cheeses&quot;&lt;/code&gt; and the associated
    *  element is the empty string.&lt;p&gt;
    *
    *
    *
    *@exception  IOException  if an error occurred when reading from the input
    *      stream.
    */
   public synchronized void load(IwcmFile f) throws IOException
   {
   	//jeeff: musel som to urobit takto kvoli handlingu roznych kodovani, malo to interne problem s kodovanim suborov
<span class="fc" id="L214">   	IwcmInputStream fis = new IwcmInputStream(f);</span>
<span class="fc" id="L215">   	String newEncoding = load(fis);</span>
<span class="fc" id="L216">   	fis.close();</span>

<span class="fc bfc" id="L218" title="All 2 branches covered.">   	if (Tools.isNotEmpty(newEncoding))</span>
   	{
<span class="fc" id="L220">   		encoding = newEncoding;</span>
<span class="fc" id="L221">   		fis = new IwcmInputStream(f);</span>
<span class="fc" id="L222">      	load(fis);</span>
<span class="fc" id="L223">      	fis.close();</span>

      	//toto zresetuje encoding, aby text-INSTALL_NAME.properties nahravalo v starom kodovani
<span class="fc" id="L226">         encoding = &quot;windows-1250&quot;;</span>
   	}
<span class="fc" id="L228">   }</span>

   /**
    * to iste ako load(java.io.File) akurat s net.sourceforge.stripes.action.FileBean
    * @param propFile
    * @throws IOException
    */
   public void load(FileBean propFile) throws IOException
	{
<span class="nc" id="L237">   	InputStream is = propFile.getInputStream();</span>
<span class="nc" id="L238">   	String newEncoding = load(is);</span>
<span class="nc" id="L239">   	is.close();</span>

<span class="nc bnc" id="L241" title="All 2 branches missed.">   	if (Tools.isNotEmpty(newEncoding))</span>
   	{
<span class="nc" id="L243">   		encoding = newEncoding;</span>
<span class="nc" id="L244">   		is = propFile.getInputStream();</span>
<span class="nc" id="L245">      	load(is);</span>
<span class="nc" id="L246">      	is.close();</span>

      	//toto zresetuje encoding, aby text-INSTALL_NAME.properties nahravalo v starom kodovani
<span class="nc" id="L249">         encoding = &quot;windows-1250&quot;;</span>
   	}

<span class="nc" id="L252">	}</span>

   private String load(InputStream inStream) throws IOException
   {
<span class="fc" id="L256">      BufferedReader in = new BufferedReader(new InputStreamReader(inStream, encoding));</span>
<span class="fc" id="L257">      int readCounter = 0;</span>
      while (true)
      {
         // Get next line
<span class="fc" id="L261">         String line = in.readLine();</span>
<span class="fc" id="L262">         readCounter++;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">         if (line == null)</span>
         {
<span class="fc" id="L265">         	in.close();</span>

         	//toto zresetuje encoding, aby text-INSTALL_NAME.properties nahravalo v starom kodovani
<span class="fc" id="L268">            encoding = &quot;windows-1250&quot;;</span>
<span class="fc" id="L269">            Logger.debug(IwayProperties.class, &quot;   readed &quot;+readCounter+&quot; keys&quot;);</span>
<span class="fc" id="L270">            return null;</span>
         }

<span class="fc bfc" id="L273" title="All 2 branches covered.">         if (line.length() &gt; 0)</span>
         {
<span class="fc bfc" id="L275" title="All 2 branches covered.">         	if (line.indexOf(&quot;#encoding=&quot;)!=-1)</span>
         	{
<span class="fc" id="L277">         		String newEncoding = line.substring(line.indexOf(&quot;=&quot;)+1);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">         		if (encoding.equals(newEncoding)==false)</span>
         		{
<span class="fc" id="L280">                  Logger.debug(IwayProperties.class, &quot;Encoding: &quot; + encoding+&quot; newEncoding=&quot;+newEncoding);</span>
<span class="fc" id="L281">                  in.close();</span>
<span class="fc" id="L282">	         		return newEncoding;</span>
         		}
         	}

            // Continue lines that end in slashes if they are not comments
<span class="fc" id="L287">            char firstChar = line.charAt(0);</span>
<span class="pc bpc" id="L288" title="1 of 4 branches missed.">            if ((firstChar != '#') &amp;&amp; (firstChar != '!'))</span>
            {
<span class="fc bfc" id="L290" title="All 2 branches covered.">               while (continueLine(line))</span>
               {
<span class="fc" id="L292">                  String nextLine = in.readLine();</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                  if (nextLine == null)</span>
                  {
<span class="nc" id="L295">                     nextLine = &quot;&quot;;</span>
                  }
<span class="fc" id="L297">                  String loppedLine = line.substring(0, line.length() - 1);</span>
                  // Advance beyond whitespace on new line
<span class="fc" id="L299">                  int startIndex = 0;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                  for (startIndex = 0; startIndex &lt; nextLine.length(); startIndex++)</span>
                  {
<span class="fc bfc" id="L302" title="All 2 branches covered.">                     if (whiteSpaceChars.indexOf(nextLine.charAt(startIndex)) == -1)</span>
                     {
<span class="fc" id="L304">                        break;</span>
                     }
                  }
<span class="fc" id="L307">                  nextLine = nextLine.substring(startIndex, nextLine.length());</span>
<span class="fc" id="L308">                  line = loppedLine + &quot;\r\n&quot; + nextLine;</span>
<span class="fc" id="L309">               }</span>

               // Find start of key
<span class="fc" id="L312">               int len = line.length();</span>
               int keyStart;
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">               for (keyStart = 0; keyStart &lt; len; keyStart++)</span>
               {
<span class="fc bfc" id="L316" title="All 2 branches covered.">                  if (whiteSpaceChars.indexOf(line.charAt(keyStart)) == -1)</span>
                  {
<span class="fc" id="L318">                     break;</span>
                  }
               }

               // Blank lines are ignored
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">               if (keyStart == len)</span>
               {
<span class="nc" id="L325">                  continue;</span>
               }

               // Find separation between key and value
               int separatorIndex;
<span class="fc bfc" id="L330" title="All 2 branches covered.">               for (separatorIndex = keyStart; separatorIndex &lt; len; separatorIndex++)</span>
               {
<span class="fc" id="L332">                  char currentChar = line.charAt(separatorIndex);</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">                  if (currentChar == '\\')</span>
                  {
<span class="nc" id="L335">                     separatorIndex++;</span>
                  }
<span class="fc bfc" id="L337" title="All 2 branches covered.">                  else if (keyValueSeparators.indexOf(currentChar) != -1)</span>
                  {
<span class="fc" id="L339">                     break;</span>
                  }
               }

               // Skip over whitespace after key if any
               int valueIndex;
<span class="fc bfc" id="L345" title="All 2 branches covered.">               for (valueIndex = separatorIndex; valueIndex &lt; len; valueIndex++)</span>
               {
<span class="fc bfc" id="L347" title="All 2 branches covered.">                  if (whiteSpaceChars.indexOf(line.charAt(valueIndex)) == -1)</span>
                  {
<span class="fc" id="L349">                     break;</span>
                  }
               }

               // Skip over one non whitespace key value separators if any
<span class="fc bfc" id="L354" title="All 2 branches covered.">               if (valueIndex &lt; len)</span>
               {
<span class="fc bfc" id="L356" title="All 2 branches covered.">                  if (strictKeyValueSeparators.indexOf(line.charAt(valueIndex)) != -1)</span>
                  {
<span class="fc" id="L358">                     valueIndex++;</span>
                  }
               }

               // Skip over white space after other separators if any
<span class="fc bfc" id="L363" title="All 2 branches covered.">               while (valueIndex &lt; len)</span>
               {
<span class="fc bfc" id="L365" title="All 2 branches covered.">                  if (whiteSpaceChars.indexOf(line.charAt(valueIndex)) == -1)</span>
                  {
<span class="fc" id="L367">                     break;</span>
                  }
<span class="fc" id="L369">                  valueIndex++;</span>
               }
<span class="fc" id="L371">               String key = line.substring(keyStart, separatorIndex);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">               String value = (separatorIndex &lt; len) ? line.substring(valueIndex, len) : &quot;&quot;;</span>

               // Convert then store key and value
<span class="fc" id="L375">               key = loadConvert(key);</span>
<span class="fc" id="L376">               value = loadConvert(value);</span>
<span class="fc" id="L377">               put(key, value);</span>
            }
         }
<span class="fc" id="L380">      }</span>
   }

   /*
    *  Returns true if the given line is a line that must
    *  be appended to the next line
    */
   /**
    *  Description of the Method
    *
    *@param  line  Description of the Parameter
    *@return       Description of the Return Value
    */
   private boolean continueLine(String line)
   {
<span class="fc" id="L395">      int slashCount = 0;</span>
<span class="fc" id="L396">      int index = line.length() - 1;</span>
<span class="pc bpc" id="L397" title="1 of 4 branches missed.">      while ((index &gt;= 0) &amp;&amp; (line.charAt(index--) == '\\'))</span>
      {
<span class="fc" id="L399">         slashCount++;</span>
      }
<span class="fc bfc" id="L401" title="All 2 branches covered.">      return (slashCount % 2 != 0);</span>
   }

   /*
    *  Converts encoded &amp;#92;uxxxx to unicode chars
    *  and changes special saved chars to their original forms
    */
   /**
    *  Description of the Method
    *
    *@param  theString  Description of the Parameter
    *@return            Description of the Return Value
    */
    @SuppressWarnings(&quot;java:S127&quot;)
   private String loadConvert(String theString)
   {
      char aChar;
<span class="fc" id="L418">      int len = theString.length();</span>
<span class="fc" id="L419">      StringBuilder outBuffer = new StringBuilder(len);</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">      for (int x = 0; x &lt; len; )</span>
      {
<span class="fc" id="L423">         aChar = theString.charAt(x++);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">         if (aChar == '\\')</span>
         {
<span class="fc" id="L426">            aChar = theString.charAt(x++);</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">            if (aChar == 'u')</span>
            {
               // Read the xxxx
<span class="nc" id="L430">               int value = 0;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">               for (int i = 0; i &lt; 4; i++)</span>
               {
<span class="nc" id="L433">                  aChar = theString.charAt(x++);</span>
<span class="nc bnc" id="L434" title="All 4 branches missed.">                  switch (aChar)</span>
                  {
                      case '0':
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
<span class="nc" id="L446">                         value = (value &lt;&lt; 4) + aChar - '0';</span>
<span class="nc" id="L447">                         break;</span>
                      case 'a':
                      case 'b':
                      case 'c':
                      case 'd':
                      case 'e':
                      case 'f':
<span class="nc" id="L454">                         value = (value &lt;&lt; 4) + 10 + aChar - 'a';</span>
<span class="nc" id="L455">                         break;</span>
                      case 'A':
                      case 'B':
                      case 'C':
                      case 'D':
                      case 'E':
                      case 'F':
<span class="nc" id="L462">                         value = (value &lt;&lt; 4) + 10 + aChar - 'A';</span>
<span class="nc" id="L463">                         break;</span>
                      default:
<span class="nc" id="L465">                         throw new IllegalArgumentException(</span>
                               &quot;Malformed \\uxxxx encoding.&quot;);
                  }
               }
<span class="nc" id="L469">               outBuffer.append((char) value);</span>
<span class="nc" id="L470">            }</span>
            else
            {
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">               if (aChar == 't')</span>
               {
<span class="nc" id="L475">                  aChar = '\t';</span>
               }
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">               else if (aChar == 'r')</span>
               {
<span class="nc" id="L479">                  aChar = '\r';</span>
               }
<span class="fc bfc" id="L481" title="All 2 branches covered.">               else if (aChar == 'n')</span>
               {
<span class="fc" id="L483">                  aChar = '\n';</span>
               }
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">               else if (aChar == 'f')</span>
               {
<span class="nc" id="L487">                  aChar = '\f';</span>
               }
<span class="fc" id="L489">               outBuffer.append(aChar);</span>
            }
         }
         else
         {
<span class="fc" id="L494">            outBuffer.append(aChar);</span>
         }
      }
<span class="fc" id="L497">      return outBuffer.toString();</span>
   }

   /*
    *  Converts unicodes to encoded &amp;#92;uxxxx
    *  and writes out any of the characters in specialSaveChars
    *  with a preceding slash
    */
   /**
    *  Description of the Method
    *
    *@param  theString    Description of the Parameter
    *@param  escapeSpace  Description of the Parameter
    *@return              Description of the Return Value
    */
   private String saveConvert(String theString, boolean escapeSpace)
   {
<span class="nc" id="L514">      int len = theString.length();</span>
<span class="nc" id="L515">      StringBuilder outBuffer = new StringBuilder(len * 2);</span>

<span class="nc bnc" id="L517" title="All 2 branches missed.">      for (int x = 0; x &lt; len; x++)</span>
      {
<span class="nc" id="L519">         char aChar = theString.charAt(x);</span>
<span class="nc bnc" id="L520" title="All 7 branches missed.">         switch (aChar)</span>
         {
             case ' ':
<span class="nc bnc" id="L523" title="All 4 branches missed.">                if (x == 0 || escapeSpace)</span>
                {
<span class="nc" id="L525">                   outBuffer.append('\\');</span>
                }

<span class="nc" id="L528">                outBuffer.append(' ');</span>
<span class="nc" id="L529">                break;</span>
             case '\\':
<span class="nc" id="L531">                outBuffer.append('\\');</span>
<span class="nc" id="L532">                outBuffer.append('\\');</span>
<span class="nc" id="L533">                break;</span>
             case '\t':
<span class="nc" id="L535">                outBuffer.append('\\');</span>
<span class="nc" id="L536">                outBuffer.append('t');</span>
<span class="nc" id="L537">                break;</span>
             case '\n':
<span class="nc" id="L539">                outBuffer.append('\\');</span>
<span class="nc" id="L540">                outBuffer.append('n');</span>
<span class="nc" id="L541">                break;</span>
             case '\r':
<span class="nc" id="L543">                outBuffer.append('\\');</span>
<span class="nc" id="L544">                outBuffer.append('r');</span>
<span class="nc" id="L545">                break;</span>
             case '\f':
<span class="nc" id="L547">                outBuffer.append('\\');</span>
<span class="nc" id="L548">                outBuffer.append('f');</span>
<span class="nc" id="L549">                break;</span>
             default:
<span class="nc bnc" id="L551" title="All 4 branches missed.">                if ((aChar &lt; 0x0020) || (aChar &gt; 0x007e))</span>
                {
<span class="nc" id="L553">                   outBuffer.append('\\');</span>
<span class="nc" id="L554">                   outBuffer.append('u');</span>
<span class="nc" id="L555">                   outBuffer.append(toHex((aChar &gt;&gt; 12) &amp; 0xF));</span>
<span class="nc" id="L556">                   outBuffer.append(toHex((aChar &gt;&gt; 8) &amp; 0xF));</span>
<span class="nc" id="L557">                   outBuffer.append(toHex((aChar &gt;&gt; 4) &amp; 0xF));</span>
<span class="nc" id="L558">                   outBuffer.append(toHex(aChar &amp; 0xF));</span>
                }
                else
                {
<span class="nc bnc" id="L562" title="All 2 branches missed.">                   if (specialSaveChars.indexOf(aChar) != -1)</span>
                   {
<span class="nc" id="L564">                      outBuffer.append('\\');</span>
                   }
<span class="nc" id="L566">                   outBuffer.append(aChar);</span>
                }
         }
      }
<span class="nc" id="L570">      return outBuffer.toString();</span>
   }


   /**
    *  Writes this property list (key and element pairs) in this &lt;code&gt;Properties&lt;/code&gt;
    *  table to the output stream in a format suitable for loading into a &lt;code&gt;Properties&lt;/code&gt;
    *  table using the &lt;code&gt;load&lt;/code&gt; method. The stream is written using the
    *  character encoding entered as parameter. &lt;p&gt;
    *
    *  Properties from the defaults table of this &lt;code&gt;Properties&lt;/code&gt; table
    *  (if any) are &lt;i&gt;not&lt;/i&gt; written out by this method. &lt;p&gt;
    *
    *  If the header argument is not null, then an ASCII &lt;code&gt;#&lt;/code&gt;
    *  character, the header string, and a line separator are first written to
    *  the output stream. Thus, the &lt;code&gt;header&lt;/code&gt; can serve as an
    *  identifying comment. &lt;p&gt;
    *
    *  Next, a comment line is always written, consisting of an ASCII &lt;code&gt;#&lt;/code&gt;
    *  character, the current date and time (as if produced by the &lt;code&gt;toString&lt;/code&gt;
    *  method of &lt;code&gt;Date&lt;/code&gt; for the current time), and a line separator
    *  as generated by the Writer. &lt;p&gt;
    *
    *  Then every entry in this &lt;code&gt;Properties&lt;/code&gt; table is written out,
    *  one per line. For each entry the key string is written, then an ASCII
    *  &lt;code&gt;=&lt;/code&gt;, then the associated element string. Each character of the
    *  element string is examined to see whether it should be rendered as an
    *  escape sequence. The ASCII characters &lt;code&gt;\&lt;/code&gt;, tab, newline, and
    *  carriage return are written as &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;
    *  , and &lt;code&gt;\r&lt;/code&gt;, respectively. Characters less than &lt;code&gt;&amp;#92;u0020&lt;/code&gt;
    *  and characters greater than &lt;code&gt;&amp;#92;u007E&lt;/code&gt; are written as &lt;code&gt;&amp;#92;u&lt;/code&gt;
    *  &lt;i&gt;xxxx&lt;/i&gt; for the appropriate hexadecimal value &lt;i&gt;xxxx&lt;/i&gt; . Leading
    *  space characters, but not embedded or trailing space characters, are
    *  written with a preceding &lt;code&gt;\&lt;/code&gt;. The key and value characters
    *  &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; are
    *  written with a preceding slash to ensure that they are properly loaded.
    *  &lt;p&gt;
    *
    *  After the entries have been written, the output stream is flushed. The
    *  output stream remains open after this method returns.
    *
    *@param  out                       an output stream.
    * @param  header                    a description of the property list.
    * @param encoding 						encoding, supported are ISO-8859-1 and UTF-8
    * @exception  IOException           if writing this property list to the
    *      specified output stream throws an &lt;tt&gt;IOException&lt;/tt&gt; .
    * @throws UnsupportedEncodingException
    *@since                            1.2
    */
   public synchronized void store(OutputStream out, String header, String encoding)
          throws IOException
   {
      BufferedWriter awriter;
<span class="nc" id="L623">      Charset targetcharset = Charset.forName(encoding);</span>
<span class="nc" id="L624">      Charset iso88591charset = StandardCharsets.ISO_8859_1;</span>
<span class="nc" id="L625">      awriter = new BufferedWriter(new OutputStreamWriter(out, targetcharset));</span>
<span class="nc" id="L626">      writeln(awriter, &quot;#encoding=&quot; + encoding);</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">      if (header != null)</span>
      {
<span class="nc" id="L629">         writeln(awriter, &quot;#&quot; + header);</span>
      }
<span class="nc" id="L631">      writeln(awriter, &quot;#&quot; + new Date().toString());</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">      for (Enumeration&lt;String&gt; e = keys(); e.hasMoreElements(); )</span>
      {
<span class="nc" id="L634">         String key = e.nextElement();</span>
<span class="nc" id="L635">         String val = get(key);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">         if(targetcharset.equals(iso88591charset)){</span>
<span class="nc" id="L637">         	key = saveConvert(key, true);</span>
            /*
             *  No need to escape embedded and trailing spaces for value, hence
             *  pass false to flag.
             */
<span class="nc" id="L642">            val = saveConvert(val, false);</span>
         }
         else{
<span class="nc" id="L645">         	val = val.replace(&quot;\r\n&quot;, &quot; \\\\\r\n\t&quot;);</span>
         }
<span class="nc" id="L647">         writeln(awriter, key + &quot;=&quot; + val);</span>
<span class="nc" id="L648">      }</span>
<span class="nc" id="L649">      awriter.flush();</span>
<span class="nc" id="L650">   }</span>

   /**
    * Doing same as stire with {@link OutputStream} parameter, but writes into {@link JspWriter}
    * using UTF-8 encoding
    * @param awriter jspwriter
    * @param header header of generated file, preceeded by hash mark
    * @throws IOException
    */
   public synchronized void storeUtf8(JspWriter awriter, String header)
   throws IOException
	{
<span class="nc" id="L662">   	writeln(awriter, &quot;#encoding=UTF-8&quot;);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">		if (header != null)</span>
		{
<span class="nc" id="L665">		  writeln(awriter, &quot;#&quot; + header);</span>
		}
<span class="nc" id="L667">		writeln(awriter, &quot;#&quot; + new Date().toString());</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">		for (Enumeration&lt;String&gt; e = keys(); e.hasMoreElements(); )</span>
		{
<span class="nc" id="L670">		  String key = e.nextElement();</span>
<span class="nc" id="L671">		  String val = get(key);</span>
<span class="nc" id="L672">		  key = Tools.replace(key, &quot; &quot;, &quot;\\u0020&quot;);</span>
<span class="nc" id="L673">		  val = val.replaceAll(&quot;[\r\n]+&quot;, &quot; \\\\\r\n\t&quot;);</span>
		  //nahrad lomitka za dvojite, aby islo napisat do textu \n a nespravilo sa z toho enter
<span class="nc" id="L675">        val = Tools.replace(val,&quot;\\&quot;, &quot;\\\\&quot;);</span>
        //lomitko na konci riadku nemoze byt dvojite, ale len jednoite
<span class="nc" id="L677">        val = Tools.replace(val,&quot;\\\\\n&quot;, &quot;\\\n&quot;);</span>
<span class="nc" id="L678">        val = Tools.replace(val,&quot;\\\\\r&quot;, &quot;\\\r&quot;);</span>
<span class="nc" id="L679">		  writeln(awriter, key + &quot;=&quot; + val);</span>
<span class="nc" id="L680">		}</span>
<span class="nc" id="L681">		awriter.flush();</span>
<span class="nc" id="L682">	}</span>

   private void writeln(JspWriter awriter, String s) throws IOException
	{
<span class="nc" id="L686">   	awriter.write(s);</span>
<span class="nc" id="L687">   	awriter.newLine();</span>
<span class="nc" id="L688">	}</span>

	/**
    *  Description of the Method
    *
    *@param  bw               Description of the Parameter
    *@param  s                Description of the Parameter
    *@exception  IOException  Description of the Exception
    */
   private static void writeln(BufferedWriter bw, String s) throws IOException
   {
<span class="nc" id="L699">      bw.write(s);</span>
<span class="nc" id="L700">      bw.newLine();</span>
<span class="nc" id="L701">   }</span>

   /**
    *  Searches for the property with the specified key in this property list.
    *  If the key is not found in this property list, the default property list,
    *  and its defaults, recursively, are then checked. The method returns
    *  &lt;code&gt;null&lt;/code&gt; if the property is not found.
    *
    *@param  key  the property key.
    *@return      the value in this property list with the specified key value.
    *@see         #setProperty
    *@see         #defaults
    */
   public String getProperty(String key)
   {
   	//nerobte mi z tohto synchronized, nastaval by deadlock
<span class="fc" id="L717">      Object oval = super.get(key);</span>
<span class="fc bfc" id="L718" title="All 2 branches covered.">      String sval = (oval instanceof String) ? (String) oval : null;</span>
<span class="pc bpc" id="L719" title="1 of 4 branches missed.">      return ((sval == null) &amp;&amp; (defaults != null)) ? defaults.getProperty(key) : sval;</span>
   }

   /**
    *  Searches for the property with the specified key in this property list.
    *  If the key is not found in this property list, the default property list,
    *  and its defaults, recursively, are then checked. The method returns the
    *  default value argument if the property is not found.
    *
    *@param  key           the hashtable key.
    *@param  defaultValue  a default value.
    *@return               the value in this property list with the specified
    *      key value.
    *@see                  #setProperty
    *@see                  #defaults
    */
   public String getProperty(String key, String defaultValue)
   {
   	//nerobte mi z tohto synchronized, nastaval by deadlock
<span class="fc" id="L738">      String val = getProperty(key);</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">      return (val == null) ? defaultValue : val;</span>
   }

   /**
    *  Returns an enumeration of all the keys in this property list, including
    *  distinct keys in the default property list if a key of the same name has
    *  not already been found from the main properties list.
    *
    *@return    an enumeration of all the keys in this property list, including
    *      the keys in the default property list.
    *@see       java.util.Enumeration
    */
   public Enumeration&lt;String&gt; propertyNames()
   {
<span class="nc" id="L753">      Hashtable&lt;String, String&gt; h = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L754">      enumerate(h);</span>
<span class="nc" id="L755">      return h.keys();</span>
   }

   /**
    *  Prints this property list out to the specified output stream. This method
    *  is useful for debugging.
    *
    *@param  out  an output stream.
    */
   public void list(PrintStream out)
   {
<span class="nc" id="L766">      out.println(&quot;-- listing properties --&quot;);</span>
<span class="nc" id="L767">      Hashtable&lt;String, String&gt; h = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L768">      enumerate(h);</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">      for (Enumeration&lt;String&gt; e = h.keys(); e.hasMoreElements(); )</span>
      {
<span class="nc" id="L771">         String key = e.nextElement();</span>
<span class="nc" id="L772">         String val = h.get(key);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">         if (val.length() &gt; 40)</span>
         {
<span class="nc" id="L775">            val = val.substring(0, 37) + &quot;...&quot;;</span>
         }
<span class="nc" id="L777">         out.println(key + &quot;=&quot; + val);</span>
<span class="nc" id="L778">      }</span>
<span class="nc" id="L779">   }</span>

   /**
    *  Prints this property list out to the specified output stream. This method
    *  is useful for debugging.
    *
    *@param  out  an output stream.
    *@since       JDK1.1
    */
   /*
    *  Rather than use an anonymous inner class to share common code, this
    *  method is duplicated in order to ensure that a non-1.1 compiler can
    *  compile this file.
    */
   public void list(PrintWriter out)
   {
<span class="nc" id="L795">      out.println(&quot;-- listing properties --&quot;);</span>
<span class="nc" id="L796">      Hashtable&lt;String, String&gt; h = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L797">      enumerate(h);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">      for (Enumeration&lt;String&gt; e = h.keys(); e.hasMoreElements(); )</span>
      {
<span class="nc" id="L800">         String key = e.nextElement();</span>
<span class="nc" id="L801">         String val = h.get(key);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">         if (val.length() &gt; 40)</span>
         {
<span class="nc" id="L804">            val = val.substring(0, 37) + &quot;...&quot;;</span>
         }
<span class="nc" id="L806">         out.println(key + &quot;=&quot; + val);</span>
<span class="nc" id="L807">      }</span>
<span class="nc" id="L808">   }</span>

   /**
    *  Enumerates all key/value pairs in the specified hastable.
    *
    *@param  h  the hashtable
    */
   private synchronized void enumerate(Hashtable&lt;String, String&gt; h)
   {
<span class="nc bnc" id="L817" title="All 2 branches missed.">      if (defaults != null)</span>
      {
<span class="nc" id="L819">         defaults.enumerate(h);</span>
      }
<span class="nc bnc" id="L821" title="All 2 branches missed.">      for (Enumeration&lt;String&gt; e = keys(); e.hasMoreElements(); )</span>
      {
<span class="nc" id="L823">         String key = e.nextElement();</span>
<span class="nc" id="L824">         h.put(key, get(key));</span>
<span class="nc" id="L825">      }</span>
<span class="nc" id="L826">   }</span>

   /**
    *  Convert a nibble to a hex character
    *
    *@param  nibble  the nibble to convert.
    *@return         Description of the Return Value
    */
   private static char toHex(int nibble)
   {
<span class="nc" id="L836">      return hexDigit[(nibble &amp; 0xF)];</span>
   }

   /**
    *  A table of hex digits
    */
<span class="fc" id="L842">   private static final char[] hexDigit = {</span>
         '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
         };

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>