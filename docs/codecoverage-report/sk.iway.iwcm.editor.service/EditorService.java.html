<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sk"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EditorService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">webjet8v9</a> &gt; <a href="index.source.html" class="el_package">sk.iway.iwcm.editor.service</a> &gt; <span class="el_source">EditorService.java</span></div><h1>EditorService.java</h1><pre class="source lang-java linenums">package sk.iway.iwcm.editor.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.StringTokenizer;
import java.util.stream.Collectors;

import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.context.annotation.RequestScope;

import sk.iway.iwcm.Adminlog;
import sk.iway.iwcm.Constants;
import sk.iway.iwcm.DB;
import sk.iway.iwcm.FileTools;
import sk.iway.iwcm.Identity;
import sk.iway.iwcm.Logger;
import sk.iway.iwcm.PathFilter;
import sk.iway.iwcm.Tools;
import sk.iway.iwcm.common.CloudToolsForCore;
import sk.iway.iwcm.common.DocTools;
import sk.iway.iwcm.database.SimpleQuery;
import sk.iway.iwcm.doc.DebugTimer;
import sk.iway.iwcm.doc.DocBasic;
import sk.iway.iwcm.doc.DocDB;
import sk.iway.iwcm.doc.DocDetails;
import sk.iway.iwcm.doc.DocDetailsRepository;
import sk.iway.iwcm.doc.DocEditorFields;
import sk.iway.iwcm.doc.DocHistory;
import sk.iway.iwcm.doc.DocHistoryRepository;
import sk.iway.iwcm.doc.GroupDetails;
import sk.iway.iwcm.doc.GroupsDB;
import sk.iway.iwcm.doc.MultigroupMapping;
import sk.iway.iwcm.doc.MultigroupMappingDB;
import sk.iway.iwcm.doc.TemplateDetails;
import sk.iway.iwcm.doc.TemplatesDB;
import sk.iway.iwcm.doc.attributes.jpa.DocAtrDefEntity;
import sk.iway.iwcm.doc.attributes.jpa.DocAtrEntity;
import sk.iway.iwcm.doc.attributes.jpa.DocAtrRepository;
import sk.iway.iwcm.editor.DocNoteBean;
import sk.iway.iwcm.editor.DocNoteDB;
import sk.iway.iwcm.editor.EditorDB;
import sk.iway.iwcm.editor.rest.DocDetailsToDocHistoryMapper;
import sk.iway.iwcm.editor.util.EditorUtils;
import sk.iway.iwcm.i18n.Prop;
import sk.iway.iwcm.io.IwcmFile;
import sk.iway.iwcm.system.UrlRedirectDB;
import sk.iway.iwcm.system.context.ContextFilter;
import sk.iway.iwcm.system.datatable.NotifyBean;
import sk.iway.iwcm.system.datatable.NotifyBean.NotifyType;
import sk.iway.iwcm.system.datatable.ProcessItemAction;
import sk.iway.iwcm.system.multidomain.MultiDomainFilter;
import sk.iway.iwcm.system.spring.events.WebjetEvent;
import sk.iway.iwcm.system.spring.events.WebjetEventType;
import sk.iway.iwcm.users.UserDetails;
import sk.iway.iwcm.users.UsersDB;
import sk.iway.iwcm.utils.Pair;

/**
 * Servis pre ukladanie web stranok (tabulka documents a documents_history).
 *
 * NEPOUZIVAT standardne je potrebne pouzit EditorFacade, ktora zapuzdruje dalsie operacie pri ulozeni
 *
 * Servis je RequestScope aby pre kazdy request boli objeky oddelene (thread safe)
 */
@Service
@RequestScope
public class EditorService {

	//repozitare
	private DocDetailsRepository docRepo;
	private DocHistoryRepository historyRepo;
	private DocAtrRepository docAtrRepository;

	//service
	private MediaService mediaService;
	private ApproveService approveService;

	//autowired
	private HttpServletRequest request;

	//privatne objekty
	private Identity currentUser;
	private Prop prop;
	private GroupsDB groupsDB;
	private DocDB docDB;
	private DocNoteDB docNoteDB;
	private long now;

	//list upozorneni
    private List&lt;NotifyBean&gt; notify;

	/** atributy nastavene pocas ukladania **/

	//nastavene na true ak je potrebne vyvolat obnovenie stromovej struktury/datatabulky po ulozeni
<span class="pc" id="L104">	private boolean forceReload = false;</span>
	//ak je nastavene casove publikovanie tu bude po ulozeni hodnota zaciatku publikovania
<span class="pc" id="L106">	private Long publihStart = null;</span>
	//po ulozeni nastavene na true, ak sa stranka vypublikovala pre zobrazenie navstevnikmi web sidla
<span class="pc" id="L108">	private boolean pageSavedToPublic = false;</span>
	//po ulozeni nastavene na true, ak sa stranka ulozila ako pracovna kopia
<span class="pc" id="L110">	private boolean pageSavedAsWorkVersion = false;</span>

	@Autowired
    public EditorService(DocDetailsRepository docRepo, DocHistoryRepository historyRepo, DocAtrRepository docAtrRepository,
<span class="fc" id="L114">			MediaService mediaService, ApproveService approveService, HttpServletRequest request) {</span>
<span class="fc" id="L115">		this.request = request;</span>

<span class="fc" id="L117">		this.docRepo = docRepo;</span>
<span class="fc" id="L118">		this.historyRepo = historyRepo;</span>
<span class="fc" id="L119">		this.docAtrRepository = docAtrRepository;</span>

<span class="fc" id="L121">		this.mediaService = mediaService;</span>
<span class="fc" id="L122">		this.approveService = approveService;</span>

<span class="fc" id="L124">		this.currentUser = UsersDB.getCurrentUser(request);</span>
<span class="fc" id="L125">		this.prop = Prop.getInstance(request);</span>
<span class="fc" id="L126">		this.groupsDB = GroupsDB.getInstance();</span>
<span class="fc" id="L127">		this.docDB = DocDB.getInstance();</span>
<span class="fc" id="L128">		this.docNoteDB = DocNoteDB.getInstance();</span>
<span class="fc" id="L129">		this.now = Tools.getNow();</span>
<span class="fc" id="L130">		this.forceReload = false;</span>

<span class="fc" id="L132">		this.notify = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L133">	}</span>

<span class="nc" id="L135">	public EditorService() {}</span>

	/**
	 * Vrati DocDetails objekt podla zadaneho docId alebo historyId (ak je zadane)
	 *
	 * @param docId
	 * @param historyId
	 * @return
	 */
    public DocDetails getDoc(int docId, int historyId) {

<span class="fc" id="L146">        DocDetails doc = null;</span>
<span class="fc" id="L147">        DocHistory history = null;</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (historyId &lt;= 0) {</span>
<span class="fc" id="L150">			doc = docRepo.findById(docId);</span>
        } else {
<span class="fc" id="L152">            Optional&lt;DocHistory&gt; historyOptional = historyRepo.findById(Long.valueOf(historyId));</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">			if (historyOptional.isPresent()) {</span>
<span class="fc" id="L154">				history = historyOptional.get();</span>
<span class="fc" id="L155">				doc = DocDetailsToDocHistoryMapper.INSTANCE.docHistoryToDocDetails(history);</span>
			}
        }

<span class="pc bpc" id="L159" title="2 of 6 branches missed.">        if (historyId &gt; 0 &amp;&amp; history != null &amp;&amp; doc != null) {</span>
			//prenes hodnoty do DocDetails objektu z History (je to takto kvoli spatnej kompatibilite)
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">            if (history.getApprovedBy()!=null) doc.setHistoryApprovedBy(history.getApprovedBy());</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (history.getDisapprovedBy()!=null) doc.setHistoryDisapprovedBy(history.getDisapprovedBy());</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">            if (history.getActual()!=null) doc.setHistoryActual(history.getActual());</span>
        }

<span class="pc bpc" id="L166" title="2 of 6 branches missed.">        if (historyId &gt; -1 &amp;&amp; history != null &amp;&amp; doc != null) {</span>
<span class="fc" id="L167">            doc.setPublicable(Boolean.TRUE.equals(history.getPublicable()));</span>
<span class="fc" id="L168">			DocEditorFields def = doc.getEditorFields();</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">			if (def == null) {</span>
<span class="fc" id="L170">				def = new DocEditorFields();</span>
<span class="fc" id="L171">				doc.setEditorFields(def);</span>
			}
<span class="fc" id="L173">			def.setPublishAfterStart(doc.isPublicable());</span>
<span class="fc" id="L174">			def.setDisableAfterEnd(history.isDisableAfterEnd());</span>
        }

<span class="fc" id="L177">        return doc;</span>
    }

	/**
	 * Ulozi DocDetials do databazy vratane vsetkych akcii spojenych s ulozenim web stranky (schvalovanie, nastavenie adresara...)
	 * @param editedDoc
	 * @return historyId alebo hodnotu &lt; 1 ak nastala chyba
	 */
	public int saveEditedDoc(DocDetails editedDoc) {
<span class="fc" id="L186">		DebugTimer dt = new DebugTimer(&quot;EditorService.saveEditedDoc&quot;);</span>

		//first update savedate and author, check permissions need this
<span class="fc" id="L189">		editedDoc.setDateCreated(now);</span>
<span class="fc" id="L190">		editedDoc.setAuthorId(currentUser.getUserId());</span>

<span class="fc" id="L192">		boolean isNewPage = false;</span>
<span class="fc" id="L193">		int historyId = -1;</span>
<span class="fc" id="L194">		boolean wasApproved = false;</span>

<span class="fc" id="L196">		(new WebjetEvent&lt;&gt;(editedDoc, WebjetEventType.ON_START)).publishEvent();</span>

		//check that data are loaded
<span class="pc bpc" id="L199" title="3 of 6 branches missed.">		if (editedDoc.getData()==null || WebpagesService.DATA_NOT_LOADED.equals(editedDoc.getData().trim()) || (&quot;&lt;p&gt;&quot;+WebpagesService.DATA_NOT_LOADED+&quot;&lt;/p&gt;&quot;).equals(editedDoc.getData().trim())) {</span>
<span class="nc" id="L200">			throw new RuntimeException(prop.getText(&quot;components.docman.errorLoadingData&quot;)+&quot; &quot;+editedDoc.getDocId());</span>
		}

		//over, ci sa nezmenil adresar, ak ano, musis spravit reload stromu
<span class="fc bfc" id="L204" title="All 2 branches covered.">		if(editedDoc.getDocId() &gt; 0) {</span>
<span class="fc" id="L205">			int oldGroupId = docRepo.getGroupId(editedDoc.getDocId()).intValue();</span>
<span class="pc bpc" id="L206" title="1 of 4 branches missed.">			if (oldGroupId &gt; 0 &amp;&amp; oldGroupId != editedDoc.getGroupId()) forceReload = true;</span>
		}

		//kontrola prav
<span class="fc" id="L210">		checkPermissions(currentUser, editedDoc, false);</span>

<span class="pc bpc" id="L212" title="1 of 2 branches missed.">		if(Constants.getBoolean(&quot;editorEscapeInvalidCharacters&quot;)) {</span>
<span class="nc" id="L213">			editedDoc.setTitle(EditorUtils.escapeInvalidCharacters(editedDoc.getTitle(), prop, notify));</span>
<span class="nc" id="L214">			editedDoc.setData(EditorUtils.escapeInvalidCharacters(editedDoc.getData(), prop, notify));</span>
<span class="nc" id="L215">			editedDoc.setHtmlData(EditorUtils.escapeInvalidCharacters(editedDoc.getHtmlData(), prop, notify));</span>
		}

		//cloud - aby nebolo mozne premenovat Header / Footer
<span class="fc" id="L219">		DocDetails existing = CloudToolsForCore.isPossibleToChangeDoc(editedDoc.getDocId());</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">		if (existing != null) {</span>
			//nemozeme menit title ani groupid
<span class="nc" id="L222">			editedDoc.setTitle(existing.getTitle());</span>
<span class="nc" id="L223">			editedDoc.setGroupId(existing.getGroupId());</span>
		}

		//kvoli Oracle, on nedokaze mat v DB prazdny string a potom to padalo
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">		if (Tools.isEmpty(editedDoc.getTitle())) editedDoc.setTitle(&quot;new web page&quot;);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">		if (Tools.isEmpty(editedDoc.getNavbar())) editedDoc.setNavbar(editedDoc.getTitle());</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">		if (Tools.isEmpty(editedDoc.getData())) editedDoc.setData(&quot;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&quot;);</span>

		//nastav virtual path
<span class="fc" id="L232">		setVirtualPath(editedDoc);</span>
<span class="fc" id="L233">		dt.diff(&quot;after virtual path&quot;);</span>

<span class="fc" id="L235">		EditorUtils.nonBreakingSpaceReplacement(editedDoc);</span>

		//data nechceme mat ulozene s context linkami (tie nam prida filter, ak treba)
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">		if (ContextFilter.isRunning(request))</span>
<span class="nc" id="L239">			editedDoc.setData(ContextFilter.removeContextPath(request.getContextPath(), editedDoc.getData()));</span>

<span class="fc" id="L241">		String data = EditorUtils.getCleanBody(editedDoc.getData().trim());</span>
<span class="fc" id="L242">		dt.diff(&quot;after getCleanBody&quot;);</span>

<span class="fc" id="L244">		String dataAsc = EditorUtils.getDataAsc(data, editedDoc, false, request);</span>
<span class="fc" id="L245">		dt.diff(&quot;after getDataAsc&quot;);</span>

<span class="fc" id="L247">		editedDoc.setData(data);</span>
<span class="fc" id="L248">		editedDoc.setDataAsc(dataAsc);</span>

		//It's new page ?
<span class="fc bfc" id="L251" title="All 2 branches covered.">		if (editedDoc.getDocId() &lt; 1) {</span>
<span class="fc" id="L252">			isNewPage = true;</span>

			//If new page do not request publish, disable page
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">			if(!editedDoc.getEditorFields().isRequestPublish()) editedDoc.setAvailable(false);</span>
		}

		// Load approve hash table data
		// If current user is approver, set selfApprover = true
<span class="fc bfc" id="L260" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish()) {</span>
<span class="fc" id="L261">			approveService.loadApproveTables(editedDoc.getGroupId());</span>

			//If approver is needed BUT it's not selfApprove (currentUser isn't approver),
			//publish is NOT allowed (set publish as false) -&gt; because it's gonna waiting for approve
<span class="pc bpc" id="L265" title="1 of 4 branches missed.">			if(approveService.needApprove() &amp;&amp; !approveService.isSelfApproved())</span>
<span class="fc" id="L266">				editedDoc.getEditorFields().setRequestPublish(false);</span>
		}
<span class="fc" id="L268">		dt.diff(&quot;after requestPublish&quot;);</span>

<span class="fc" id="L270">		DocHistory editedHistory = DocDetailsToDocHistoryMapper.INSTANCE.docDetailsToDocHistory(editedDoc);</span>

<span class="fc bfc" id="L272" title="All 2 branches covered.">		if (isNewPage) {</span>
			//Save (insert) new webpage
<span class="fc" id="L274">			insertWebpage(editedDoc, dt);</span>
<span class="fc" id="L275">			editedHistory.setDocId(editedDoc.getDocId());</span>
		} else {
			//Update exist webpage
<span class="fc" id="L278">			updateWebpage(editedDoc, dt);</span>
		}

<span class="fc" id="L281">		dt.diff(&quot;after savedata, webpage Insert/Update&quot;);</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish()) {</span>
<span class="fc" id="L284">				pageSavedToPublic = true;</span>
		} else {
<span class="fc bfc" id="L286" title="All 2 branches covered.">			if (editedDoc.isPublishAfterStart()){</span>
<span class="fc" id="L287">				publihStart = Long.valueOf(editedDoc.getPublishStart());</span>
			} else {
<span class="fc" id="L289">				pageSavedAsWorkVersion = true;</span>
			}
		}
<span class="fc" id="L292">		dt.diff(&quot;after session set&quot;);</span>

		//vypne zapisovanie zaznamov do documents_history tabulky. true - nezapise zaznam do documents_history
<span class="fc" id="L295">		boolean disableHistory = Constants.getBoolean(&quot;editorDisableHistory&quot;);</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">		if(disableHistory) {</span>
<span class="nc" id="L297">			Logger.debug(EditorService.class, &quot;Write into documents_history is disabled&quot;);</span>
<span class="nc" id="L298">			historyId = 1;</span>
		}

		// If history is not disabled
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">		if (!disableHistory) {</span>
			// zisti, ci v historii na ten isty datum a cas nema byt nieco vypublikovane
<span class="fc bfc" id="L304" title="All 4 branches covered.">			if (editedDoc.getPublishStartDate() != null &amp;&amp; (editedDoc.getPublishStartDate().getTime()+60000)&gt;Tools.getNow()) {</span>
<span class="fc" id="L305">				List&lt;DocHistory&gt; waitingForPublish = historyRepo.findByDocIdAndPublishStartDate(editedDoc.getDocId(), editedDoc.getPublishStartDate());</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">				if (waitingForPublish != null) {</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">					for (DocHistory waiting : waitingForPublish) {</span>
<span class="fc" id="L308">						waiting.setPublicable(false);</span>
<span class="fc" id="L309">						waiting.setSyncStatus(1);</span>
<span class="fc" id="L310">						historyRepo.save(waiting);</span>
<span class="fc" id="L311">					}</span>
				}
			}
<span class="fc" id="L314">			dt.diff(&quot;after dochist is publicable&quot;);</span>

			// DocHistory entity, that represent change of original webpage (DocDetails entity)
<span class="fc" id="L317">			editedHistory.setPublicable(Boolean.valueOf(editedDoc.isPublishAfterStart()));</span>
<span class="fc" id="L318">			editedHistory.setData(data);</span>
<span class="fc" id="L319">			editedHistory.setDataAsc(dataAsc);</span>
<span class="fc" id="L320">			editedHistory.setSaveDate(new Date(now));</span>
<span class="fc" id="L321">			editedHistory.setActual(editedDoc.getEditorFields().isRequestPublish());</span>

			//Set ApprovedBy value, that indicate approve status
<span class="fc bfc" id="L324" title="All 2 branches covered.">			if (approveService.needApprove()) {</span>
				//Need approve
<span class="fc" id="L326">				editedHistory.setApprovedBy(-1);</span>
			} else {
				// Do not need approve
<span class="fc bfc" id="L329" title="All 2 branches covered.">				if(approveService.isSelfApproved()) {</span>
					//Page created by approver (automatic self approved), set approver id
<span class="fc" id="L331">					editedHistory.setApprovedBy(currentUser.getUserId());</span>
<span class="fc" id="L332">					wasApproved = true;</span>
				} else {
					//Not self approved, but do not need approve (probably folder that do not require approve)
<span class="fc bfc" id="L335" title="All 2 branches covered.">					if (editedDoc.getEditorFields().isRequestPublish()) {</span>
						//Publish without approver, soo approver is 0
<span class="fc" id="L337">						editedHistory.setApprovedBy(0);</span>
<span class="fc" id="L338">						wasApproved = true;</span>
					} else {
						//Do not publish, approver is -1
<span class="fc" id="L341">						editedHistory.setApprovedBy(-1);</span>
					}
				}
			}

<span class="fc bfc" id="L346" title="All 4 branches covered.">			if (!editedHistory.getEditorFields().isRequestPublish() &amp;&amp; approveService.needApprove())</span>
<span class="fc" id="L347">				editedHistory.setAwaitingApprove(&quot;,&quot; + approveService.getApproveUserIds() + &quot;,&quot;);</span>
			else
<span class="fc" id="L349">				editedHistory.setAwaitingApprove(null);</span>


			//Save edited history
<span class="fc" id="L353">			historyRepo.save(editedHistory);</span>
<span class="fc" id="L354">			dt.diff(&quot;after dochistory insert&quot;);</span>

			//ziskaj history_id
<span class="fc" id="L357">			historyId = editedHistory.getHistoryId();</span>
<span class="fc" id="L358">			dt.diff(&quot;after dochistory get id&quot;);</span>

			//Publishing
<span class="fc bfc" id="L361" title="All 2 branches covered.">			if(wasApproved) deleteHistorySaveRecords(editedDoc, editedHistory, historyId, dt);</span>
		}

		/*Odoslanie schvalovani a notifikacii*/
<span class="fc" id="L365">		approveService.sendEmails(editedDoc, historyId);</span>
<span class="fc" id="L366">		dt.diff(&quot;after sendApproveNotifyEmail&quot;);</span>

<span class="pc bpc" id="L368" title="1 of 6 branches missed.">		if(isNewPage || wasApproved || disableHistory) {</span>
			//In case of insert, actions are needed because page was saved, even when isn't approved
			// !! without this actions, insert page return 404
<span class="fc" id="L371">			renameVirtualPath(editedDoc, dt);</span>
<span class="fc" id="L372">			refreshCacheObjects(editedDoc, dt);</span>
<span class="fc" id="L373">			refreshTemplates(editedDoc, dt);</span>
<span class="pc bpc" id="L374" title="1 of 4 branches missed.">		} else if(editedDoc.isPublishAfterStart() || editedDoc.isDisableAfterEnd()) {</span>
			//reload awaiting pages for DocDB
<span class="fc" id="L376">			docDB.readPagesToPublic();</span>
		}

		/*Ulozenie poznamky*/
<span class="fc" id="L380">		saveRedactorNote(editedDoc, historyId);</span>
<span class="fc" id="L381">		dt.diff(&quot;after instances&quot;);</span>

		/*Finish*/
<span class="fc" id="L384">		auditSave(editedDoc, isNewPage, historyId);</span>

<span class="fc" id="L386">		dt.diff(&quot;done&quot;);</span>

		//Publikovanie eventov
<span class="fc" id="L389">		(new WebjetEvent&lt;&gt;(editedDoc, WebjetEventType.AFTER_SAVE)).publishEvent();</span>

<span class="fc" id="L391">		return(historyId);</span>
 	}

	/**
	 * Vrati instanciu noveho DocDetails
	 * @param docId - -1 alebo -DOCID sablony prazdnej stranky
	 * @param group - adresar kde ma vzniknut (podla toho sa nastavi sablona, sort priority...)
	 * @return
	 */
	public DocDetails prepareNewDocForEditor(int docId, GroupDetails group) {
		//ak je to admin
<span class="fc" id="L402">		DocDetails editedDoc = null;</span>
		//-1 je cisty dokument
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">		if (docId &lt; -1) {</span>
<span class="nc" id="L405">			editedDoc = getDoc(-docId, -1);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">			if (editedDoc != null) {</span>
<span class="nc" id="L407">				editedDoc.setDocId(-1);</span>
			}
		}

<span class="pc bpc" id="L411" title="1 of 2 branches missed.">		if (editedDoc == null) {</span>
<span class="fc" id="L412">			editedDoc = new DocDetails();</span>
<span class="fc" id="L413">			editedDoc.setDocId(-1);</span>
<span class="fc" id="L414">			editedDoc.setGroupId(group.getGroupId());</span>
<span class="fc" id="L415">			editedDoc.setData(&quot;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&quot;);</span>
<span class="fc" id="L416">			editedDoc.setTitle(prop.getText(&quot;editor.newDocumentName&quot;));</span>
<span class="fc" id="L417">			editedDoc.setSearchable(true);</span>
<span class="fc" id="L418">			editedDoc.setAvailable(Constants.getBoolean(&quot;editorNewDocDefaultAvailableChecked&quot;));</span>
<span class="fc" id="L419">			editedDoc.setShowInMenu(true);</span>
<span class="fc" id="L420">			editedDoc.setSortPriority(10);</span>
		} else {
			//nastav grupu na aktualne vybratu
<span class="nc" id="L423">			editedDoc.setDocId(-1);</span>
<span class="nc" id="L424">			editedDoc.setGroupId(group.getGroupId());</span>
<span class="nc" id="L425">			editedDoc.setTitle(prop.getText(&quot;editor.newDocumentName&quot;));</span>
<span class="nc" id="L426">			editedDoc.setNavbar(&quot;&quot;);</span>
<span class="nc" id="L427">			editedDoc.setVirtualPath(&quot;&quot;);</span>
<span class="nc" id="L428">			editedDoc.setExternalLink(&quot;&quot;);</span>
<span class="nc" id="L429">			editedDoc.setEventDateString(&quot;&quot;);</span>
<span class="nc" id="L430">			editedDoc.setEventTimeString(&quot;&quot;);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">			if (Constants.getBoolean(&quot;editorNewDocDefaultAvailableChecked&quot;) == false) editedDoc.setAvailable(false);</span>
		}

<span class="fc" id="L434">		editedDoc.setTempId(group.getTempId());</span>
		/*zisti maximalnu prioritu a zvys o 10*/
<span class="fc" id="L436">		editedDoc.setSortPriority(0);</span>
<span class="fc" id="L437">		boolean dirIsEmpty = true;</span>
<span class="fc" id="L438">		int maxPriority = DocDB.getMaxSortPriorityInGroup(group.getGroupId());</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">		if(maxPriority &gt; 0) {</span>
<span class="fc" id="L440">			editedDoc.setSortPriority(maxPriority);</span>
<span class="fc" id="L441">			dirIsEmpty = false;</span>
		}

<span class="pc bpc" id="L444" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;sortPriorityIncremental&quot;)) {</span>
<span class="fc" id="L445">			GroupDetails parentGroup = groupsDB.getGroup(group.getParentGroupId());</span>
<span class="fc bfc" id="L446" title="All 4 branches covered.">			if (parentGroup != null &amp;&amp; maxPriority &lt; parentGroup.getSortPriority()) {</span>
				//-10 lebo sa nam to o par riadkov nizsie navysi o 10
<span class="fc" id="L448">				maxPriority = parentGroup.getSortPriority() - 10;</span>
<span class="fc" id="L449">				editedDoc.setSortPriority(maxPriority);</span>
			}
		}

<span class="fc bfc" id="L453" title="All 2 branches covered.">		if (dirIsEmpty) {</span>
<span class="fc" id="L454">			editedDoc.setTitle(group.getGroupName());</span>
<span class="fc" id="L455">			editedDoc.setNavbar(group.getNavbarName());</span>
		}
<span class="fc" id="L457">		editedDoc.setSortPriority(editedDoc.getSortPriority() + 10);</span>

<span class="fc" id="L459">		WebpagesService.processFromEntity(editedDoc, ProcessItemAction.GETONE, request);</span>

<span class="fc" id="L461">		return editedDoc;</span>
	}

	/**
	 * Vrati existujuci DocDetails objekt podla zadaneho historyId/docId.
	 *
	 * Riesi aj problem s MultigroupMaping, kedy nacita udaje master dokumentu.
	 *
	 * @param docId
	 * @param historyId
	 * @return
	 */
	public DocDetails prepareDocForEditor(int docId, int historyId) {
<span class="nc" id="L474">		return prepareDocForEditor(docId, historyId, false);</span>
	}

	/**
	 * Vrati existujuci DocDetails objekt podla zadaneho historyId/docId.
	 * ak je ignoreMultigroupMapping=false Riesi aj problem s MultigroupMaping, kedy nacita udaje master dokumentu.
	 *
	 * @param docId
	 * @param historyId
	 * @param ignoreMultigroupMapping
	 * @return
	 */
	public DocDetails prepareDocForEditor(int docId, int historyId, boolean ignoreMultigroupMapping) {
<span class="fc" id="L487">		int docIdOriginal = docId;</span>

		//moznost nacitat slave data
		//int masterId = (request.getAttribute(&quot;keepSlave&quot;) != null &amp;&amp; &quot;true&quot;.equals(request.getAttribute(&quot;keepSlave&quot;))) ? 0 : MultigroupMappingDB.getMasterDocId(docId);
<span class="fc" id="L491">		int masterId = MultigroupMappingDB.getMasterDocId(docId);</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">        if(masterId &gt; 0) docId = masterId;</span>


<span class="fc" id="L495">		DocDetails editedDoc = null;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">		if (historyId &gt; 0) {</span>
<span class="fc" id="L497">			editedDoc = getDoc(-1, historyId);</span>
		} else {
<span class="fc" id="L499">			editedDoc = getDoc(docId, -1);</span>
		}

<span class="pc bpc" id="L502" title="1 of 2 branches missed.">		if (editedDoc == null) {</span>
<span class="nc" id="L503">			return(null);</span>
		} else {
<span class="fc" id="L505">			WebpagesService.processFromEntity(editedDoc, ProcessItemAction.GETONE, request);</span>

			//ak nacitavam slave clanok a chcem zachovat sort priority, tak NEnacitavam sort priority mastra
<span class="fc" id="L508">			boolean multiGroupkeepSortPriority = Constants.getBoolean(&quot;multiGroupKeepSortPriority&quot;);</span>
<span class="pc bpc" id="L509" title="1 of 4 branches missed.">			if(multiGroupkeepSortPriority &amp;&amp; masterId &gt; 0) {</span>
<span class="fc" id="L510">				DocDetails slave = docDB.getBasicDocDetails(docIdOriginal, false);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">				if(slave != null) editedDoc.setSortPriority(slave.getSortPriority());</span>
			}
		}

		//ak sa nacital slave dokument, nastav povodne ID, aby to v editore korektne nacitalo
<span class="fc bfc" id="L516" title="All 2 branches covered.">		if (masterId &gt; 0) {</span>
<span class="fc" id="L517">			editedDoc.setDocId(docIdOriginal);</span>

			//keep virtual path
<span class="fc" id="L520">			DocDetails slave = docDB.getBasicDocDetails(docIdOriginal, false);</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">			if (slave != null) editedDoc.setVirtualPath(slave.getVirtualPath());</span>
		}

<span class="fc" id="L524">		return editedDoc;</span>
	}

	/**
	 * Ulozi novo vytvorenu web stranku do databazy
	 * @param editedDoc
	 * @param requestPublish
	 * @param dt
	 * @param data
	 * @param dataAsc
	 */
	private void insertWebpage(DocDetails editedDoc, DebugTimer dt) {
		//Request publish could be set as false during loadApproveTables action (when author has no right to do this, and approve is needed)
<span class="fc bfc" id="L537" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish() == false) {</span>
<span class="fc" id="L538">			editedDoc.setAvailable(false);</span>
		} else {
			//If user has right, check if publish is in the future
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">			if (editedDoc.isPublishAfterStart()) {</span>
				//When to publish
<span class="nc" id="L543">				long publishStart = editedDoc.getPublishStart();</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">				if(publishStart != 0) {</span>
					//Is publish in the future ?
<span class="nc bnc" id="L546" title="All 2 branches missed.">					if (publishStart &gt; now) {</span>
						//For now, cancel publish and availability
<span class="nc" id="L548">						editedDoc.getEditorFields().setRequestPublish(false);</span>
<span class="nc" id="L549">						editedDoc.setAvailable(false);</span>

						//Add note when this is gonna be publish
						//Change data
<span class="nc" id="L553">						String publishDocData = prop.getText(&quot;editor.publish.note&quot;) + &quot; &quot; + editedDoc.getPublishStartString() + &quot; &quot; + editedDoc.getPublishStartTimeString();</span>
<span class="nc" id="L554">						editedDoc.setData(publishDocData);</span>
<span class="nc" id="L555">						editedDoc.setDataAsc(EditorUtils.getDataAsc(publishDocData, editedDoc, false, request));</span>
					}
				}
			}
		}

		//Unlike update, insert is gonna happen even if user have no rights
		//Reason is to show webpage to user, but page still need to be approve and is marked as red (waiting for approve)
<span class="fc" id="L563">		docSave(editedDoc, true, dt);</span>
<span class="fc" id="L564">	}</span>

	/**
	 * Ulozi do databazy existujucu web stranku
	 * @param editedDoc
	 * @param requestPublish
	 * @param dt
	 */
	private void updateWebpage(DocDetails editedDoc, DebugTimer dt) {
		//premenovanie Groupy ak je stranka defaultna pre Grupu.
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">		if(Constants.getBoolean(&quot;syncGroupAndWebpageTitle&quot;)) {</span>
<span class="fc" id="L575">			DocDB.changeGroupTitle(editedDoc.getGroupId(), editedDoc.getDocId(), editedDoc.getTitle());</span>
		}

		//Request publish could be set as false during loadApproveTables action (when author has no right to do this, and approve is needed)
<span class="fc bfc" id="L579" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish() == false) {</span>
<span class="fc" id="L580">			editedDoc.setAvailable(false);</span>
		} else {
			//If user has right, check if publish is in the future
<span class="fc bfc" id="L583" title="All 2 branches covered.">			if (editedDoc.isPublishAfterStart()) {</span>
				//When to publish
<span class="fc" id="L585">				long publishStart = editedDoc.getPublishStart();</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">				if(publishStart != 0) {</span>
					//Is publish in the future ?
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">					if (publishStart &gt; now) {</span>
						//For now, cancel publish and availability
<span class="fc" id="L590">						editedDoc.getEditorFields().setRequestPublish(false);</span>
<span class="fc" id="L591">						editedDoc.setAvailable(false);</span>
					}
				}
			}
		}

		//Unlike insert, update is gonna happen only IF requestPublish = true (sooo user have rights to do that)
<span class="fc bfc" id="L598" title="All 2 branches covered.">		if (editedDoc.getEditorFields().isRequestPublish()) docSave(editedDoc, false, dt);</span>
<span class="fc" id="L599">	}</span>

	/**
	 * Zmazanie web stranky, kontroluje prava pouzivatela, ak nema prava throwne RuntimeException
	 * @param doc
	 * @param publishEvents - true to publish WebjetEvents (default true)
	 * @return
	 */
	public boolean deleteWebpage(DocDetails doc, boolean publishEvents) {
<span class="fc" id="L608">		String result = deleteWebpageLogic(doc.getDocId(), approveService, publishEvents);</span>

		//All good
<span class="fc bfc" id="L611" title="All 2 branches covered.">		if(&quot;success&quot;.equals(result)) return true;</span>

		//Delete needs to be approved
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">		if(prop.getText(&quot;approveAction.err.cantApprove&quot;).equals(result)) {</span>
<span class="fc" id="L615">			String approversString = &quot;&quot;;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">			for(UserDetails approver : approveService.getApprovers()) {</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">				if(!approversString.isEmpty()) approversString += &quot;, &quot;;</span>
<span class="fc" id="L618">				approversString += approver.getFullName();</span>
<span class="fc" id="L619">			}</span>
<span class="fc" id="L620">			NotifyBean info = new NotifyBean(prop.getText(&quot;editor.approve.notifyTitle&quot;), prop.getText(&quot;editor.approveDeleteRequestGet&quot;)+&quot;: &quot;+approversString, NotifyBean.NotifyType.INFO, 60000);</span>
<span class="fc" id="L621">            addNotify(info);</span>

<span class="fc" id="L623">			return true;</span>
		}

		//Something wrong
<span class="nc" id="L627">		throw new RuntimeException(result);</span>
	}

	/**
	 * Pri funkcii Ulozit rozprazovanu verziu sa v history tabulke kopia pracovne zaznamy, tie pri publikovani zmazeme, ponechame len podla approveHistoryId
	 * @param editedDoc
	 * @param editedHistory
	 * @param historyId
	 * @param dt
	 */
	private void deleteHistorySaveRecords(DocDetails editedDoc, DocHistory editedHistory, int historyId, DebugTimer dt) {
		// zmaz stare dokumenty, ktore nie su schvalene
		List&lt;Integer&gt; historyIds;

<span class="fc" id="L641">		historyIds = historyRepo.findOldHistoryIds(editedHistory.getDocId(), Long.valueOf(historyId), false, currentUser.getUserId());</span>
<span class="fc" id="L642">		dt.diff(&quot;after was_approved history_id list&quot;);</span>

<span class="fc bfc" id="L644" title="All 2 branches covered.">		if (historyIds.isEmpty()==false) {</span>
<span class="fc" id="L645">			historyRepo.deleteHistoryOnPublish(historyIds, currentUser.getUserId());</span>
<span class="fc" id="L646">			dt.diff(&quot;after was_approved delete&quot;);</span>
		}

		//nastav aktualne na actual=false
<span class="fc" id="L650">		historyIds = historyRepo.findOldHistoryIds(editedDoc.getDocId(), historyId);</span>

<span class="fc bfc" id="L652" title="All 2 branches covered.">		if (historyIds.isEmpty()==false) historyRepo.updateActualHistory(false, &quot;&quot;, historyIds);</span>
<span class="fc" id="L653">		dt.diff(&quot;after was_approved&quot;);</span>
<span class="fc" id="L654">	}</span>

	/**
	 * Zapise auditny zaznam po ulozeni web stranky
	 * @param editedDoc
	 * @param isNewPage
	 * @param historyId
	 */
	private void auditSave(DocDetails editedDoc, boolean isNewPage, int historyId) {
<span class="fc" id="L663">		String newPageAppend = &quot;&quot;;</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">		if (isNewPage) newPageAppend = &quot; (newpage)&quot;;</span>

		//Priprava description textu pre admin log
<span class="fc" id="L667">		StringBuilder adminlogDescription = new StringBuilder();</span>
<span class="fc" id="L668">		adminlogDescription.append(&quot;Save Webpage&quot; + newPageAppend);</span>
<span class="fc" id="L669">		adminlogDescription.append(&quot; doc_id:&quot; + editedDoc.getDocId());</span>
<span class="fc" id="L670">		adminlogDescription.append(&quot; history_id:&quot; + historyId);</span>
<span class="fc" id="L671">		adminlogDescription.append(&quot; title: &quot; + editedDoc.getTitle());</span>
<span class="fc" id="L672">		adminlogDescription.append(&quot; path: &quot; + editedDoc.getVirtualPath());</span>

		//Zapisanie audit zaznamu
<span class="fc" id="L675">		Adminlog.add(Adminlog.TYPE_SAVEDOC, adminlogDescription.toString(), editedDoc.getDocId(), historyId);</span>
<span class="fc" id="L676">	}</span>

	/**
	 * Nastavi databazove stlpce root_group_lX s hodnotami ID adresarov na 1-3 urovni
	 * @param groupId
	 * @param editedDoc
	 */
	private void setRootGroupL(int groupId, DocDetails editedDoc) {
<span class="fc" id="L684">		List&lt;GroupDetails&gt; parentGroups = groupsDB.getParentGroups(groupId);</span>
<span class="fc" id="L685">		int[] rootGroupL = new int[3];</span>
<span class="fc" id="L686">		Arrays.fill(rootGroupL, 0);</span>
<span class="fc" id="L687">		int ind = 0;</span>

<span class="fc bfc" id="L689" title="All 2 branches covered.">		for(int i=parentGroups.size()-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L690">			rootGroupL[ind++] = parentGroups.get(i).getGroupId();</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">			if(ind == 3) break;</span>
		}

<span class="pc bpc" id="L694" title="1 of 2 branches missed.">		if(editedDoc != null) {</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">			if(rootGroupL[0] &gt; 0) editedDoc.setRootGroupL1(rootGroupL[0]);</span>
<span class="nc" id="L696">			else editedDoc.setRootGroupL1(null);</span>

<span class="fc bfc" id="L698" title="All 2 branches covered.">			if(rootGroupL[1] &gt; 0) editedDoc.setRootGroupL2(rootGroupL[1]);</span>
<span class="fc" id="L699">			else editedDoc.setRootGroupL2(null);</span>

<span class="fc bfc" id="L701" title="All 2 branches covered.">			if(rootGroupL[2] &gt; 0) editedDoc.setRootGroupL3(rootGroupL[2]);</span>
<span class="fc" id="L702">			else editedDoc.setRootGroupL3(null);</span>
		}
<span class="fc" id="L704">	}</span>

	/**
	 * Ulozi poznamku redaktora (alebo zmaze, ak je prazdna)
	 * @param editedDoc
	 * @param historyId
	 */
	private void saveRedactorNote(DocDetails editedDoc, int historyId) {
		//ulozenie poznamky pre redaktorov k webstranke
<span class="fc" id="L713">		DocNoteBean note = docNoteDB.getDocNote(editedDoc.getDocId(), -1);</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">		if(Tools.isNotEmpty(editedDoc.getEditorFields().getRedactorNote())) {</span>
			//ak je my_form.getEditorFields().isPublishAfterStart()==true, tak sa stranka publikuje v buducnosti. Poznamka sa nastavy v DocDB.copyDHistory(List&lt;PublicableForm&gt; copyDHtoD) a nie tu
<span class="pc bpc" id="L716" title="2 of 4 branches missed.">			if(editedDoc.getEditorFields().isRequestPublish() &amp;&amp; !editedDoc.getEditorFields().isPublishAfterStart()) {</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">				if(note == null) note = new DocNoteBean();</span>
<span class="fc" id="L718">				note.setDocId(editedDoc.getDocId());</span>
<span class="fc" id="L719">				note.setHistoryId(-1);</span>
<span class="fc" id="L720">				note.setNote(editedDoc.getEditorFields().getRedactorNote());</span>
<span class="fc" id="L721">				note.setUserId(editedDoc.getAuthorId());</span>
<span class="fc" id="L722">				note.setCreated(new Date());</span>
<span class="fc" id="L723">				note.save();</span>
			}

			//historia sa ulozi stale
<span class="fc" id="L727">			DocNoteBean noteHistory = docNoteDB.getDocNote(-1, historyId);</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">			if(noteHistory == null) noteHistory = new DocNoteBean();</span>
<span class="fc" id="L729">			noteHistory.setDocId(-1);</span>
<span class="fc" id="L730">			noteHistory.setHistoryId(historyId);</span>
<span class="fc" id="L731">			noteHistory.setNote(editedDoc.getEditorFields().getRedactorNote());</span>
<span class="fc" id="L732">			noteHistory.setUserId(editedDoc.getAuthorId());</span>
<span class="fc" id="L733">			noteHistory.setCreated(new Date());</span>
<span class="fc" id="L734">			noteHistory.save();</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">		} else if(note != null) {</span>
			//ak je zadana poznamka z formulara prazdna, tak existujucu note k stranke vymazeme
<span class="nc" id="L737">			note.delete();</span>
		}
<span class="fc" id="L739">	}</span>

	/**
	 * Nastavi stranke URL adresu (virtual_path), ak uz nejaka ina stranka takuto URL ma, tak prida cislo 1,2,3... na koniec URL adresy
	 * @param editedDoc
	 */
	private void setVirtualPath(DocDetails editedDoc) {
<span class="fc" id="L746">		String domain = groupsDB.getDomain(editedDoc.getGroupId());</span>
<span class="fc" id="L747">		int virtualPathConflictDocId = -1;</span>
<span class="pc bpc" id="L748" title="2 of 4 branches missed.">		if (Constants.getInt(&quot;linkType&quot;) == Constants.LINK_TYPE_HTML &amp;&amp; editedDoc.getVirtualPath().startsWith(&quot;javascript:&quot;) == false) {</span>
<span class="fc" id="L749">			boolean mustGenerateVirtualPath = false;</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">			if (Tools.isNotEmpty(editedDoc.getVirtualPath())) {</span>
<span class="fc" id="L751">				int actualDocId = DocDB.getDocIdFromURL(editedDoc.getVirtualPath(), domain);</span>
<span class="fc bfc" id="L752" title="All 4 branches covered.">				if (actualDocId &gt; 0 &amp;&amp; actualDocId != editedDoc.getDocId()) {</span>
<span class="fc" id="L753">					mustGenerateVirtualPath = true;</span>
<span class="fc" id="L754">					virtualPathConflictDocId = actualDocId;</span>
				}
			}

<span class="pc bpc" id="L758" title="1 of 6 branches missed.">			if (mustGenerateVirtualPath || Tools.isEmpty(editedDoc.getVirtualPath()) || editedDoc.getVirtualPath().indexOf('/') == -1) {</span>
				//nastavime ako treba
<span class="fc" id="L760">				String groupDiskPath = DocDB.getGroupDiskPath(groupsDB.getGroupsAll(), editedDoc.getGroupId());</span>
<span class="fc" id="L761">				DocDetails doc = new DocDetails();</span>
<span class="fc" id="L762">				doc.setDocId(editedDoc.getDocId());</span>
<span class="fc" id="L763">				doc.setTitle(editedDoc.getTitle());</span>
<span class="fc" id="L764">				doc.setNavbar(DB.prepareString(editedDoc.getNavbar(), 128));</span>
<span class="fc" id="L765">				doc.setVirtualPath(editedDoc.getVirtualPath());</span>
<span class="fc" id="L766">				doc.setGroupId(editedDoc.getGroupId());</span>
<span class="fc" id="L767">				String virtualPath = DocDB.getURL(doc, groupDiskPath);</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">				String ending = virtualPath.endsWith(&quot;/&quot;) ? &quot;/&quot; : &quot;.html&quot;;</span>
<span class="fc" id="L769">				String editorPageExtension = Constants.getString(&quot;editorPageExtension&quot;);</span>

<span class="pc bpc" id="L771" title="1 of 2 branches missed.">				for (int i = 1; i &lt; 1000; i++) {</span>
<span class="pc bpc" id="L772" title="2 of 4 branches missed.">					if(virtualPath != null &amp;&amp; virtualPath.length() &gt; 255) {</span>
<span class="nc" id="L773">						String vpTmp = virtualPath.substring(0, virtualPath.length() - ending.length());</span>
<span class="nc" id="L774">						vpTmp = DB.prepareString(vpTmp, 255 - ending.length()) + ending;</span>
<span class="nc" id="L775">						virtualPath = vpTmp;</span>
					}

<span class="fc" id="L778">					int allreadyDocId = DocDB.getDocIdFromURL(virtualPath, domain);</span>
<span class="fc" id="L779">					Logger.debug(EditorService.class, &quot;setVirtualPath: allreadyDocId for virtualPath: &quot; + virtualPath + &quot; ,docid: &quot; + allreadyDocId);</span>

<span class="fc bfc" id="L781" title="All 4 branches covered.">					if (allreadyDocId &lt;= 0 || allreadyDocId == editedDoc.getDocId()) { break; }</span>

					//lebo moze kolidovat uz z hora
<span class="fc bfc" id="L784" title="All 2 branches covered.">					if (virtualPathConflictDocId &lt; 1) virtualPathConflictDocId = allreadyDocId;</span>

<span class="fc" id="L786">					doc.setTitle(editedDoc.getTitle() + &quot; &quot; + i);</span>
<span class="fc" id="L787">					doc.setNavbar(DB.prepareString(editedDoc.getNavbar(), 128) + &quot; &quot; + i);</span>

<span class="pc bpc" id="L789" title="1 of 2 branches missed.">					if (&quot;/&quot;.equals(editorPageExtension)) {</span>
						//nastav cistu, handluje sa to nastavenim title s cislom vyssie
<span class="nc" id="L791">						doc.setVirtualPath(&quot;&quot;);</span>
					}
					else {
<span class="fc bfc" id="L794" title="All 2 branches covered.">						if (editedDoc.getVirtualPath().endsWith(&quot;.html&quot;)) {</span>
<span class="fc" id="L795">							doc.setVirtualPath(Tools.replace(editedDoc.getVirtualPath(), &quot;.html&quot;, &quot;-&quot; + i + &quot;.html&quot;));</span>
<span class="fc" id="L796">							ending = &quot;-&quot; + i + &quot;.html&quot;;</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">						} else if (editedDoc.getVirtualPath().endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L798">							doc.setVirtualPath(editedDoc.getVirtualPath() + i + &quot;.html&quot;);</span>
<span class="nc" id="L799">							ending = i + &quot;.html&quot;;</span>
<span class="pc bpc" id="L800" title="2 of 6 branches missed.">						} else if (Tools.isNotEmpty(editedDoc.getVirtualPath()) &amp;&amp; editedDoc.getVirtualPath().endsWith(&quot;/&quot;)==false &amp;&amp; editedDoc.getVirtualPath().contains(&quot;.html&quot;)==false) {</span>
							//url without last slash and without .html like /aaa/bbb
<span class="fc" id="L802">							doc.setVirtualPath(editedDoc.getVirtualPath() + &quot;-&quot; + i + &quot;.html&quot;);</span>
<span class="fc" id="L803">							ending = i + &quot;.html&quot;;</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">						} else if (Tools.isEmpty(editedDoc.getVirtualPath())) {</span>
<span class="fc" id="L805">							doc.setVirtualPath(Tools.replace(editedDoc.getTitle() + &quot;.html&quot;, &quot;/&quot;, &quot;-&quot;));</span>
<span class="fc" id="L806">							editedDoc.setVirtualPath(doc.getVirtualPath());</span>
<span class="fc" id="L807">							ending = &quot;.html&quot;;</span>
						}
					}

<span class="fc" id="L811">					virtualPath = DocDB.getURL(doc, groupDiskPath);</span>
				}

<span class="fc" id="L814">				editedDoc.setVirtualPath(DocDB.normalizeVirtualPath(virtualPath));</span>

<span class="fc" id="L816">				Logger.println(EditorService.class, &quot;nastaveny virtual path na:&quot;+virtualPath+&quot;;&quot;);</span>
<span class="fc" id="L817">			}</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">			else if (&quot;cloud&quot;.equals(Constants.getInstallName())) {</span>
				//tiket 15910 - kontrola specialnych znakov v URL
<span class="nc" id="L820">				String cleaned = DocTools.removeCharsDir(DB.internationalToEnglish(editedDoc.getVirtualPath())).toLowerCase();</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">				if(!cleaned.equals(editedDoc.getVirtualPath())) {</span>
<span class="nc" id="L822">					editedDoc.setVirtualPath(DocDB.normalizeVirtualPath(cleaned));</span>
<span class="nc" id="L823">					Logger.println(EditorService.class, &quot;virtual path upraveny na:&quot;+editedDoc.getVirtualPath()+&quot;;&quot;);</span>
				}
			}
		}
		//pre uz existujucu stranku, ktora ma automaticky generovane URL nezobrazuj varovanie (lebo sa vzdy generuje a zobrazi sa pri kazdom ulozeni)
<span class="pc bpc" id="L828" title="1 of 6 branches missed.">		if (virtualPathConflictDocId&gt;0 &amp;&amp; (Boolean.FALSE.equals(editedDoc.getGenerateUrlFromTitle()) || editedDoc.getDocId()&lt;1  ) ) {</span>
<span class="fc" id="L829">			NotifyBean notifyBean = new NotifyBean(prop.getText(&quot;text.warning&quot;), prop.getText(&quot;editor.virtual_path_allready_used_in_doc&quot;)+&quot;: &quot;+virtualPathConflictDocId, NotifyType.WARNING);</span>
<span class="fc" id="L830">			addNotify(notifyBean);</span>
		}
<span class="fc" id="L832">		String normalized = DocDB.normalizeVirtualPath(editedDoc.getVirtualPath());</span>
<span class="pc bpc" id="L833" title="1 of 6 branches missed.">		if (normalized!=null &amp;&amp; normalized.equals(editedDoc.getVirtualPath())==false &amp;&amp; editedDoc.getVirtualPath().contains(&quot;*&quot;)==false) editedDoc.setVirtualPath(normalized);</span>
<span class="fc" id="L834">	}</span>

	/**
	 * Ak sa zmeni virtual path stranky aktualizuje vsetky doterajsie linky
	 * @param docId
	 * @param oldLinkUrl //It's virtual path !!
	 * @param newVirtualPath
	 * @return
	 */
	private List&lt;DocDetails&gt; fixRenamedVirtualPath(int docId, String oldLinkURL, String newVirtualPath) {

<span class="fc" id="L845">		List&lt;DocDetails&gt; updated = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L846" title="2 of 4 branches missed.">		if (Tools.isEmpty(newVirtualPath) || Constants.getBoolean(&quot;editorDisableAutomaticRedirect&quot;)) return(updated);</span>

<span class="fc" id="L848">		newVirtualPath = DocDB.normalizeVirtualPath(newVirtualPath);</span>
<span class="fc" id="L849">		String domain = null;</span>

<span class="fc" id="L851">		Logger.println(EditorService.class, &quot;OldLinkURL: &quot; + oldLinkURL);</span>

		//Find the webpages, we need to rename
<span class="pc bpc" id="L854" title="1 of 4 branches missed.">		if (Tools.isNotEmpty(oldLinkURL) &amp;&amp; !oldLinkURL.equals(&quot;/showdoc.do?docid=&quot; + docId)) {</span>
<span class="fc" id="L855">			String newLinkURL = newVirtualPath;</span>
			//Logger.println(EditorService.class, &quot;newLinkURL=&quot;+newLinkURL);

<span class="fc bfc" id="L858" title="All 2 branches covered.">			if (oldLinkURL.compareTo(newLinkURL) != 0) {</span>
<span class="fc" id="L859">				String subGroupsIds = &quot;&quot;;</span>

				//Find domain (if need), and do it only on domain sub-pages
<span class="pc bpc" id="L862" title="1 of 2 branches missed.">				if (Constants.getBoolean(&quot;multiDomainEnabled&quot;) == true) {</span>
<span class="fc" id="L863">					DocDetails doc = docDB.getBasicDocDetails(docId, false);</span>
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">					if (doc != null) {</span>
<span class="fc" id="L865">						GroupDetails group = groupsDB.getGroup(doc.getGroupId());</span>
<span class="fc" id="L866">						domain = group.getDomainName();</span>
<span class="fc" id="L867">						subGroupsIds = groupsDB.getSubgroupsIds(domain);</span>
					}
				}

<span class="fc" id="L871">				Logger.debug(EditorService.class, &quot;fixRenamedVirtualPath: old=&quot; + oldLinkURL + &quot; new=&quot; + newLinkURL + &quot; domain=&quot; + domain);</span>

				//Replace all old URl to new in all pages
<span class="fc" id="L874">				updated = replaceUrl(oldLinkURL, newLinkURL, domain);</span>

				//aktualizuj presmerovania
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">				if(Tools.isNotEmpty(subGroupsIds)) {</span>
<span class="fc" id="L878">					int[] subGroupsArray = Tools.getTokensInt(subGroupsIds, &quot;,&quot;);</span>
					try {
<span class="fc" id="L880">						docRepo.updateRedirect(newLinkURL, oldLinkURL, subGroupsArray);</span>
<span class="nc" id="L881">					} catch (Exception ex) {</span>
						//asi prilis vela groupIds IN, skusme premenovat co sa da
<span class="nc" id="L883">						docRepo.updateRedirect(newLinkURL, oldLinkURL);</span>
<span class="fc" id="L884">					}</span>
<span class="fc" id="L885">				} else {</span>
<span class="nc" id="L886">					docRepo.updateRedirect(newLinkURL, oldLinkURL);</span>
				}

				//Update media
<span class="fc" id="L890">				mediaService.updateMediaLink(oldLinkURL, newLinkURL, domain);</span>

				//Write redirect
<span class="fc" id="L893">				UrlRedirectDB.addRedirect(oldLinkURL, newVirtualPath, domain, 301);</span>
			}
		}

<span class="fc" id="L897">		return(updated);</span>
	}

	/**
	 * Nahradi odkazy z povodneho na nove URL vo vsetkych strankach
	 * @param oldLinkURL
	 * @param newLinkURL
	 * @param domain
	 * @return
	 */
	private List&lt;DocDetails&gt; replaceUrl(String oldLinkURL, String newLinkURL, String domain) {
<span class="fc" id="L908">		List&lt;DocDetails&gt; docsUpdated = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L909">		String subgroupsIds = &quot;&quot;;</span>
		List&lt;DocDetails&gt; docs;

<span class="pc bpc" id="L912" title="1 of 2 branches missed.">		if (Constants.getBoolean(&quot;editorQuickUrlFix&quot; )== true) return docsUpdated;</span>

<span class="fc" id="L914">		DebugTimer dt = new DebugTimer(&quot;replaceUrl&quot;);</span>
<span class="fc" id="L915">		dt.diff(&quot;starting&quot;);</span>

<span class="fc" id="L917">		String oldLinkURL2 = oldLinkURL;</span>
<span class="pc bpc" id="L918" title="1 of 4 branches missed.">		if (oldLinkURL.length() &gt; 2 &amp;&amp; oldLinkURL.endsWith(&quot;/&quot;)) { oldLinkURL2 = oldLinkURL.substring(0, oldLinkURL.length() - 1); }</span>

		//zisti domenu (ak treba) a sprav to iba na substrankach domeny
<span class="pc bpc" id="L921" title="2 of 4 branches missed.">		if (Constants.getBoolean(&quot;multiDomainEnabled&quot;)==true &amp;&amp; Tools.isNotEmpty(domain)) {</span>
<span class="fc" id="L922">			subgroupsIds = groupsDB.getSubgroupsIds(domain);</span>

<span class="fc" id="L924">			docs = docRepo.findByDataLikeAndGroupIdIn(&quot;%&quot; + oldLinkURL2 + &quot;%&quot;, Tools.getTokensInt(subgroupsIds, &quot;,&quot;));</span>
		} else {
<span class="nc" id="L926">			docs = docRepo.findByDataLike(&quot;%&quot; + oldLinkURL2 + &quot;%&quot;);</span>
		}
<span class="fc" id="L928">		dt.diff(&quot;mam, pocet:&quot;+docs.size());</span>

		//We have list, now update it all
<span class="fc bfc" id="L931" title="All 2 branches covered.">		for (DocDetails doc : docs) {</span>
<span class="fc" id="L932">			Logger.println(EditorService.class, &quot;updating link in: &quot; + doc.getTitle());</span>

<span class="fc" id="L934">			String oldData = doc.getData();</span>
<span class="fc" id="L935">			doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL + &quot;'&quot;, &quot;'&quot; +newLinkURL + &quot;'&quot;));</span>
<span class="fc" id="L936">			doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL + &quot;\&quot;&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;\&quot;&quot;));</span>
			//toto robilo problem ked sa URL / menilo na /nieco-ine, menilo to aj 0903 / 100 100
			//doc.setData(Tools.replace(doc.getData(), &quot; &quot;+oldLinkURL+&quot; &quot;, &quot; &quot;+newLinkURL+&quot; &quot;));
<span class="fc" id="L939">			doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL + &quot;#&quot;, &quot;'&quot; + newLinkURL + &quot;#&quot;));</span>
<span class="fc" id="L940">			doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL + &quot;#&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;#&quot;));</span>
			//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL + &quot;#&quot;, &quot; &quot; + newLinkURL + &quot;#&quot;));

<span class="pc bpc" id="L943" title="2 of 4 branches missed.">			if (oldLinkURL.length()&gt;2 &amp;&amp; oldLinkURL.endsWith(&quot;/&quot;)) {</span>
				//fix na chybajuce koncove lomitko
<span class="nc" id="L945">				doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL2 + &quot;'&quot;, &quot;'&quot; + newLinkURL + &quot;'&quot;));</span>
<span class="nc" id="L946">				doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL2 + &quot;\&quot;&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;\&quot;&quot;));</span>
				//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL2 + &quot; &quot;, &quot; &quot; + newLinkURL + &quot; &quot;));
<span class="nc" id="L948">				doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL2 + &quot;#&quot;, &quot;'&quot; + newLinkURL + &quot;#&quot;));</span>
<span class="nc" id="L949">				doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL2 + &quot;#&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;#&quot;));</span>
				//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL2 + &quot;#&quot;, &quot; &quot; + newLinkURL + &quot;#&quot;));
<span class="pc bpc" id="L951" title="2 of 4 branches missed.">			} else if (oldLinkURL.length() &gt; 2 &amp;&amp; oldLinkURL.endsWith(&quot;.html&quot;) == false) {</span>
				//ak je linka bez koncoveho /, toto to vyriesi
<span class="nc" id="L953">				oldLinkURL2 = oldLinkURL + &quot;/&quot;;</span>

<span class="nc" id="L955">				doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL2 + &quot;'&quot;, &quot;'&quot; + newLinkURL + &quot;'&quot;));</span>
<span class="nc" id="L956">				doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL2 + &quot;\&quot;&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;\&quot;&quot;));</span>
				//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL2 + &quot; &quot;, &quot; &quot; + newLinkURL + &quot; &quot;));
<span class="nc" id="L958">				doc.setData(Tools.replace(doc.getData(), &quot;'&quot; + oldLinkURL2 + &quot;#&quot;, &quot;'&quot; + newLinkURL + &quot;#&quot;));</span>
<span class="nc" id="L959">				doc.setData(Tools.replace(doc.getData(), &quot;\&quot;&quot; + oldLinkURL2 + &quot;#&quot;, &quot;\&quot;&quot; + newLinkURL + &quot;#&quot;));</span>
				//doc.setData(Tools.replace(doc.getData(), &quot; &quot; + oldLinkURL2 + &quot;#&quot;, &quot; &quot; + newLinkURL + &quot;#&quot;));
			}

<span class="pc bpc" id="L963" title="1 of 2 branches missed.">			if (oldData.equals(doc.getData()) == false) {</span>
<span class="fc" id="L964">				dt.diff(&quot;updating doc:&quot; + doc.getDocId());</span>
<span class="fc" id="L965">				docRepo.updateAfterUrlReplace(doc.getData(), DB.internationalToEnglish(doc.getData()).toLowerCase(), doc.getDocId());</span>

<span class="fc" id="L967">				docsUpdated.add(doc);</span>
			}
			//DocDB.updateDataClob(db_conn, doc.getDocId(), -1, doc.getData(), DB.internationalToEnglish(doc.getData()).toLowerCase());
<span class="fc" id="L970">		}</span>
<span class="fc" id="L971">		dt.diff(&quot;done&quot;);</span>

<span class="fc" id="L973">		return(docsUpdated);</span>
	}

	//getre/setre

	/**
	 * Ak nastalo schvalovanie vrati zoznam schvalovatelov
	 * @return
	 */
	public List&lt;UserDetails&gt; getApprovers() {
<span class="fc" id="L983">		return approveService.getApprovers();</span>
	}

	/**
	 * Ak ma web stranka publikovanie v buducnosti nastavi sa sem timestamp zaciatku publikovania
	 * @return
	 */
	public Long getPublihStart() {
<span class="fc" id="L991">		return publihStart;</span>
	}

	/**
	 * Ak bola stranka uspesne vypublikovana na verejne zobrazenie vrati true
	 * @return
	 */
	public boolean isPageSavedToPublic() {
<span class="nc" id="L999">		return pageSavedToPublic;</span>
	}

	/**
	 * Ak bola stranka korektne ulozena ako rozpracovana verzia vrati true
	 * @return
	 */
	public boolean isPageSavedAsWorkVersion() {
<span class="fc" id="L1007">		return pageSavedAsWorkVersion;</span>
	}

	/**
	 * Vrati true ak je potrebne obnovit stromovu strukturu web stranok na GUI
	 * @return
	 */
<span class="fc" id="L1014">	public boolean isForceReload() { return forceReload; }</span>

	/**
	 * Vyvola reload=true atribut v JSON odpovedi pre obnovenie stromovej struktury/datatabulky
	 * @param forceReload
	 */
<span class="nc" id="L1020">	public void setForceReload(boolean forceReload) { this.forceReload = forceReload; }</span>

	/**
	 * Vrati zoznam moznych notifikacii pre pouzivatela
	 * @return
	 */
	public List&lt;NotifyBean&gt; getNotify() {
<span class="fc" id="L1027">		return notify;</span>
	}

	/**
	 * Prida notifikaciu
	 * @param notifyBean
	 */
	public void addNotify(NotifyBean notifyBean) {
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">        if(this.notify == null) this.notify = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1036">        this.notify.add(notifyBean);</span>
<span class="fc" id="L1037">    }</span>

	/**
	 * Overi, ci pouzivatel ma pravo na editaciu zadanej web stranky
	 * @param user
	 * @param doc
	 * @param isDelete
	 * @return
	 */
	public boolean isPageEditable(Identity user, DocDetails doc, boolean isDelete) {
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">		if (UsersDB.checkUserPerms(user, Constants.getString(&quot;webpagesFunctionsPerms&quot;)) == false) return false;</span>

<span class="fc bfc" id="L1049" title="All 2 branches covered.">		if (isDelete) {</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">			if (user.isDisabledItem(&quot;deletePage&quot;)) {</span>
<span class="fc" id="L1051">				return false;</span>
			}
<span class="pc bpc" id="L1053" title="1 of 4 branches missed.">		} else if (doc.getDocId()&lt;1 &amp;&amp; user.isDisabledItem(&quot;addPage&quot;)) {</span>
<span class="nc" id="L1054">			return false;</span>
<span class="pc bpc" id="L1055" title="1 of 4 branches missed.">		} else if (doc.getDocId()&gt;0 &amp;&amp; user.isDisabledItem(&quot;pageSave&quot;)) {</span>
<span class="nc" id="L1056">			return false;</span>
		}

<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">		if (doc == null) return true;</span>

		//otestuj, ci mame na tento dokument pristupove prava
<span class="fc" id="L1062">		boolean canAccess = GroupsDB.isGroupEditable(user, doc.getGroupId());</span>

<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">		if (!canAccess)</span>
		{
			//zisti, ci to nie je moja stranka
<span class="nc" id="L1067">			int[] editablePages = Tools.getTokensInt(user.getEditablePages(), &quot;,&quot;);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">			for (int id : editablePages)</span>
			{
<span class="nc bnc" id="L1070" title="All 2 branches missed.">				if (id == doc.getDocId())</span>
				{
<span class="nc" id="L1072">					canAccess = true;</span>
				}
			}
		}

		//kontrola pre slave adresare danej stranky
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">		if(!canAccess)</span>
		{
			int groupId;
<span class="nc bnc" id="L1081" title="All 2 branches missed.">			for (MultigroupMapping mapping : MultigroupMappingDB.getSlaveMappings(doc.getDocId()))</span>
			{
<span class="nc" id="L1083">				int dId = mapping.getDocId();</span>
<span class="nc" id="L1084">				groupId = DocDB.getInstance().getBasicDocDetails(dId, true).getGroupId();</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">				if (groupId &gt; 0) canAccess = GroupsDB.isGroupEditable(user, groupId);</span>
<span class="nc" id="L1086">				Logger.debug(EditorService.class, &quot;testujem pristup pre multigroup stranky [groupId=&quot;+groupId+&quot;] canAccess=&quot;+canAccess);</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">				if(canAccess) break;</span>
<span class="nc" id="L1088">			}</span>
		}

<span class="pc bpc" id="L1091" title="2 of 4 branches missed.">		if (canAccess &amp;&amp; Constants.getBoolean(&quot;adminCheckUserGroups&quot;))</span>
		{
<span class="nc bnc" id="L1093" title="All 2 branches missed.">			if (DocDB.canAccess(doc, user, true)==false)</span>
			{
<span class="nc" id="L1095">				 canAccess = false;</span>
			}
		}

<span class="fc" id="L1099">		return canAccess;</span>
	}

	/**
	 * Skontroluje prava na editaciu web stranky a throwne Runtime exception v pripade nedostatocnych prav
	 * @param user
	 * @param doc
	 * @param isDelete - nastavte na true, ak sa jedna o kontrolu prav pre mazanie stranky
	 */
	public void checkPermissions(Identity user, DocDetails doc, boolean isDelete) {
<span class="fc" id="L1109">		String errorKey = null;</span>
<span class="pc bpc" id="L1110" title="3 of 6 branches missed.">		if (user == null || UsersDB.checkUserPerms(user, Constants.getString(&quot;webpagesFunctionsPerms&quot;)) == false || doc == null) {</span>
<span class="nc" id="L1111">			errorKey = &quot;error.userNotLogged&quot;;</span>
<span class="fc bfc" id="L1112" title="All 4 branches covered.">		} else if (isDelete &amp;&amp; isPageEditable(user, doc, true)==false) {</span>
<span class="fc" id="L1113">			errorKey = &quot;admin.delete.deletePageDisabled.error&quot;;</span>
<span class="fc bfc" id="L1114" title="All 4 branches covered.">		} else if (doc.getDocId()&lt;1 &amp;&amp; user.isDisabledItem(&quot;addPage&quot;)) {</span>
<span class="fc" id="L1115">			errorKey = &quot;admin.addPage.addPageDisabled.error&quot;;</span>
<span class="fc bfc" id="L1116" title="All 4 branches covered.">		} else if (doc.getDocId()&gt;0 &amp;&amp; user.isDisabledItem(&quot;pageSave&quot;)) {</span>
<span class="fc" id="L1117">			errorKey = &quot;admin.editPage.error&quot;;</span>
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">		} else if (isPageEditable(user, doc, false)==false) {</span>
<span class="nc" id="L1119">			errorKey = &quot;admin.editPage.error&quot;;</span>
		}

<span class="fc bfc" id="L1122" title="All 2 branches covered.">		if (Tools.isNotEmpty(errorKey)) {</span>
<span class="fc" id="L1123">			throw new RuntimeException(prop.getText(errorKey));</span>
		}

<span class="fc" id="L1126">	}</span>

	public Prop getProp() {
<span class="nc" id="L1129">		return prop;</span>
	}

	/**
	 * Vrati mapu CSS stylov pre roletku vyberu stylu v editore
	 * @param baseCssPath
	 * @return
	 */
	public static List&lt;Map&lt;String, String&gt;&gt; getCssListJson(DocBasic doc) {
<span class="fc" id="L1138">		List&lt;Map&lt;String, String&gt;&gt; sessionCssParsed = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1140">		StringTokenizer stCss = new StringTokenizer(getCssPath(doc), &quot;,\n&quot;);</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">		while (stCss.hasMoreTokens())</span>
		{
<span class="fc" id="L1143">			String cssFile = stCss.nextToken();</span>
			//bootstrap neparsujeme, to by bol masaker
<span class="pc bpc" id="L1145" title="2 of 4 branches missed.">			if (cssFile.contains(&quot;bootstrap.min.css&quot;) || cssFile.contains(&quot;bootstrap.css&quot;)) continue;</span>

			//PathFilter.getRealPath je pouzity z dovodu najdenia custom_path pre vyvoj
<span class="fc" id="L1148">			IwcmFile file = new IwcmFile(PathFilter.getCustomPathRealPath(cssFile));</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">			if (!file.exists()) {</span>
				//skus najst subor s pridanym InstallName
<span class="fc" id="L1151">				file = new IwcmFile(PathFilter.getCustomPathRealPath(Tools.replace(cssFile, &quot;/templates/&quot;, &quot;/templates/&quot;+Constants.getInstallName()+&quot;/&quot;)));</span>
			}
<span class="fc bfc" id="L1153" title="All 2 branches covered.">			if (!file.exists()) {</span>
<span class="fc" id="L1154">				Logger.error(EditorService.class, &quot;Css file &quot; + file.getName() + &quot; not exist&quot;);</span>
<span class="fc" id="L1155">				continue;</span>
			}

			//ak subor konci na min.css skus najst neminifikovanu verziu
<span class="fc bfc" id="L1159" title="All 2 branches covered.">			if (file.getName().endsWith(&quot;.min.css&quot;)) {</span>
<span class="fc" id="L1160">				String path = Tools.replace(file.getAbsolutePath(), &quot;.min.css&quot;, &quot;.css&quot;);</span>
<span class="fc" id="L1161">				IwcmFile notMinified = new IwcmFile(path);</span>
<span class="pc bpc" id="L1162" title="2 of 4 branches missed.">				if (notMinified.exists() &amp;&amp; notMinified.canRead()) file = notMinified;</span>
			}

<span class="fc" id="L1165">			sk.iway.css.CssParser cssParser = new sk.iway.css.CssParser(file);</span>
<span class="fc" id="L1166">			List&lt;Pair&lt;String, String&gt;&gt; editorCss = cssParser.getElements();</span>
			try
			{
				//prehod na json format
<span class="fc bfc" id="L1170" title="All 2 branches covered.">				for(Pair&lt;String, String&gt; element : editorCss)</span>
				{
<span class="fc" id="L1172">					Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1173">					map.put(&quot;tag&quot;, element.getFirst());</span>
<span class="fc" id="L1174">					map.put(&quot;class&quot;, element.getSecond());</span>
<span class="fc" id="L1175">					sessionCssParsed.add(map);</span>
<span class="fc" id="L1176">				}</span>
			}
<span class="nc" id="L1178">			catch (Exception ex)</span>
			{
<span class="nc" id="L1180">				Logger.error(EditorService.class, ex);</span>
<span class="fc" id="L1181">			}</span>
<span class="fc" id="L1182">		}</span>

<span class="fc" id="L1184">		return sessionCssParsed;</span>
	}

	private static String getCssPath(DocBasic doc) {

<span class="fc" id="L1189">		String defaultBaseCssPath = &quot;/css/page.css&quot;; //NOSONAR</span>
<span class="fc" id="L1190">		String baseCssPath = null;</span>
<span class="fc" id="L1191">		TemplateDetails temp = TemplatesDB.getInstance().getTemplate(doc.getTempId());</span>
<span class="fc" id="L1192">		GroupDetails group = doc.getGroup();</span>
<span class="fc" id="L1193">		String domainName = null;</span>
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">		if (group != null) domainName = group.getDomainName();</span>

<span class="pc bpc" id="L1196" title="1 of 2 branches missed.">		if (temp != null) {</span>
<span class="fc" id="L1197">			baseCssPath = temp.getBaseCssPath();</span>
		}

<span class="pc bpc" id="L1200" title="3 of 6 branches missed.">		if (Tools.isNotEmpty(baseCssPath) &amp;&amp; Constants.getBoolean(&quot;multiDomainEnabled&quot;) == true &amp;&amp; Tools.isNotEmpty(domainName)) {</span>
			// baseCssPath = Tools.replace(baseCssPath, &quot;/css/&quot;,
			// &quot;/css/&quot;+MultiDomainFilter.getDomainAlias(editForm.getDomainName())+&quot;/&quot;);
<span class="fc" id="L1203">			baseCssPath = MultiDomainFilter.rewriteUrlToLocal(baseCssPath, MultiDomainFilter.getDomainAlias(domainName));</span>
		}

<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">		if (Tools.isEmpty(baseCssPath)) {</span>
<span class="nc" id="L1207">			baseCssPath = defaultBaseCssPath;</span>
		}

<span class="fc" id="L1210">		String editorCssPath = getEditorCssPath(baseCssPath);</span>
<span class="pc bpc" id="L1211" title="4 of 10 branches missed.">		if (baseCssPath != null &amp;&amp; baseCssPath.startsWith(&quot;/templates/&quot;) &amp;&amp; baseCssPath.contains(&quot;editor.css&quot;) == false &amp;&amp; editorCssPath != null &amp;&amp; editorCssPath.startsWith(&quot;/templates&quot;)) {</span>
<span class="fc" id="L1212">			baseCssPath += &quot;,&quot; + editorCssPath;</span>
		}

<span class="fc" id="L1215">		return baseCssPath;</span>
	}

	private static String getEditorCssPath(String baseCssPath) {
		String editorCss;
<span class="pc bpc" id="L1220" title="2 of 6 branches missed.">		if (baseCssPath != null &amp;&amp; baseCssPath.startsWith(&quot;/templates/&quot;) &amp;&amp; baseCssPath.contains(&quot;editor.css&quot;) == false) {</span>
			// skus automaticky dohladat aj editor.css v danom adresari
<span class="fc" id="L1222">			editorCss = baseCssPath.substring(0, baseCssPath.lastIndexOf(&quot;/&quot;)) + &quot;/editor.css&quot;;</span>
<span class="pc bpc" id="L1223" title="1 of 2 branches missed.">			if (FileTools.isFile(editorCss)) {</span>
<span class="fc" id="L1224">				return editorCss;</span>
			}
		}

<span class="fc" id="L1228">		editorCss = &quot;/css/editor.css&quot;;</span>
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">		if (FileTools.isFile(editorCss)) {</span>
<span class="nc" id="L1230">			return editorCss;</span>
		}

<span class="fc" id="L1233">		return null;</span>
	}

	public void saveAttrs(DocDetails doc, List&lt;DocAtrDefEntity&gt; attrs, boolean cleanBeforeSave) {
<span class="pc bpc" id="L1237" title="2 of 6 branches missed.">		if (doc == null || attrs == null || attrs.size()&lt;1) return;</span>

<span class="fc bfc" id="L1239" title="All 2 branches covered.">		if (cleanBeforeSave) {</span>
<span class="fc" id="L1240">			docAtrRepository.deleteAllByDocId(doc.getDocId());</span>
		}

<span class="fc bfc" id="L1243" title="All 2 branches covered.">		for (DocAtrDefEntity def : attrs) {</span>
<span class="fc" id="L1244">			DocAtrEntity atrEntity = def.getDocAtrEntityFirst();</span>
<span class="pc bpc" id="L1245" title="1 of 2 branches missed.">			if (atrEntity != null) {</span>
<span class="fc bfc" id="L1246" title="All 2 branches covered.">				if (cleanBeforeSave) atrEntity.setId(null);</span>
<span class="fc bfc" id="L1247" title="All 4 branches covered.">				if (atrEntity.getDocId()==null || cleanBeforeSave) atrEntity.setDocId(doc.getDocId());</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">				if (atrEntity.getAtrDef()==null) atrEntity.setAtrDef(def);</span>
<span class="fc" id="L1249">				docAtrRepository.save(atrEntity);</span>
			}
<span class="fc" id="L1251">		}</span>
<span class="fc" id="L1252">	}</span>

	/**
	 *
	 * @param editedDoc
	 * @param isInsert
	 * @param dt
	 */
	private void docSave(DocDetails editedDoc, boolean isInsert, DebugTimer dt) {
<span class="fc bfc" id="L1261" title="All 2 branches covered.">		if(isInsert) dt.diff(&quot;preparing insert&quot;);</span>
<span class="fc" id="L1262">		else dt.diff(&quot;preparing update data&quot;);</span>

<span class="fc" id="L1264">		GroupDetails group = groupsDB.getGroup(editedDoc.getGroupId());</span>
<span class="fc" id="L1265">		String fileName = null;</span>

<span class="pc bpc" id="L1267" title="1 of 4 branches missed.">		if (group != null &amp;&amp; group.isInternal() == false) fileName = groupsDB.getGroupNamePath(editedDoc.getGroupId());</span>

		//Cut string too maxLength 255, then set
<span class="fc" id="L1270">		editedDoc.setFileName(DB.prepareString(fileName,255));</span>

		// Set root groups L1, L2, L3
<span class="fc" id="L1273">		setRootGroupL(editedDoc.getGroupId(), editedDoc);</span>

<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">		if (Tools.isEmpty(editedDoc.getNavbar())) editedDoc.setNavbar(editedDoc.getTitle());</span>

<span class="fc bfc" id="L1277" title="All 2 branches covered.">		if(isInsert) {</span>
			// Insert new doc entity via DocDeailsRepository
<span class="fc" id="L1279">			docRepo.save(editedDoc);</span>
<span class="fc" id="L1280">			dt.diff(&quot;after insert&quot;);</span>

			// Set docId into entity (get id from DB)
<span class="fc" id="L1283">			editedDoc.setDocId(docRepo.findMaxIdByGroupIdAndTitle(editedDoc.getGroupId(), editedDoc.getTitle()));</span>
<span class="fc" id="L1284">			dt.diff(&quot;after setDocId&quot;);</span>
		} else {
			//Update webpage via DocDeailsRepository
<span class="fc" id="L1287">			docRepo.save(editedDoc);</span>
<span class="fc" id="L1288">			dt.diff(&quot;after update&quot;);</span>
		}

		//aktualizuj pripadne aj tab. perex_group_doc
<span class="fc" id="L1292">		DocDB.udpdatePerexGroupDoc(editedDoc.getDocId(), editedDoc.getPerexGroupString());</span>
<span class="fc" id="L1293">		dt.diff(&quot;after update perex group doc&quot;);</span>
<span class="fc" id="L1294">	}</span>

	private void renameVirtualPath(DocDetails editedDoc, DebugTimer dt) {
		//Ak sa zmeni virtual path stranky aktualizuje vsetky doterajsie linky
<span class="fc" id="L1298">		String oldLinkURL = DocDB.getURLFromDocId(editedDoc.getDocId(), request); //Get page old virtual path</span>

<span class="fc" id="L1300">		List&lt;DocDetails&gt; updated = fixRenamedVirtualPath(editedDoc.getDocId(), oldLinkURL, editedDoc.getVirtualPath());</span>
<span class="fc bfc" id="L1301" title="All 2 branches covered.">		if (updated.isEmpty()==false) {</span>
			//zobraz cez notifikaciu
<span class="fc" id="L1303">			StringBuilder changedPages = new StringBuilder();</span>
<span class="fc bfc" id="L1304" title="All 2 branches covered.">			for (DocDetails doc : updated) {</span>
<span class="fc" id="L1305">				changedPages.append(&quot;\n&lt;br/&gt;&quot;).append(doc.getDocId()).append(&quot;-&quot;).append(doc.getTitle());</span>
<span class="fc" id="L1306">			}</span>

<span class="fc" id="L1308">			NotifyBean notifyBean = new NotifyBean(prop.getText(&quot;text.info&quot;), prop.getText(&quot;editor.updatedDocs&quot;)+changedPages.toString(), NotifyType.INFO);</span>
<span class="fc" id="L1309">			addNotify(notifyBean);</span>
		}
<span class="fc" id="L1311">		dt.diff(&quot;after fixRenamedVirtualPath&quot;);</span>
<span class="fc" id="L1312">	}</span>

	/**
	 * Approve waiting DocHistory to change some webpage (can be update/insert).
	 * @param editedHistory
	 */
	public void approveDocHistory(DocHistory editedHistory) {
		//Set actual informations
<span class="nc" id="L1320">		editedHistory.setApprovedBy(currentUser.getUserId());</span>
<span class="nc" id="L1321">		editedHistory.setAwaitingApprove(null);</span>
<span class="nc" id="L1322">		editedHistory.setActual(true);</span>
<span class="nc" id="L1323">		editedHistory.setAvailable(true);</span>
<span class="nc" id="L1324">		editedHistory.setApproveDate(new Date(now));</span>

		//Create new version of DocDetails from DocHistory
<span class="nc" id="L1327">		DocDetails editedDoc = DocDetailsToDocHistoryMapper.INSTANCE.docHistoryToDocDetails(editedHistory);</span>

		//Inicialize editorFields
<span class="nc" id="L1330">		DocEditorFields def = new DocEditorFields();</span>
<span class="nc" id="L1331">		def.fromDocDetails(editedDoc, true);</span>
<span class="nc" id="L1332">		def.setRequestPublish(true);</span>
<span class="nc" id="L1333">		editedDoc.setEditorFields(def);</span>

<span class="nc" id="L1335">		DebugTimer dt = new DebugTimer(&quot;EditorService.saveEditedDoc&quot;);</span>

<span class="nc" id="L1337">		Logger.println(this,&quot;ApproveAction.approve&quot;);</span>

<span class="nc" id="L1339">		(new WebjetEvent&lt;&gt;(editedDoc, WebjetEventType.ON_START)).publishEvent();</span>

		//Check perms
<span class="nc" id="L1342">		checkPermissions(currentUser, editedDoc, false);</span>

		//Do update itself
<span class="nc" id="L1345">		updateWebpage(editedDoc, dt);</span>

		//Update docHistory record (no more waiting)
<span class="nc" id="L1348">		historyRepo.save(editedHistory);</span>

		//Delete other waiting docHistory records for this webpage
<span class="nc" id="L1351">		deleteHistorySaveRecords(editedDoc, editedHistory, editedHistory.getHistoryId(), dt);</span>

		//There can be situation that change is approved, but isRequestPublish = false because we are waiting for publishing date
<span class="nc bnc" id="L1354" title="All 2 branches missed.">		if(editedDoc.getEditorFields().isRequestPublish()) {</span>
			//IN case of update webpage, there is NEEDED to do some sort of adjustments and refresh

<span class="nc" id="L1357">			renameVirtualPath(editedDoc, dt);</span>
<span class="nc" id="L1358">			refreshCacheObjects(editedDoc, dt);</span>
<span class="nc" id="L1359">			refreshTemplates(editedDoc, dt);</span>
		}

<span class="nc" id="L1362">		(new WebjetEvent&lt;&gt;(editedDoc, WebjetEventType.AFTER_SAVE)).publishEvent();</span>
<span class="nc" id="L1363">	}</span>

	/**
	 * Refresh cache object. Used after DOC change, so this changes will show.
	 * @param editedDoc
	 * @param dt
	 */
	private void refreshCacheObjects(DocDetails editedDoc, DebugTimer dt) {
<span class="pc bpc" id="L1371" title="3 of 6 branches missed.">		if (editedDoc.getGroupId() == Constants.getInt(&quot;tempGroupId&quot;) || editedDoc.getGroupId() == Constants.getInt(&quot;menuGroupId&quot;) || editedDoc.getGroupId() == Constants.getInt(&quot;headerFooterGroupId&quot;)) {</span>
			//v system adresari pre istotu spravim klasicky refresh
<span class="nc" id="L1373">			docDB = DocDB.getInstance(true);</span>
<span class="nc" id="L1374">			dt.diff(&quot;after DocDB.getInstance&quot;);</span>
			/*spravime update dokumentu v indexe */
<span class="nc" id="L1376">			docDB.updateInternalCaches(editedDoc.getDocId());</span>
		} else {
<span class="fc" id="L1378">			docDB.updateInternalCaches(editedDoc.getDocId());</span>
<span class="fc" id="L1379">			dt.diff(&quot;after DocDB.update internal caches&quot;);</span>
		}
<span class="fc" id="L1381">	}</span>

	/**
	 * Refresh templates. Used after DOC change, so this changes will show.
	 * @param editedDoc
	 * @param dt
	 */
	private void refreshTemplates(DocDetails editedDoc, DebugTimer dt) {
<span class="fc" id="L1389">		boolean isInSystemFolder = false;</span>
<span class="pc bpc" id="L1390" title="2 of 4 branches missed.">		if (editedDoc.getVirtualPath()!=null &amp;&amp; editedDoc.getVirtualPath().startsWith(&quot;/system/&quot;)) isInSystemFolder = true;</span>
<span class="pc bpc" id="L1391" title="4 of 8 branches missed.">		if (isInSystemFolder || editedDoc.getGroupId() == Constants.getInt(&quot;tempGroupId&quot;) || editedDoc.getGroupId() == Constants.getInt(&quot;menuGroupId&quot;) || editedDoc.getGroupId() == Constants.getInt(&quot;headerFooterGroupId&quot;)) {</span>
<span class="nc" id="L1392">			TemplatesDB.getInstance(true);</span>
<span class="nc" id="L1393">			dt.diff(&quot;after templates DB getInstance&quot;);</span>
		}
<span class="fc" id="L1395">	}</span>

	/**
	 * Perform insert/update webpage action (aka waiting docHistory) by approve/reject throu calling ApproveSrvice.approveAction method
	 * @return
	 */
	public boolean approveAction() {
<span class="fc" id="L1402">		return approveService.approveAction(historyRepo, this);</span>
	}

	/**
	 * Perform delete webpage action (aka waiting docHistory) by approve/reject throu calling ApproveSrvice.approveDelAction method
	 * @return
	 */
	public boolean approveDelAction() {
<span class="fc" id="L1410">		return approveService.approveDelAction(historyRepo, docRepo, this);</span>
	}

	/**
	 * Delete webpage logic + checkPermissions and check approve posibility.
	 *
	 * It will move webpage to trash folder (soft delete) OR if delete is called from trash folder perform permanent delete.
	 * @param delDocId
	 * @param approveService
	 * @param publishEvents
	 * @return Return &quot;success&quot; or other string taht represend some sort of error taht occured
	 */
	protected String deleteWebpageLogic(int delDocId, ApproveService approveService, boolean publishEvents) {
		//If id is -1, try get id from request, if id is still -1 return eeror message
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">		if(delDocId == -1) delDocId = Tools.getIntValue(request.getParameter(&quot;docid&quot;), -1);</span>
<span class="pc bpc" id="L1425" title="1 of 2 branches missed.">		if(delDocId == -1) return &quot;There's no provided docId to by used for delete.&quot;;</span>

		//Try get DocDetails object by id, if not present return error message
<span class="fc" id="L1428">		Optional&lt;DocDetails&gt; docDetailsOpt = docRepo.findById(Long.valueOf(delDocId));</span>
<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">		if(!docDetailsOpt.isPresent()) {</span>
<span class="nc" id="L1430">			return &quot;Record by provided ID not found.&quot;;</span>
		}
<span class="fc" id="L1432">		DocDetails docDetails = docDetailsOpt.get();</span>

		//To check perms and approve for this action
<span class="fc" id="L1435">		checkPermissions(currentUser, docDetails, true);</span>
<span class="fc" id="L1436">		approveService.loadApproveTables(docDetails.getGroupId());</span>

		//Check if user can approve this action
<span class="pc bpc" id="L1439" title="1 of 4 branches missed.">		if(approveService.needApprove()==false || approveService.isSelfApproved()) {</span>
			//Doc, do not need approve OR
			//current user IS self approver, can do delete action

<span class="fc bfc" id="L1443" title="All 2 branches covered.">			if (publishEvents) (new WebjetEvent&lt;DocDetails&gt;(docDetails, WebjetEventType.ON_DELETE)).publishEvent();</span>

			// zisti ci sme v adresari /System/Trash (kos), ak nie presun, inak vymaz
<span class="fc" id="L1446">			String navbarNoHref = DB.internationalToEnglish(groupsDB.getURLPath(docDetails.getGroupId())).toLowerCase();</span>
<span class="fc" id="L1447">			Logger.println(EditorService.class,&quot;MAZEM: &quot; + navbarNoHref);</span>

			//tu sa vytvara adresar podla default jazyka, nie podla prihlaseneho pouzivatela!
<span class="fc" id="L1450">			Prop propSystem = Prop.getInstance(Constants.getString(&quot;defaultLanguage&quot;));</span>
<span class="fc" id="L1451">			String trashDirName = propSystem.getText(&quot;config.trash_dir&quot;);</span>
<span class="fc" id="L1452">			GroupDetails group = groupsDB.getGroup(docDetails.getGroupId());</span>

			//vypne zapisovanie zaznamov do documents_history tabulky. true - nezapise zaznam do documents_history
<span class="fc" id="L1455">			boolean disableHistory = Constants.getBoolean(&quot;editorDisableHistory&quot;);</span>
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">			GroupDetails trashGroupDetails = disableHistory == false ? groupsDB.getCreateGroup(trashDirName) : null;</span>

<span class="pc bpc" id="L1458" title="1 of 4 branches missed.">			if (trashGroupDetails==null || navbarNoHref.startsWith(DB.internationalToEnglish(groupsDB.getURLPath(trashGroupDetails.getGroupId())).toLowerCase()))  {</span>
					//Permanent DOC delete
<span class="fc" id="L1460">					docRepo.deleteById(Long.valueOf(delDocId));</span>

					//Every docHistory record awaiting for approve is canceled (DOC is deleted so changes waiting for approve are irelevant)
<span class="fc" id="L1463">					historyRepo.updateAwaitingApprove(&quot;&quot;, delDocId);</span>

					//Check, if DOC is main in the folder
<span class="pc bpc" id="L1466" title="1 of 2 branches missed.">                    if (group.getDefaultDocId() == delDocId)  {</span>
<span class="nc" id="L1467">                        List&lt;DocDetails&gt; pages = docDB.getDocByGroup(group.getGroupId(), DocDB.ORDER_PRIORITY, true, -1, -1, true);</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">                        if (pages.size() &gt; 0) {</span>
<span class="nc" id="L1469">                            docDetails = pages.get(0);</span>

<span class="nc bnc" id="L1471" title="All 2 branches missed.">                            if (docDetails != null) {</span>
<span class="nc" id="L1472">                                group.setDefaultDocId(docDetails.getDocId());</span>
<span class="nc" id="L1473">                                group.setSyncStatus(1);</span>
<span class="nc" id="L1474">                                groupsDB.setGroup(group);</span>
                            } else {
<span class="nc" id="L1476">                                group.setDefaultDocId(0);</span>
<span class="nc" id="L1477">                                group.setSyncStatus(1);</span>
<span class="nc" id="L1478">                                groupsDB.setGroup(group);</span>
                            }
                        }
                    }
                    //Set for ApproveDelAction (proof of succesfull delete)
<span class="pc bpc" id="L1483" title="1 of 2 branches missed.">                    if (request!=null) request.setAttribute(&quot;deleteSuccess&quot;, &quot;yes&quot;);</span>

					//delete doc from multigroup mapping
<span class="fc" id="L1486">					MultigroupMappingDB.deleteSlaveDocFromMapping(delDocId);</span>

                    //14.8.2012 pridany Admin log stranka bola vymazana uplne (z kosa)
<span class="fc" id="L1489">                    Adminlog.add(Adminlog.TYPE_PAGE_DELETE, &quot;(DocID: &quot;+delDocId+&quot;): Stranka bola uplne zmazana (z kosa)&quot;, delDocId, 0);</span>

<span class="fc" id="L1491">					List&lt;MultigroupMapping&gt; slaveMappingList = MultigroupMappingDB.getSlaveMappings(delDocId);</span>
<span class="pc bpc" id="L1492" title="1 of 4 branches missed.">					if(slaveMappingList != null &amp;&amp; slaveMappingList.isEmpty()==false) {</span>
<span class="fc" id="L1493">						List&lt;Long&gt; slaveIds = slaveMappingList.stream().map(x-&gt;Long.valueOf(x.getDocId())).collect(Collectors.toList());</span>

						//Delete all connections from multigroup table
<span class="fc" id="L1496">						MultigroupMappingDB.deleteSlaves(delDocId);</span>

						//Perform HARD (permanent) delete of slave pages
<span class="fc" id="L1499">						docRepo.deleteByDocIdIn(slaveIds);</span>

<span class="fc bfc" id="L1501" title="All 2 branches covered.">						for (Long slaveId : slaveIds) {</span>
<span class="fc" id="L1502">							DocDB.getInstance().updateInternalCaches(slaveId.intValue());</span>
<span class="fc" id="L1503">						}</span>

<span class="fc" id="L1505">						Adminlog.add(Adminlog.TYPE_PAGE_DELETE, &quot;(DocID's : &quot; + StringUtils.collectionToDelimitedString(slaveIds, &quot;,&quot;) + &quot;): Slave stranky boli uplne zmazane (hard delete)&quot;, delDocId, 0);</span>
					}
<span class="fc" id="L1507">            } else {</span>
                //failsafe na zle zmazane polozky (take co v kosi boli volakedy a zle sa zmazali)

<span class="fc" id="L1510">				List&lt;Integer&gt; groupIds = (new SimpleQuery()).forListInteger(&quot;SELECT group_id FROM groups WHERE group_id=parent_group_id&quot;);</span>

<span class="fc" id="L1512">				String ids = null;</span>
<span class="fc" id="L1513">				StringBuilder buf = null;</span>

<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">				for(Integer groupIdX : groupIds) {</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">					if (buf == null) buf = new StringBuilder(Integer.toString(groupIdX));</span>
<span class="nc" id="L1517">					else buf.append(',').append(groupIdX);</span>
<span class="nc" id="L1518">				}</span>

<span class="pc bpc" id="L1520" title="1 of 2 branches missed.">				if(buf != null) ids = buf.toString();</span>

<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">				if (ids != null) {</span>
<span class="nc" id="L1523">					new SimpleQuery().execute(&quot;UPDATE groups SET parent_group_id=? WHERE group_id IN (&quot; + ids + &quot;)&quot;);</span>
<span class="nc" id="L1524">					GroupsDB.getInstance(true);</span>
				}

                //presun to do trash adresara
<span class="fc" id="L1528">                Logger.println(EditorService.class,&quot;presuvam do trash adresara&quot;);</span>

				//Soft delete, move to thash folder
<span class="fc" id="L1531">				docRepo.moveToTrash(false, trashGroupDetails.getGroupId(), delDocId);</span>

				//Every docHistory record awaiting for approve is canceled (DOC is deleted so changes waiting for approve are irelevant)
<span class="fc" id="L1534">				historyRepo.updateAwaitingApprove(&quot;&quot;, delDocId);</span>

                //Check, if DOC is main in the folder
<span class="pc bpc" id="L1537" title="2 of 4 branches missed.">                if (group!=null &amp;&amp; group.getDefaultDocId() == delDocId) {</span>
<span class="nc" id="L1538">                    List&lt;DocDetails&gt; pages = docDB.getDocByGroup(group.getGroupId(), DocDB.ORDER_PRIORITY, true, -1, -1, true);</span>
<span class="nc bnc" id="L1539" title="All 2 branches missed.">                    if (pages.size() &gt; 0) {</span>
<span class="nc" id="L1540">                        docDetails = pages.get(0);</span>

<span class="nc bnc" id="L1542" title="All 2 branches missed.">                        if (docDetails!=null) {</span>
<span class="nc" id="L1543">                            group.setDefaultDocId(docDetails.getDocId());</span>
<span class="nc" id="L1544">                            group.setSyncStatus(1);</span>
<span class="nc" id="L1545">                            groupsDB.setGroup(group);</span>
                        } else {
<span class="nc" id="L1547">							group.setDefaultDocId(0);</span>
<span class="nc" id="L1548">							group.setSyncStatus(1);</span>
<span class="nc" id="L1549">							groupsDB.setGroup(group);</span>
						}
                    }
                }
				//Set for ApproveDelAction (proof of succesfull delete)
<span class="pc bpc" id="L1554" title="1 of 2 branches missed.">                if (request != null) request.setAttribute(&quot;deleteSuccess&quot;, &quot;yes&quot;);</span>
                //Admin log stranka bola presunuta do kosa
<span class="fc" id="L1556">                Adminlog.add(Adminlog.TYPE_PAGE_DELETE, &quot;(DocID: &quot; + delDocId + &quot;): Stranka bola presunuta do kosa &quot;, delDocId, 0);</span>
            }
<span class="fc" id="L1558">            DocDB.getInstance().updateInternalCaches(delDocId);</span>

<span class="fc bfc" id="L1560" title="All 2 branches covered.">			if (publishEvents) (new WebjetEvent&lt;DocDetails&gt;(docDetails, WebjetEventType.AFTER_DELETE)).publishEvent();</span>

			//Success signlization
<span class="fc" id="L1563">			return &quot;success&quot;;</span>
		} else {
			//Doc NEED's approve, BUT current user is NOT selfApprover, so he can't approve this shit

			//ziskaj aktualne vypublikovane history_id
<span class="fc" id="L1568">			Optional&lt;Integer&gt; actualPublishedHistoryIdOpt = historyRepo.findMaxHistoryId(delDocId, true);</span>

			//!! BUG FIX - If page is stil waiting to be approven (as inserted)
			//If approver try delete this page it's gonna be ok, BUT in this (non approver) case actualPublishedHistoryId is empty
<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">			if(!actualPublishedHistoryIdOpt.isPresent()) return &quot;Something went wrong. Page probably isn't exist.&quot;;</span>
<span class="fc" id="L1573">			int actualPublishedHistoryId  = actualPublishedHistoryIdOpt.get();</span>

			//vypne zapisovanie zaznamov do documents_history tabulky. true - nezapise zaznam do documents_history
<span class="fc" id="L1576">            boolean disableHistory =  Constants.getBoolean(&quot;editorDisableHistory&quot;);</span>
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">            if(disableHistory) {</span>
<span class="nc" id="L1578">                Logger.debug(EditorDB.class, &quot;Write into documents_history is disabled&quot;);</span>
            } else {
<span class="fc" id="L1580">				Logger.println(EditorService.class,&quot;approveByUsersId=&quot; + approveService.getApproveUserIds());</span>

				//Convert DocDetail to DocHistory entity (this new entity will be inserted)
<span class="fc" id="L1583">				DocHistory docHistory = prepareDeleteDocHistoryEntityFromDocDetails(docDetails);</span>

				//Save
<span class="fc" id="L1586">				historyRepo.save(docHistory);</span>

				//Id of new docHistory entity
<span class="fc" id="L1589">				int historyId = historyRepo.findMaxHistoryId(delDocId);</span>

				//Send request's to this deleet action
<span class="fc" id="L1592">				approveService.sendWebpageApproveDelRequestEmail(docHistory, historyId, actualPublishedHistoryId);</span>

				//9.8.2012 pridany audit o zmazani suboru
<span class="fc" id="L1595">				Adminlog.add(Adminlog.TYPE_PAGE_DELETE, &quot;(DocID: &quot;+delDocId+&quot;): Stranka poziadana o vymazanie : &quot; + approveService.getEmailsToNotify(null), delDocId, 0);</span>
			}

			//Can't approve signalization
<span class="fc" id="L1599">			return prop.getText(&quot;approveAction.err.cantApprove&quot;);</span>
		}
	}

	private DocHistory prepareDeleteDocHistoryEntityFromDocDetails(DocDetails docDetails) {
		//Convert DocDetail to DocHistory entity (this new entity will be inserted)
<span class="fc" id="L1605">		DocHistory docHistory = DocDetailsToDocHistoryMapper.INSTANCE.docDetailsToDocHistory(docDetails);</span>

		//General setting - !! there MUST be set &quot;[DELETE]&quot; as delete prefix, that indicates delete intend
<span class="fc" id="L1608">		docHistory.setTitle(&quot;[DELETE] &quot; + docHistory.getTitle());</span>
<span class="fc" id="L1609">		docHistory.setData(prop.getText(&quot;approve.delete.doctext&quot;));</span>
<span class="fc" id="L1610">		docHistory.setDataAsc(&quot;[DELETE]&quot;);</span>

		//When created and by who
<span class="fc" id="L1613">		docHistory.setDateCreated(now);</span>
<span class="fc" id="L1614">		docHistory.setSaveDate(new Date(now));</span>
<span class="fc" id="L1615">		docHistory.setAuthorId(currentUser.getUserId());</span>

		//Set availability of page etc
<span class="fc" id="L1618">		docHistory.setSearchable(false);</span>
<span class="fc" id="L1619">		docHistory.setCacheable(false);</span>
<span class="fc" id="L1620">		docHistory.setAvailable(false);</span>
<span class="fc" id="L1621">		docHistory.setActual(false);</span>

		//Mark docHistory as waiting for approve (need's approve by approver)
<span class="fc" id="L1624">		docHistory.setApprovedBy(-1);</span>
<span class="fc" id="L1625">		docHistory.setAwaitingApprove(&quot;,&quot; + approveService.getApproveUserIds() + &quot;,&quot;);</span>

<span class="fc" id="L1627">		return docHistory;</span>
	}

	/**
	 * Recover webpage from trash folder:
	 * - set groupId from history (latest where actual=1 or latest)
	 * - set available from history (latest where actual=1 or latest)
	 * @param recoverDocId
	 */
	public void recoverWebpageFromTrash(int recoverDocId) {
<span class="pc bpc" id="L1637" title="1 of 2 branches missed.">		if(recoverDocId &lt;1) throw new RuntimeException(&quot;recoverDocId is not valid&quot;);</span>

		//Try get DocDetails object by id, if not present return error message
<span class="fc" id="L1640">		Optional&lt;DocDetails&gt; docDetailsOpt = docRepo.findById(Long.valueOf(recoverDocId));</span>
<span class="pc bpc" id="L1641" title="1 of 2 branches missed.">		if(!docDetailsOpt.isPresent()) throw new RuntimeException(&quot;DocDetails doesn't exists.&quot;);</span>
<span class="fc" id="L1642">		DocDetails docDetailsToRecover = docDetailsOpt.get();</span>

		//To check perms and approve for this action
<span class="fc" id="L1645">		checkPermissions(currentUser, docDetailsToRecover, true);</span>

		//Find last actual (if posible) history id (so we know wehre to recover page)
<span class="fc" id="L1648">		Integer historyId = null;</span>
<span class="fc" id="L1649">		Optional&lt;Integer&gt; historyIdOpt = historyRepo.findMaxHistoryId(recoverDocId, true); //(actual history id)</span>
<span class="pc bpc" id="L1650" title="1 of 2 branches missed.">		if(historyIdOpt.isPresent())</span>
<span class="fc" id="L1651">			historyId = historyIdOpt.get();</span>
<span class="nc" id="L1652">		else historyId = historyRepo.findMaxHistoryId(recoverDocId); //(any history id)</span>

<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">		if(historyId == null) {</span>
			//There is no history
<span class="nc" id="L1656">			NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notifyTitle&quot;), prop.getText(&quot;editor.recover.notify.no_history&quot;), NotifyBean.NotifyType.WARNING, 60000);</span>
<span class="nc" id="L1657">            addNotify(info);</span>
<span class="nc" id="L1658">			return;</span>
		} else {
<span class="fc" id="L1660">			Optional&lt;Integer&gt; destGroupId = historyRepo.findGroupIdById(Long.valueOf(historyId));</span>
<span class="pc bpc" id="L1661" title="1 of 2 branches missed.">			if(!destGroupId.isPresent()) {</span>
<span class="nc" id="L1662">				NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notifyTitle&quot;), prop.getText(&quot;editor.recover.notify.no_history&quot;), NotifyBean.NotifyType.WARNING, 60000);</span>
<span class="nc" id="L1663">            	addNotify(info);</span>
<span class="nc" id="L1664">				return;</span>
			}
<span class="fc" id="L1666">			GroupDetails destGroup = groupsDB.getGroup(destGroupId.get());</span>
<span class="fc bfc" id="L1667" title="All 2 branches covered.">			if(destGroup == null) {</span>
<span class="fc" id="L1668">				NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notifyTitle&quot;), prop.getText(&quot;editor.recover.notify.no_history&quot;), NotifyBean.NotifyType.WARNING, 60000);</span>
<span class="fc" id="L1669">            	addNotify(info);</span>
<span class="fc" id="L1670">				return;</span>
			}

			//Check perms
<span class="fc" id="L1674">			approveService.loadApproveTables(destGroup.getGroupId());</span>
<span class="pc bpc" id="L1675" title="3 of 4 branches missed.">			if(approveService.needApprove() == false || approveService.isSelfApproved()) {</span>
				//Have right
<span class="fc" id="L1677">				docDetailsToRecover.setGroupId(destGroup.getGroupId());</span>
<span class="fc" id="L1678">				docDetailsToRecover.setAvailable(true);</span>
<span class="fc" id="L1679">				docRepo.save(docDetailsToRecover);</span>
			} else {
				//No right
<span class="nc" id="L1682">				NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notifyTitle&quot;), prop.getText(&quot;editor.recover.notify.no_right&quot;), NotifyBean.NotifyType.WARNING, 60000);</span>
<span class="nc" id="L1683">				addNotify(info);</span>
<span class="nc" id="L1684">				return;</span>
			}
		}

		//Refresh
<span class="fc" id="L1689">		DocDB.getInstance(true);</span>
<span class="fc" id="L1690">		GroupsDB.getInstance(true);</span>

		//Success
<span class="fc" id="L1693">		NotifyBean info = new NotifyBean(prop.getText(&quot;editor.recover.notify_title.success_page&quot;), prop.getText(&quot;editor.recover.notify_body.success_page&quot;, docDetailsToRecover.getTitle(), docDetailsToRecover.getFullPath()), NotifyBean.NotifyType.SUCCESS, 60000);</span>
<span class="fc" id="L1694">		addNotify(info);</span>
<span class="fc" id="L1695">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>